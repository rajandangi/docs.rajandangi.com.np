{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to docs.rajandangi","text":"<p>Experienced full-stack web developer with over 4 years of expertise in modern technologies. Proficient in developing scalable, high-performance web applications and passionate about solving complex problems.</p>"},{"location":"#core-expertise","title":"Core Expertise","text":"<ul> <li> <p> PHP Development</p> <p>Laravel, WordPress, Moodle.</p> </li> <li> <p> JavaScript Mastery</p> <p>React, Node.js, Vue.js, Next.js</p> </li> <li> <p> Python &amp; AI Development</p> <p>AI applications using RAG and NLP technologies.</p> </li> <li> <p> DevOps &amp; Server Management</p> <p>Docker, CI/CD, and server optimization.</p> </li> <li> <p> CSS &amp; Design Frameworks</p> <p>SCSS, SASS, Bootstrap, and Tailwind CSS.</p> </li> <li> <p> SEO</p> <p>GTM, GA/GA4, Matomo</p> </li> </ul>"},{"location":"#key-strengths","title":"Key Strengths","text":"<ul> <li> <p> Project Management</p> <p>Agile and Scrum methodologies for efficient project delivery.</p> </li> <li> <p> Analytical Skills</p> <p>Ensuring scalability and security in solutions.</p> </li> <li> <p> Customer Interaction</p> <p>Requirement analysis, client collaboration, and technical support.</p> </li> <li> <p> Testing</p> <p>Unit testing, integration testing, and performance testing.</p> </li> </ul>"},{"location":"#technical-skills","title":"Technical Skills","text":"<ul> <li> <p> Languages</p> <p>PHP, JavaScript, Python</p> </li> <li> <p> Databases</p> <p>MySQL, PostgreSQL</p> </li> <li> <p> Frameworks</p> <p>Laravel, React, Node, Vue, Bootstrap</p> </li> <li> <p> Tools</p> <p>Docker, VsCode, Git, SSH, Jira, Postman, NPM, Composer</p> </li> <li> <p> CMS/LMS</p> <p>WordPress, Moodle, Moodle Workplace</p> </li> <li> <p> Operating Systems</p> <p>Linux, Unix, Windows, macOS</p> </li> </ul>"},{"location":"#lets-connect","title":"Let's Connect","text":"<ul> <li> Email</li> <li> LinkedIn</li> <li> Portfolio</li> <li> GitHub</li> <li> Medium</li> <li> Upwork</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/","title":"Download protected pdf from google drive","text":"<p>Ever found yourself frustrated by a view-only PDF in Google Drive that you desperately need to download? You're not alone. Today I'm sharing a powerful, tested solution that actually works.</p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#the-protected-pdf-problem-why-google-makes-it-difficult","title":"The Protected PDF Problem: Why Google Makes It Difficult","text":"<p>We've all been there \u2013 you find the perfect resource, but it's locked behind Google Drive's \"view only\" restriction. While Google implements these protections for valid copyright reasons, there are legitimate scenarios where downloading is necessary:</p> <ul> <li>Accessing academic materials you need offline</li> <li>Saving conference materials for later reference</li> <li>Backing up your own documents shared through limited-access links</li> </ul> <p>Important Ethical Reminder</p> <p>This tutorial is provided strictly for educational purposes. Always respect copyright laws and terms of service. Only use this technique for content you have legitimate permission to download.</p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#the-javascript-solution-download-in-high-resolution","title":"The JavaScript Solution: Download in High Resolution","text":"<p>Unlike other methods that produce poor-quality screenshots or incomplete files, this approach creates a perfect, high-resolution PDF with all pages intact. Here's why this method is superior:</p> <ul> <li> Preserves image quality at optimal resolution</li> <li> Maintains proper page formatting</li> <li> Works with multi-page documents</li> <li> Creates a standard PDF file compatible with all readers</li> <li> Doesn't require installing suspicious third-party software</li> </ul>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<p>Follow these simple steps to download your protected PDF:</p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#1-prepare-the-document","title":"1. Prepare the Document","text":"<p>Open the protected PDF in Google Drive and scroll to the very bottom. This crucial step ensures all pages are loaded into your browser's memory.</p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#2-access-developer-tools","title":"2. Access Developer Tools","text":"<p>Right-click anywhere on the page and select \"Inspect\" or press: - Windows/Linux: <code>Ctrl+Shift+I</code> - Mac: <code>Cmd+Option+I</code></p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#3-navigate-to-console","title":"3. Navigate to Console","text":"<p>Click on the \"Console\" tab in the developer tools panel. This is where we'll run our PDF-generating script.</p>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#4-run-the-magic-script","title":"4. Run the Magic Script","text":"<p>Copy the entire code block below and paste it into the console:</p> <pre><code>let trustedURL;\nif (window.trustedTypes &amp;&amp; trustedTypes.createPolicy) {\n    const policy = trustedTypes.createPolicy('myPolicy', {\n        createScriptURL: (input) =&gt; {\n            return input;\n        }\n    });\n    trustedURL = policy.createScriptURL('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');\n} else {\n    trustedURL = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';\n}\n\n// Load the jsPDF library using the trusted URL\nlet jspdf = document.createElement(\"script\");\njspdf.onload = function () {\n    // Create a PDF with higher quality images\n    const { jsPDF } = window.jspdf;\n    const doc = new jsPDF({\n        orientation: 'portrait',\n        unit: 'mm',\n        format: 'a4'\n    });\n\n    let elements = document.getElementsByTagName(\"img\");\n\n    // Function to process each image\n    const processImage = (index) =&gt; {\n        if (index &gt;= elements.length) {\n            // All images processed, save the PDF\n            doc.save(\"high_quality_download.pdf\");\n            return;\n        }\n\n        let img = elements[index];\n        if (!/^blob:/.test(img.src)) {\n            // Skip non-blob images\n            processImage(index + 1);\n            return;\n        }\n\n        // Create a high-resolution canvas\n        let canvasElement = document.createElement('canvas');\n        // Use double the display size for higher resolution\n        canvasElement.width = img.naturalWidth || img.width * 2;\n        canvasElement.height = img.naturalHeight || img.height * 2;\n\n        let ctx = canvasElement.getContext(\"2d\");\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = \"high\";\n\n        // Draw the image at full resolution\n        ctx.drawImage(img, 0, 0, canvasElement.width, canvasElement.height);\n\n        // Get high-quality image data\n        let imgData = canvasElement.toDataURL(\"image/jpeg\", 1.0);\n\n        // Calculate dimensions to fit on A4\n        const pageWidth = doc.internal.pageSize.getWidth();\n        const pageHeight = doc.internal.pageSize.getHeight();\n\n        const imgRatio = canvasElement.height / canvasElement.width;\n        let imgWidth = pageWidth - 20; // margins\n        let imgHeight = imgWidth * imgRatio;\n\n        // If image is taller than page, scale it down\n        if (imgHeight &gt; pageHeight - 20) {\n            imgHeight = pageHeight - 20;\n            imgWidth = imgHeight / imgRatio;\n        }\n\n        // Add a new page for each image except the first\n        if (index &gt; 0) {\n            doc.addPage();\n        }\n\n        // Center the image on the page\n        const x = (pageWidth - imgWidth) / 2;\n        const y = (pageHeight - imgHeight) / 2;\n\n        doc.addImage(imgData, 'JPEG', x, y, imgWidth, imgHeight);\n\n        // Move to the next image\n        processImage(index + 1);\n    };\n\n    // Start processing images\n    processImage(0);\n};\n\njspdf.src = trustedURL;\ndocument.body.appendChild(jspdf);\n</code></pre>"},{"location":"blog/tutorial/download-protected-pdf-from-google-drive/#5-download-your-pdf","title":"5. Download Your PDF","text":"<p>After running the script, wait a few seconds while the magic happens. Your browser will automatically download a file named high_quality_download.pdf with all pages preserved in excellent quality.</p>"},{"location":"contributing/","title":"Contributing to docs.rajandangi","text":""},{"location":"contributing/#introduction","title":"Introduction","text":"<p>Contributions are always welcome. Also, if you have any confusion, please feel free to create an issue.</p>"},{"location":"contributing/#key-information","title":"Key information","text":"<ul> <li>The documentation source files are inside <code>docs/</code> directory.</li> <li>The source files are written in <code>Markdown</code>.</li> <li>The HTML documentation site is built using mkdocs,   a Python package to build documentation.</li> </ul>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":""},{"location":"contributing/#fork-it-clone-it","title":"Fork it, clone it","text":"<p>Fork the docs repo by using the Github interface.</p> <p>Clone that fork into your development machine.</p> <pre><code>git clone git@github.com:&lt;YOUR_USERNAME&gt;/docs.rajandangi.com.np.git\n</code></pre>"},{"location":"contributing/#locally-building-and-serving","title":"Locally building and serving","text":"<p>Install <code>mkdocs</code> using any of the methods specified in the official documentation.</p> <p>The current theme used for mkdocs is <code>material</code>. You will need to install the theme as well.</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>To serve the docs locally, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will build and host the <code>.md</code> files in <code>http://localhost:8000</code>. It will also live reload the page when you make changes in the source files.</p>"},{"location":"contributing/#pushing-changes","title":"Pushing changes","text":"<p>Once you've made necessary changes, push it to your forked repository by running:</p> <pre><code>git push origin main\n</code></pre> <p>After you've done this, you need to ask us to merge your changes to the main repo. Github provides pull request feature to accomplish that.</p> <p>Go to the pull requests tab of the main repo.</p> <p>You'll notice a big green, New pull request button on the top right side of the page. Click on that button and follow from there. Your pull request will be reviewed and merged by one of Khalti development staff.</p>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>If you encounter an issue or unexpected behavior in the documentation or the website, please follow these steps to help us resolve the problem efficiently.</p>"},{"location":"contributing/reporting-a-bug/#before-reporting","title":"Before Reporting","text":"<ul> <li> <p>Search Existing Issues:   Check the issues page to see if the bug has already been reported.</p> </li> <li> <p>Reproduce the Bug:   Ensure that it is reproducible by following these steps:</p> </li> <li>Clear your browser cache.</li> <li>Open the documentation site in an incognito/private window.</li> <li>Verify the issue persists.</li> </ul>"},{"location":"contributing/reporting-a-bug/#how-to-report","title":"How to Report","text":"<p>When you are ready to report the bug, please include the following details:</p> <ul> <li> <p>Title:   A short and descriptive title of the issue.</p> </li> <li> <p>Description:   A detailed description of the bug, including:</p> </li> <li>What you expected to happen.</li> <li>What actually happened.</li> <li> <p>Any error messages or screenshots, if applicable.</p> </li> <li> <p>Steps to Reproduce:   A step-by-step guide to reproduce the issue:</p> </li> <li>The URL or page where the bug occurs.</li> <li>The actions you performed.</li> <li> <p>Any additional context (browser, operating system, etc.).</p> </li> <li> <p>Environment Information:   Provide details such as:</p> </li> <li>Browser and version.</li> <li>Operating system.</li> <li> <p>Documentation version (if applicable).</p> </li> <li> <p>Additional Information:   Any other context or logs that might be helpful in diagnosing the issue.</p> </li> </ul>"},{"location":"contributing/reporting-a-bug/#submitting-your-report","title":"Submitting Your Report","text":"<p>Once you've gathered all the necessary information, submit your report as an issue on our GitHub repository.</p> <p>Thank you for helping us improve the documentation!</p>"},{"location":"contributing/reporting-a-docs-issue/","title":"Reporting a Documentation Issue","text":"<p>If you notice any errors, inconsistencies, or areas for improvement in our documentation, please follow these steps to help us address the issue effectively.</p>"},{"location":"contributing/reporting-a-docs-issue/#before-reporting","title":"Before Reporting","text":"<ul> <li> <p>Search Existing Issues:   Check the issues page to see if the documentation issue has already been reported.</p> </li> <li> <p>Review the Context:   Make sure to review the relevant sections to confirm the issue. This helps avoid duplicate reports and ensures that the suggested changes are necessary.</p> </li> </ul>"},{"location":"contributing/reporting-a-docs-issue/#how-to-report","title":"How to Report","text":"<p>When you are ready to report a documentation issue, please include the following details:</p> <ul> <li> <p>Title:   A clear and descriptive title for the documentation issue.</p> </li> <li> <p>Description:   A detailed description of the issue, including:</p> </li> <li>Where you found the issue (URL or section).</li> <li>What is incorrect, unclear, or outdated.</li> <li> <p>Your suggestion for improvement, if applicable.</p> </li> <li> <p>Steps to Reproduce:   If applicable, provide a step-by-step guide or reference for locating the problem within the documentation.</p> </li> <li> <p>Environment Information:   Include details such as:</p> </li> <li>Browser and version (if the issue is related to how the documentation is displayed).</li> <li>Operating system.</li> <li> <p>Documentation version or branch, if known.</p> </li> <li> <p>Additional Information:   Attach any screenshots or additional context that might help in diagnosing and fixing the issue.</p> </li> </ul>"},{"location":"contributing/reporting-a-docs-issue/#submitting-your-report","title":"Submitting Your Report","text":"<p>Once you've gathered the necessary information, please submit your report as an issue on our GitHub repository.</p> <p>Thank you for helping us improve our documentation!</p>"},{"location":"javascript/","title":"Learn Javascript","text":""},{"location":"javascript/#introduction","title":"Introduction","text":"<p>In this documentation, we will learn about the fundamentals of JavaScript, a programming language that is widely used for web development. We will cover the basics of JavaScript to advanced concepts, including functions, objects, and more. The documentation will be divided into multiple units, each focusing on a specific topic.</p>"},{"location":"javascript/#references","title":"References","text":"<p>This documentation is highly inspired by the following resources:</p> <p>  Namaste JavaScript - Season 1</p> <p>  Namaste JavaScript - Season 2</p> <p>Thanks to Akshay Saini for creating these amazing videos and sharing his knowledge with the world. The documentation is designed to be beginner-friendly, so you can follow along even if you're new to programming.</p>"},{"location":"javascript/async-js-and-event-loop/","title":"Asynchronous JavaScript &amp; The Event Loop","text":"<p>Ever wondered how JavaScript, known for being single-threaded, handles tasks that take time, like fetching data or waiting for a timer, without freezing everything else? This is where the magic of the asynchronous model, powered by the browser environment and the Event Loop, comes into play.</p>"},{"location":"javascript/async-js-and-event-loop/#prerequisite","title":"Prerequisite:","text":"<p>If you don\u2019t understand how the Call Stack works, I highly recommend reading this first:  JavaScript Call Stack</p>"},{"location":"javascript/async-js-and-event-loop/#the-puzzle-javascripts-synchronous-nature","title":"The Puzzle: JavaScript's Synchronous Nature","text":"<p>First, let's establish the baseline:</p> <ul> <li>Single-Threaded: JavaScript, in its core execution model, has only one thread. This means it can only do one thing at a time.</li> <li>Synchronous Execution: Code runs line by line, one after another. If one line takes a long time, the next line has to wait.</li> <li>The Call Stack: This is the heart of JS execution. It's a data structure that keeps track of function calls.<ul> <li>When a script starts, a Global Execution Context (GEC) is created and pushed onto the stack.</li> <li>When a function is called, a new Execution Context (EC) for that function is created and pushed onto the stack.</li> <li>The code inside the function executes.</li> <li>When the function finishes, its EC is popped off the stack.</li> <li>When the entire script finishes, the GEC is popped off, and the stack is empty.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>function greet(name) {\n    console.log(\"Hello, \" + name);\n}\n\nfunction start() {\n    console.log(\"Starting...\");\n    greet(\"Alice\");\n    console.log(\"Finished!\");\n}\n\nstart();\nconsole.log(\"All done.\");\n\n/* Execution Flow &amp; Call Stack:\n1. GEC pushed. `start()` called.\n2. `start()` EC pushed. `console.log(\"Starting...\")` runs.\n3. `greet(\"Alice\")` called.\n4. `greet()` EC pushed. `console.log(\"Hello, Alice\")` runs.\n5. `greet()` finishes, EC popped.\n6. Back in `start()`, `console.log(\"Finished!\")` runs.\n7. `start()` finishes, EC popped.\n8. Back in GEC, `console.log(\"All done.\")` runs.\n9. Script ends, GEC popped. Stack is empty.\n*/\n</code></pre> <p>The Call Stack's main job is simple: execute whatever is currently on top of it, immediately. It doesn't wait. So, how do we handle delays or external events?</p>"},{"location":"javascript/async-js-and-event-loop/#what-happens-when-things-take-time-the-browsers-role","title":"What Happens When Things Take Time? The Browser's Role","text":"<p>If the Call Stack just executes code synchronously, how can we possibly wait 5 seconds for a timer without blocking the entire thread? The answer lies outside the JavaScript Engine itself.</p> <p>The Browser (or Node.js environment) provides additional capabilities beyond the core JS engine. These are often called Web APIs.</p>"},{"location":"javascript/async-js-and-event-loop/#meet-the-browsers-helpers-web-apis","title":"Meet the Browser's Helpers: Web APIs","text":"<p>Think of the browser as a larger environment containing:</p> <ol> <li>The JS Engine: (e.g., V8 in Chrome/Node) with its Call Stack.</li> <li>Web APIs: A set of APIs provided by the browser for interacting with the outside world or performing tasks in the background. Examples include:<ul> <li><code>setTimeout()</code>, <code>setInterval()</code> (Timers)</li> <li>DOM APIs (manipulating HTML, handling events like clicks)</li> <li><code>fetch()</code> (making network requests)</li> <li><code>localStorage</code> (storage)</li> <li><code>console</code> (debugging output)</li> <li>Geolocation, Bluetooth, etc.</li> </ul> </li> </ol> <p>These APIs are not part of the core JavaScript language itself but are provided by the environment (like the browser). We can access them through the global object (<code>window</code> in browsers).</p> <p>When we call a function like <code>setTimeout</code>, the JS Engine doesn't handle the waiting itself. It hands off the task to the corresponding Web API.</p>"},{"location":"javascript/async-js-and-event-loop/#deep-dive-how-settimeout-really-works","title":"Deep Dive: How <code>setTimeout</code> Really Works","text":"<p>Let's trace this code:</p> <pre><code>console.log(\"Start\"); // 1\n\nsetTimeout(function cb() { // cb stands for callback\n    console.log(\"Callback after 5s\"); // 4 (after delay and queue processing)\n}, 5000); // 2\n\nconsole.log(\"End\"); // 3\n</code></pre> <p>Execution Steps:</p> <ol> <li><code>console.log(\"Start\")</code> is executed and logged.</li> <li><code>setTimeout(cb, 5000)</code> is executed.<ul> <li>The JS Engine sees <code>setTimeout</code>. It knows this is a Web API call.</li> <li>It hands the callback function <code>cb</code> and the delay <code>5000</code>ms over to the browser's Timer API.</li> <li>The Timer API starts a countdown for 5 seconds.</li> <li>Crucially: The JS Engine does not wait. It immediately moves on after handing off <code>cb</code> to the browser.</li> </ul> </li> <li><code>console.log(\"End\")</code> is executed and logged.</li> <li>The main script finishes, and the GEC is popped from the Call Stack. The stack is now empty.</li> <li>Meanwhile, in the browser: The Timer API is counting down. After 5 seconds, the timer completes.</li> <li>What happens to <code>cb</code> now? It doesn't go directly back to the Call Stack. It needs a place to wait until the Call Stack is free.</li> </ol>"},{"location":"javascript/async-js-and-event-loop/#the-waiting-room-callback-queue-the-gatekeeper-event-loop","title":"The Waiting Room: Callback Queue &amp; The Gatekeeper: Event Loop","text":"<p>This is where two more crucial pieces come in:</p> <ol> <li> <p>Callback Queue (or Task Queue): When a Web API finishes its task (like the timer expiring, or data arriving from <code>fetch</code>, or a button being clicked), the associated callback function (like our <code>cb</code>) is placed into the Callback Queue. It's a waiting line for functions ready to be executed.</p> </li> <li> <p>Event Loop: This is the conductor orchestrating the whole process. The Event Loop has one simple, continuous job:</p> <ul> <li>Monitor: Is the Call Stack empty?</li> <li>Monitor: Is there anything waiting in the Callback Queue?</li> <li>Action: If the Call Stack IS empty AND there IS a callback waiting in the Callback Queue, the Event Loop takes the first callback from the queue and pushes it onto the Call Stack for execution.</li> </ul> </li> </ol> <p>Continuing the <code>setTimeout</code> example:</p> <ul> <li>After 5 seconds, the Timer API places <code>cb</code> into the Callback Queue: <code>[ cb ]</code>.</li> <li>The Event Loop sees the Call Stack is empty (our main script finished) and sees <code>cb</code> in the queue.</li> <li>The Event Loop pushes <code>cb</code> onto the Call Stack.</li> <li>The code inside <code>cb</code> (<code>console.log(\"Callback after 5s\")</code>) executes.</li> <li><code>cb</code> finishes and is popped from the Call Stack. The stack is empty again. The queue is empty. Everything is settled.</li> </ul>"},{"location":"javascript/async-js-and-event-loop/#handling-clicks-event-listeners-in-action","title":"Handling Clicks: Event Listeners in Action","text":"<p>Event listeners work similarly:</p> <pre><code>console.log(\"Start\");\n\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function handleClick() {\n    console.log(\"Button clicked!\"); // Runs only AFTER a click AND stack is empty\n});\n\nconsole.log(\"End\");\n</code></pre> <ol> <li><code>console.log(\"Start\")</code> runs.</li> <li><code>addEventListener</code> is called. The JS Engine tells the browser's DOM API: \"Hey, watch the element with ID 'myButton'. If a 'click' happens, remember this <code>handleClick</code> function.\" The browser registers this listener. The JS Engine moves on.</li> <li><code>console.log(\"End\")</code> runs. The main script might finish, emptying the Call Stack.</li> <li>Later: The user clicks the button.<ol> <li>The browser's DOM API sees the click and finds the registered <code>handleClick</code> function.</li> <li>It places <code>handleClick</code> into the Callback Queue: <code>[ handleClick ]</code>.</li> <li>The Event Loop waits for the Call Stack to be empty.</li> <li>Once the stack is empty, the Event Loop pushes <code>handleClick</code> onto the stack.</li> <li><code>console.log(\"Button clicked!\")</code> executes.</li> <li><code>handleClick</code> finishes and is popped off the stack.</li> </ol> </li> </ol> <p>If the user clicks the button 5 times rapidly while the Call Stack is busy, 5 <code>handleClick</code> functions will be added to the Callback Queue, waiting their turn.</p>"},{"location":"javascript/async-js-and-event-loop/#fetching-data-introducing-promises-and-a-new-queue","title":"Fetching Data: Introducing Promises and a New Queue","text":"<p>Now, let's look at <code>fetch</code>, which is commonly used for network requests and involves Promises:</p> <pre><code>console.log(\"Start\"); // 1\n\nsetTimeout(function cbT() { // cbT = callback Timer\n    console.log(\"Timeout Callback\"); // 5?\n}, 0); // 2 - Note: 0ms delay!\n\nfetch(\"some/api/endpoint\") // 3\n    .then(function cbF() { // cbF = callback Fetch\n        console.log(\"Fetch Callback (Promise resolved)\"); // 4?\n    });\n\nconsole.log(\"End\"); // 4? (or maybe 3?)\n</code></pre> <p>You might expect the <code>setTimeout</code> with 0ms delay to run very quickly. However, <code>fetch</code> introduces Promises, and Promises have a special place in the asynchronous model.</p>"},{"location":"javascript/async-js-and-event-loop/#the-vip-lane-microtask-queue","title":"\u2728 The VIP Lane: Microtask Queue","text":"<p>It turns out there isn't just one queue. There are (at least) two important ones:</p> <ol> <li>Callback Queue (or Task Queue): Holds callbacks from <code>setTimeout</code>, <code>setInterval</code>, DOM events, I/O operations, etc.</li> <li>Microtask Queue (or Job Queue): Holds callbacks associated with Promises (like functions passed to <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>) and some other mechanisms like <code>MutationObserver</code> and <code>queueMicrotask()</code>.</li> </ol> <p>The Crucial Difference: Priority</p> <p>The Event Loop gives the Microtask Queue higher priority. The rule is:</p> <ul> <li>After a task currently executing on the Call Stack finishes, the Event Loop checks the Microtask Queue.</li> <li>If the Microtask Queue has tasks, the Event Loop runs ALL tasks in the Microtask Queue, one by one, until it's empty.</li> <li>Only then does the Event Loop check the Callback Queue and move one task from there to the Call Stack (if the stack is empty).</li> </ul> <p>Revisiting the <code>fetch</code> example</p> <ol> <li><code>console.log(\"Start\")</code> runs.</li> <li><code>setTimeout(cbT, 0)</code>: The JS Engine hands <code>cbT</code> to the Timer API. The Timer API almost immediately (after ~4ms minimum delay in browsers typically, not truly 0) places <code>cbT</code> into the Callback Queue.</li> <li><code>fetch()</code>: The JS Engine initiates the network request via the browser's Fetch API. <code>fetch</code> returns a Promise immediately. The <code>.then(cbF)</code> part registers <code>cbF</code> to run when the Promise resolves.</li> <li><code>console.log(\"End\")</code> runs. The main script finishes. Call Stack is empty.</li> <li>Now the Event Loop checks:<ul> <li>Microtask Queue: Let's assume the <code>fetch</code> completed quickly and the Promise resolved. <code>cbF</code> is now in the Microtask Queue.</li> <li>Callback Queue: <code>cbT</code> is waiting here.</li> </ul> </li> <li>Event Loop Action: Because the Microtask Queue has priority, the Event Loop pushes <code>cbF</code> onto the Call Stack.</li> <li><code>console.log(\"Fetch Callback...\")</code> runs. <code>cbF</code> finishes and is popped.</li> <li>Event Loop checks again: Microtask Queue is empty.</li> <li>Event Loop checks Callback Queue: It finds <code>cbT</code>. The Call Stack is empty.</li> <li>Event Loop Action: It pushes <code>cbT</code> onto the Call Stack.</li> <li><code>console.log(\"Timeout Callback\")</code> runs. <code>cbT</code> finishes and is popped.</li> </ol> <p>Output: <pre><code>Start\nEnd\nFetch Callback (Promise resolved)\nTimeout Callback\n</code></pre> Even with a 0ms delay, the <code>setTimeout</code> callback runs after the Promise callback because of the Microtask Queue's priority.</p>"},{"location":"javascript/async-js-and-event-loop/#a-potential-problem-starvation","title":"A Potential Problem: Starvation","text":"<p>Because the Event Loop processes all microtasks before moving to the next task from the Callback Queue, it's possible to \"starve\" the Callback Queue. If a microtask keeps adding more microtasks, the Event Loop might never get a chance to process tasks waiting in the Callback Queue (like <code>setTimeout</code> or rendering updates). This is generally something to be aware of but less common in typical application code unless dealing with recursive Promise resolutions or complex MutationObserver scenarios.</p>"},{"location":"javascript/async-js-and-event-loop/#putting-it-all-together","title":"Putting It All Together","text":"<p>JavaScript achieves asynchronicity not through multi-threading within the JS Engine itself, but by leveraging the capabilities of its hosting environment (like the browser):</p> <ol> <li>The Call Stack executes synchronous code.</li> <li>Web APIs handle long-running tasks or external events off the main thread.</li> <li>The Callback Queue holds callbacks from less urgent async operations (timers, clicks).</li> <li>The Microtask Queue holds callbacks from more urgent async operations (Promises).</li> <li>The Event Loop constantly monitors the Call Stack and the Queues, moving callbacks from the queues (Microtasks first!) onto the stack when the stack is empty, allowing asynchronous operations to integrate back into the synchronous flow without blocking.</li> </ol>"},{"location":"javascript/bind-polyfill/","title":"Polyfill for <code>bind()</code>","text":"<p>Sometimes, you want to use modern JavaScript features, but not all environments support them. For example, some older browsers might not have the <code>bind()</code> method. So how do you ensure your functions still work as expected?</p>"},{"location":"javascript/bind-polyfill/#prerequisite","title":"Prerequisite","text":"<p> call, apply, and bind method in JavaScript</p>"},{"location":"javascript/bind-polyfill/#the-solution-introducing-polyfills","title":"The Solution: Introducing Polyfills","text":"<p>Polyfill: A piece of code that adds missing functionality by emulating features that don't exist in certain JavaScript environments.</p> <p>By writing a polyfill, you can make sure your code works everywhere\u2014even where built-in functionality is missing.</p>"},{"location":"javascript/bind-polyfill/#polyfilling-bind","title":"Polyfilling <code>bind()</code>","text":"<p>Let\u2019s see how the built-in <code>bind()</code> works first:</p> <pre><code>const name = {\n    firstName: 'John',\n    lastName: 'Doe'\n};\n\nfunction printName(homeTown, state) {\n    console.log(this.firstName + ' ' + this.lastName + ' from ' + homeTown + ', ' + state);\n}\n\n// Built-in bind(): sets 'this' to 'name' and pre-fills 'homeTown'\nconst printMyName = printName.bind(name, 'Salyan');\nprintMyName('Karnali');\n// Output: John Doe from Salyan, Karnali\n</code></pre> <p>The built-in <code>bind()</code> lets you fix <code>this</code> and optionally preset some arguments.</p>"},{"location":"javascript/bind-polyfill/#writing-a-polyfill-mybind","title":"Writing a Polyfill: <code>myBind</code>","text":"<p>Suppose the built-in <code>bind()</code> is missing. Let's create a polyfill called <code>myBind</code>:</p> <pre><code>Function.prototype.myBind = function (...args) {\n    const originalFunction = this; // The function on which myBind is called\n    const context = args[0]; // The object to bind as 'this'\n    const bindArgs = args.slice(1); // Any initial arguments to preset\n\n    return function (...callArgs) {\n        // Combine the preset arguments and those provided at call time\n        return originalFunction.apply(context, [...bindArgs, ...callArgs]);\n    };\n};\n</code></pre> <p>How it works:</p> <ul> <li><code>...args</code> captures all arguments passed to <code>myBind</code>.</li> <li>The first argument (<code>args[0]</code>) is the intended <code>this</code> context.</li> <li>The rest (<code>args.slice(1)</code>) are preset arguments.</li> <li>When calling the returned function, both preset and later arguments are combined and passed to the original function using <code>apply</code>.</li> </ul>"},{"location":"javascript/bind-polyfill/#example-usage","title":"Example Usage","text":"<pre><code>const printMyName2 = printName.myBind(name, 'Salyan');\nprintMyName2('Karnali');\n// Output: John Doe from Salyan, Karnali\n</code></pre> <p>Just like the built-in <code>bind()</code>, the polyfill creates a new function with the desired <code>this</code> context and preset arguments.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/","title":"Scope in JavaScript: Block, Function, and Shadowing","text":"<p>Ever wondered how JavaScript knows which variable you're referring to, especially when names are reused in different parts of your code? This boils down to the concept of scope. Let's explore how <code>block scope</code>, <code>function scope</code>, and a related idea called <code>shadowing</code> work in JS.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#what-is-a-block","title":"\ud83e\udd14 What is a Block?","text":"<p>You've definitely seen curly braces <code>{}</code> in JavaScript, especially with <code>if</code> statements, <code>for</code> loops, or just on their own.</p> <pre><code>if (true) {\n  // This is a block\n  let message = \"Hello!\";\n  console.log(message);\n}\n</code></pre> <p>These curly braces define a block. Think of a block as a way to group multiple JavaScript statements together where JavaScript might otherwise expect only one. It's also known as a compound statement.</p> <p>Why group statements?</p> <p>Consider the <code>if</code> statement. Syntactically, it expects a single statement to execute if the condition is true. Blocks allow us to execute multiple statements conditionally.</p> Example: Block with if<pre><code>if (true) {\n  // Compound Statement (Block)\n  var a = 10; // We'll discuss 'var' vs 'let'/'const' soon!\n  console.log(a);\n}\n</code></pre>"},{"location":"javascript/block-scope-function-scope-shadowing/#what-is-block-scope","title":"\ud83d\udeaa What is Block Scope?","text":"<p>Now, why are blocks important for variables? Because they create a scope. Block scope determines the accessibility of variables declared inside that block. Specifically, variables declared with <code>let</code> and <code>const</code> are block-scoped.</p> <p>Let's see what happens when we declare variables with <code>var</code>, <code>let</code>, and <code>const</code> inside a block and try to access them both inside and outside.</p> index.js<pre><code>{\n  var a = 10;\n  let b = 20;\n  const c = 30;\n  console.log(\"Inside Block a= \", a); // Output: 10\n  console.log(\"Inside Block b= \", b); // Output: 20\n  console.log(\"Inside Block c= \", c); // Output: 30\n}\n\nconsole.log(\"Outside Block a= \", a); // Output: 10  (Uh oh?)\nconsole.log(\"Outside Block b= \", b); // Throws ReferenceError\nconsole.log(\"Outside Block c= \", c); // Throws ReferenceError\n</code></pre> <p>Console Output:</p> console output<pre><code>Inside Block a=  10\nInside Block b=  20\nInside Block c=  30\nOutside Block a=  10\nUncaught ReferenceError: b is not defined\n</code></pre> <p>What's happening here?</p> <ul> <li><code>let b</code> and <code>const c</code> are block-scoped. They exist only within the <code>{}</code> block. Trying to access them outside results in a <code>ReferenceError</code>. They live in a special memory space associated with the block.</li> <li><code>var a</code>, however, is not block-scoped (it's typically function-scoped or globally-scoped). It \"escapes\" the block and becomes accessible outside. In this case, it attaches to the global scope.</li> </ul> Image illustrating 'b' and 'c' in Block scope, 'a' in Global scope <p>Info</p> <p>This is a key reason why <code>let</code> and <code>const</code> (introduced in ES6) are generally preferred over <code>var</code> \u2013 they limit the variable's \"lifespan\" to the block where they are needed, reducing potential bugs.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#what-is-shadowing","title":"\ud83c\udfad What is Shadowing?","text":"<p>What if you declare a variable inside a block with the same name as a variable declared outside the block? This is called shadowing. The inner variable temporarily \"hides\" or \"shadows\" the outer variable within the block's scope.</p> <p>Let's see how <code>var</code>, <code>let</code>, and <code>const</code> behave with shadowing.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#scenario-1-shadowing-var-with-var","title":"Scenario 1: Shadowing <code>var</code> with <code>var</code>","text":"index.js<pre><code>var a = 12; // Outer 'a'\n{\n  var a = 10; // Inner 'a' - shadows the outer 'a'\n  let b = 20;\n  const c = 30;\n  console.log(\"Inside Block a= \", a); // Output: 10\n  console.log(\"Inside Block b= \", b); // Output: 20\n  console.log(\"Inside Block c= \", c); // Output: 30\n}\nconsole.log(\"Outside Block a= \", a); // Output: 10 (Wait, what?)\n</code></pre> <p>Console Output:</p> console output<pre><code>Inside Block a= 10\nInside Block b= 20\nInside Block c= 30\nOutside Block a= 10\n</code></pre> <p>Because <code>var</code> is not block-scoped, both <code>var a = 12</code> and <code>var a = 10</code> refer to the same variable in the outer (in this case, global) scope. The inner declaration shadows the outer one and modifies its value.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#scenario-2-shadowing-let-with-let","title":"Scenario 2: Shadowing <code>let</code> with <code>let</code>","text":"index.js<pre><code>let b = 12; // Outer 'b' (lives in Script scope)\n{\n  var a = 10;\n  let b = 20; // Inner 'b' (lives in Block scope) - shadows outer 'b'\n  const c = 30;\n  console.log(\"Inside Block a= \", a); // Output: 10\n  console.log(\"Inside Block b= \", b); // Output: 20\n  console.log(\"Inside Block c= \", c); // Output: 30\n}\nconsole.log(\"Outside Block b= \", b); // Output: 12\n</code></pre> <p>Console Output:</p> console output<pre><code>Inside Block a= 10\nInside Block b= 20\nInside Block c= 30\nOutside Block b= 12\n</code></pre> <p>This is different! The inner <code>let b = 20</code> creates a completely new variable <code>b</code> that only exists within the block. It shadows the outer <code>b</code> inside the block, but doesn't affect it. Once the block finishes, the inner <code>b</code> disappears, and the outer <code>b</code> (value 12) is accessible again.</p> Image illustrating Global scope for 'a', Script scope for outer 'b', Block scope for inner 'b' and 'c'"},{"location":"javascript/block-scope-function-scope-shadowing/#scenario-3-shadowing-const-with-const","title":"Scenario 3: Shadowing <code>const</code> with <code>const</code>","text":"<p><code>const</code> behaves identically to <code>let</code> regarding shadowing and block scope.</p> index.js<pre><code>const c = 12; // Outer 'c' (Script scope)\n{\n  var a = 10;\n  let b = 20;\n  const c = 30; // Inner 'c' (Block scope) - shadows outer 'c'\n  console.log(\"Inside Block a= \", a); // Output: 10\n  console.log(\"Inside Block b= \", b); // Output: 20\n  console.log(\"Inside Block c= \", c); // Output: 30\n}\nconsole.log(\"Outside Block c= \", c); // Output: 12\n</code></pre> <p>Console Output:</p> console output<pre><code>Inside Block a= 10\nInside Block b= 20\nInside Block c= 30\nOutside Block c= 12\n</code></pre> <p>Again, the inner <code>const c</code> is a separate variable confined to the block scope.</p> Image illustrating Global scope for 'a', Script scope for outer 'c', Block scope for 'b' and inner 'c'"},{"location":"javascript/block-scope-function-scope-shadowing/#does-shadowing-work-the-same-in-functions","title":"\ud83c\udfdb\ufe0f Does Shadowing Work the Same in Functions?","text":"<p>Yes! Functions also create their own scope (function scope). Variables declared inside a function can shadow variables from outer scopes, similar to how <code>let</code> and <code>const</code> work in blocks.</p> index.js<pre><code>const c = 12; // Global 'c'\n\nfunction myFunction() {\n  const c = 30; // Function-scoped 'c' - shadows global 'c'\n  console.log(\"Inside Function c= \", c); // Output: 30\n}\n\nmyFunction();\n\nconsole.log(\"Outside Function c= \", c); // Output: 12\n</code></pre> <p>Console Output:</p> console output<pre><code>Inside Function c= 30\nOutside Function c= 12\n</code></pre> <p>The <code>c</code> inside <code>myFunction</code> is distinct from the global <code>c</code>.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#illegal-shadowing","title":"Illegal Shadowing","text":"<p>While shadowing with <code>let</code> and <code>const</code> is predictable, mixing them with <code>var</code> can lead to errors.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#case-1-shadowing-let-with-var-illegal","title":"Case 1: Shadowing <code>let</code> with <code>var</code> (Illegal)","text":"<pre><code>let a = 20;\n{\n  var a = 10; // SyntaxError!\n}\n</code></pre> <p>Console Output:</p> console output<pre><code>Uncaught SyntaxError: Identifier 'a' has already been declared\n</code></pre> <p>This is illegal shadowing. You cannot shadow a <code>let</code> (or <code>const</code>) variable with <code>var</code> within the same block scope.</p> <p>Why is this illegal?</p> <p>Remember, <code>var</code> is not truly block-scoped. A <code>var a = 10</code> inside the block tries to declare a variable in the outer scope (function or global) where <code>let a</code> already exists. Since <code>let</code> variables cannot be re-declared in the same scope, this causes a <code>SyntaxError</code>. <code>var</code> tries to \"cross the boundary\" of its block, interfering with the outer <code>let</code>.</p>"},{"location":"javascript/block-scope-function-scope-shadowing/#case-2-shadowing-var-with-let-legal","title":"Case 2: Shadowing <code>var</code> with <code>let</code> (Legal)","text":"<pre><code>var a = 20;\n{\n  let a = 10; // Perfectly fine!\n  console.log(\"Inside block a =\", a); // Output: 10\n}\nconsole.log(\"Outside block a =\", a); // Output: 20\n</code></pre> <p>This works because the inner <code>let a</code> creates a new, block-scoped variable. It doesn't interfere with the outer <code>var a</code>.</p> <p>Important Note on Functions: The illegal shadowing rule applies within the same block context. If the <code>var</code> is inside a function within the block, it's okay because the function creates its own separate scope:</p> shadowing.js<pre><code>let a = 20; // Script scope\n\nfunction test() {\n  // Function scope starts here\n  var a = 10; // This 'a' is local to the function 'test'\n  console.log(\"Inside function:\", a); // Output: 10\n}\n\ntest();\nconsole.log(\"Outside function:\", a); // Output: 20 (Unaffected)\n</code></pre> console output<pre><code>Inside function: 10                 shadowing.js:6\nOutside function: 20                shadowing.js:10\n</code></pre>"},{"location":"javascript/block-scope-function-scope-shadowing/#practice-time","title":"\ud83e\uddea Practice Time!","text":"<p>Add <code>debugger;</code> statements or use your browser's developer tools to inspect the scopes for these examples:</p> <p>Example 1: Nested Blocks</p> shadowing.js<pre><code>const a = 20; // Outer scope (Script)\n{\n  const a = 30; // First block scope\n  console.log(\"Inside Block 1, a = \", a);\n  {\n    const a = 40; // Second block scope (nested)\n    console.log(\"Inside Block 2, a = \", a);\n  }\n  console.log(\"Back in Block 1, a = \", a); // What will this print?\n}\nconsole.log(\"Outside Block, a = \", a);\n</code></pre> <p>Example 2: Lexical Scope</p> shadowing-1.js<pre><code>const a = 20; // Outer scope (Script)\n{\n  const a = 30; // First block scope\n  console.log(\"Inside Block 1, a = \", a);\n  {\n    // No 'a' declared here!\n    console.log(\"Inside Block 2, a = \", a); // Which 'a' does this access?\n  }\n}\nconsole.log(\"Outside Block, a = \", a);\n</code></pre> <p>Answer</p> <p>These examples also demonstrate the Lexical Scope chain: JavaScript looks for a variable in the current scope, then in the outer scope, then the next outer scope, and so on, until it finds it or reaches the global scope.</p> <p>Understanding block scope, function scope, and shadowing (especially the differences between <code>var</code>, <code>let</code>, and <code>const</code>) is crucial for writing predictable and bug-free JavaScript code!</p> console output<pre><code>Inside Block 1, a =  30                     shadowing.js:4\nInside Block 2, a =  40                     shadowing.js:7\nBack in Block 1, a =  30                    shadowing.js:9\nOutside Block, a =  20                      shadowing.js:11\n</code></pre> console output<pre><code>Inside Block 1, a =  30                     shadowing-1.js:4\nInside Block 2, a =  30                     shadowing-1.js:7\nOutside Block, a =  20                      shadowing-1.js:10\n</code></pre>"},{"location":"javascript/call-apply-bind/","title":"<code>call</code>, <code>apply</code>, and <code>bind</code>","text":"<p>Have you ever needed to share a function between different objects, but found that <code>this</code> didn't refer to the object you expected? JavaScript provides powerful tools\u2014<code>call</code>, <code>apply</code>, and <code>bind</code>\u2014to explicitly control the <code>this</code> context when invoking functions. Let's see how you can use them to solve this common problem.</p>"},{"location":"javascript/call-apply-bind/#the-problem-reusing-methods-across-objects","title":"The Problem: Reusing Methods Across Objects","text":"<p>Suppose you have an object method, but you don't want to copy or rewrite it for every object. Instead, you want to reuse a function and decide which object it should refer to when called.</p> <pre><code>const name = {\n    firstName: 'Rajan',\n    lastName: 'Dangi'\n};\n\nconst name2 = {\n    firstName: 'Bhawana',\n    lastName: 'Dangi'\n};\n</code></pre> <p>You want to use a single <code>fullName</code> function for both objects.</p>"},{"location":"javascript/call-apply-bind/#the-solution-using-call-apply-and-bind","title":"The Solution: Using <code>call</code>, <code>apply</code>, and <code>bind</code>","text":""},{"location":"javascript/call-apply-bind/#1-call","title":"1. <code>call()</code>","text":"<p><code>call()</code> immediately invokes the function, letting you specify the <code>this</code> value and arguments one by one.</p> <pre><code>const fullName = function() {\n    console.log(this.firstName + ' ' + this.lastName);\n};\n\nfullName.call(name);   // Rajan Dangi\nfullName.call(name2);  // Bhawana Dangi\n</code></pre> <p>How it works: The first argument is the object to use as <code>this</code>. Additional arguments are passed to the function.</p>"},{"location":"javascript/call-apply-bind/#2-apply","title":"2. <code>apply()</code>","text":"<p><code>apply()</code> is almost identical to <code>call()</code>, but takes arguments as an array.</p> <pre><code>const getHomeTown = function(hometown, state) {\n    console.log(this.firstName + ' ' + this.lastName + ' is from ' + hometown + ', ' + state);\n};\n\ngetHomeTown.apply(name, ['Kathmandu', 'Bagmati']);\n// Rajan Dangi is from Kathmandu, Bagmati\n\ngetHomeTown.apply(name2, ['Kathmandu', 'Bagmati']);\n// Bhawana Dangi is from Kathmandu, Bagmati\n</code></pre> <p>Key difference: Arguments after the context object are supplied as an array.</p>"},{"location":"javascript/call-apply-bind/#3-bind","title":"3. <code>bind()</code>","text":"<p><code>bind()</code> doesn\u2019t call the function immediately. Instead, it returns a new function with the chosen <code>this</code> context. You can then call this new function later.</p> <pre><code>const fullNameBind = fullName.bind(name);\nfullNameBind(); // Rajan Dangi\n\nconst fullNameBind2 = fullName.bind(name2);\nfullNameBind2(); // Bhawana Dangi\n</code></pre> <p>Use case: Perfect when you need a reusable function with a preset context.</p>"},{"location":"javascript/call-apply-bind/#quick-comparison-table","title":"Quick Comparison Table","text":"Method Call Immediately? How to Pass Arguments Returns <code>call</code> Yes Individually Result value <code>apply</code> Yes As an array Result value <code>bind</code> No Individually (when bound) New function"},{"location":"javascript/call-apply-bind/#summary","title":"Summary","text":"<ul> <li><code>call()</code> and <code>apply()</code> allow you to borrow a function and execute it in the context of another object, right away.</li> <li><code>bind()</code> creates a new function with the desired context, which you can use later.</li> <li>Use <code>call</code> and <code>apply</code> based on whether you want to provide arguments as a list or array.</li> </ul>"},{"location":"javascript/call-apply-bind/#related-topics","title":"Related Topics","text":"<p> Arrow Functions and <code>this</code></p>"},{"location":"javascript/callback-functions/","title":"Callback Functions","text":"<p>Ever wondered how JavaScript, a language that typically runs code line by line (synchronously), handles tasks that take time, like waiting for user input, fetching data, or timers, without freezing everything up? The answer often lies in a fundamental concept: Callback Functions.</p>"},{"location":"javascript/callback-functions/#what-is-a-callback-function","title":"What is a Callback Function?","text":"<p>In JavaScript, functions are special \u2013 they are \"first-class citizens.\" This means you can treat them like any other variable: assign them, pass them around, and yes, even pass them into other functions as arguments.</p> <p>Callback function</p> <p>A callback function is simply a function that you pass into another function as an argument, with the intention that the outer function will execute (or \"call back\") your function at a later time or when a specific event occurs.</p> <p>Why are they useful?</p> <ul> <li>Enable asynchronous operations (timers, HTTP requests, file I/O) in a single-threaded environment.</li> <li>Control execution order: \u201cDo this, then do that.\u201d</li> <li>Keep the main thread free\u2014long tasks won\u2019t block UI updates or user interactions.</li> </ul>"},{"location":"javascript/callback-functions/#example-settimeout-custom-callbacks","title":"Example: setTimeout &amp; Custom Callbacks","text":"<p>Problem: You want to run code after a delay without freezing the UI.</p> <p>Solution: Use <code>setTimeout()</code> \u2014 it takes a callback and a delay, schedules the callback via the browser\u2019s Web APIs, then immediately returns control to the call stack.</p> <pre><code>// After 5 seconds, print \"Hello World\"\nsetTimeout(function() {\n  console.log(\"Hello World\");\n}, 5000);\n\n// Demonstrate custom callback invocation\nfunction x(callback) {\n  console.log(\"Inside x\");\n  callback();\n}\n\nx(function() {\n  console.log(\"Inside callback y\");\n});\n</code></pre> <p>What happens under the hood:</p> <ol> <li><code>setTimeout()</code> registers the callback in the browser\u2019s timer queue.</li> <li>JS continues to the next line\u2014no blocking.</li> <li><code>x()</code> runs, prints \u201cInside x\u201d then calls your callback, printing \u201cInside callback y.\u201d</li> <li>After ~5000 ms, the timer expires, and the callback is pushed onto the call stack for execution.</li> </ol> <p>This demonstrates how callbacks allow JavaScript to handle delays without stopping execution.</p>"},{"location":"javascript/callback-functions/#the-problem-blocking-the-main-thread","title":"The Problem: Blocking the Main Thread","text":"<p>Since JavaScript runs on a single thread (in the browser context), executing code line by line in the call stack, what happens If you run a heavy computation on the main thread:</p> <pre><code>// Example of a (simulated) long-running synchronous task\nfunction blockThread() {\n    console.log(\"Starting blocking task...\");\n    const start = Date.now();\n    while (Date.now() - start &lt; 5000) {\n        // Do nothing, just wait synchronously for 5 seconds\n    }\n    console.log(\"Blocking task finished.\");\n}\n\nconsole.log(\"Before blocking task.\");\nblockThread(); // The browser will freeze here for 5 seconds!\nconsole.log(\"After blocking task.\");\n// Any UI interactions (clicks, scrolls) during these 5s won't register until after.\n</code></pre> <ul> <li>The browser can\u2019t handle user input, rendering or other JS until that task finishes.</li> <li>The UI freezes\u2014bad for UX.</li> </ul> <p>This is blocking the main thread, and it leads to a poor user experience.</p> <p>Callbacks, used with asynchronous APIs</p> <p>Callbacks, used with asynchronous APIs (like <code>setTimeout</code>, <code>fetch</code>, or event listeners), are the solution. They allow you to say, \"Go do this task, and run this specific function (the callback) when you're done,\" letting the main thread continue with other work in the meantime.</p>"},{"location":"javascript/callback-functions/#event-listeners-as-callbacks","title":"Event Listeners as Callbacks","text":"<p>Event listeners are callbacks tied to user or DOM events:</p> <pre><code>&lt;button id=\"btn-one\"&gt;Click Me&lt;/button&gt;\n&lt;script&gt;\n  const btn = document.getElementById('btn-one');\n  btn.addEventListener('click', function handleClick() {\n    console.log('Button Clicked');\n  });\n&lt;/script&gt;\n</code></pre> <ul> <li>The anonymous function (or named <code>handleClick</code>) is your callback.</li> <li>When the user clicks the button, the browser pushes this callback onto the call stack and executes it.</li> </ul>"},{"location":"javascript/callback-functions/#closures-with-event-listeners","title":"Closures with Event Listeners","text":"<p>Callbacks become even more powerful when combined with closures. A closure allows a function to \"remember\" the environment (the variables) in which it was created, even after that environment is gone.</p> <p>Let's say we want to count how many times a button is clicked:</p> <pre><code>// Function to set up the listener and its private counter\nfunction attachClickCounter() {\n    let count = 0; // 'count' is in the scope of attachClickCounter\n\n    // Assuming HTML has &lt;button id=\"btn-two\"&gt;Click Counter&lt;/button&gt;\n    const counterButton = document.getElementById('btn-two');\n\n    // Attach the event listener\n    counterButton.addEventListener('click', function handleCountClick() {\n        // This callback function forms a closure.\n        // It \"remembers\" the 'count' variable from its parent scope.\n        count++;\n        console.log('Button Clicked ' + count + ' times');\n    });\n}\n\n// Call the setup function\nattachClickCounter();\n\n// Even though attachClickCounter() has finished executing,\n// the handleCountClick callback still has access to 'count'.\n</code></pre> <p>Output (after clicking the button multiple times):</p> <pre><code>Button Clicked 1 times\nButton Clicked 2 times\nButton Clicked 3 times\n...\n</code></pre> <p>The <code>handleCountClick</code> function (our callback) forms a closure over the <code>attachClickCounter</code> function's scope, specifically capturing the <code>count</code> variable. Every time the button is clicked, the same callback function runs, and because of the closure, it can access and modify the same <code>count</code> variable it remembered from when it was created.</p> <p>You can often inspect these closures in your browser's developer tools:</p> Closures with event listeners Click event listeners are added to the button. Callback function inside event Listeners have access to the global scope and scope     inside closure also."},{"location":"javascript/callback-functions/#garbage-collection-and-removing-event-listeners","title":"Garbage Collection and Removing Event Listeners","text":"<p>While powerful, event listeners and their associated closures aren't free. They consume memory.</p> <ul> <li>The Problem: If you add many event listeners, especially ones that form closures over large amounts of data, and you don't remove them when they're no longer needed (e.g., when the element is removed from the page or the component is unmounted), they can lead to memory leaks. The browser can't garbage collect the listener function or the variables trapped in its closure because it thinks they might still be needed. This can slow down your application over time.</li> <li>The Solution: It's crucial to clean up event listeners when they are no longer necessary. You can do this using the <code>removeEventListener</code> method. It requires a reference to the exact same function that was originally attached.</li> </ul> index.js<pre><code>function setupListener() {\n    const button = document.getElementById('myRemovableButton'); // Assume this button exists\n\n    // IMPORTANT: Define the callback as a named function or store it in a variable\n    function handleButtonClick() {\n        console.log('Removable listener clicked!');\n        // Maybe remove the listener after the first click?\n        button.removeEventListener('click', handleButtonClick);\n        console.log('Listener removed.');\n    }\n\n    if (button) {\n        button.addEventListener('click', handleButtonClick);\n    }\n\n    // You might also remove the listener based on other application logic,\n    // e.g., when a component unmounts or a feature is disabled.\n}\n\nsetupListener();\n</code></pre> <p>Key Takeaway</p> <p>Event listeners are heavy because they keep their callback function and its closure scope alive. Always remove listeners when they're no longer needed to prevent memory leaks and keep your application performant.</p>"},{"location":"javascript/callback-hell/","title":"Callback Hell in JavaScript","text":"<p>Callbacks help JavaScript handle asynchronous operations. But when callbacks pile up, they create a messy, hard-to-follow nest\u2014famously known as Callback Hell.</p>"},{"location":"javascript/callback-hell/#setting-the-scene-online-shopping-with-callbacks","title":"Setting the Scene: Online Shopping with Callbacks","text":"<p>Let\u2019s step into an online store. Imagine the flow a customer follows:</p> <ol> <li>Add items to cart</li> <li>Place order</li> <li>Make payment</li> <li>View summary</li> <li>Update wallet</li> </ol> <p>Each action must finish before the next begins, and every step uses asynchronous APIs.</p> <p>Here\u2019s what this can really look like in code:</p> <pre><code>// The user's shopping cart\nconst cart = [\"shoes\", \"pants\", \"kurta\"];\n\n// Start the order process\napi.createOrder(cart, function(order) {\n  // order is now available from createOrder\n  api.proceedToPayment(order, function(paymentInfo) {\n    // paymentInfo is available from proceedToPayment\n    api.showOrderSummary(paymentInfo, function(summary) {\n      // summary is available from showOrderSummary\n      api.updateWallet(summary, function(walletStatus) {\n        // walletStatus is available from updateWallet\n        console.log(\"Order complete! Final wallet status:\", walletStatus);\n      });\n    });\n  });\n});\n</code></pre> <p>How values get passed:</p> <ul> <li>Each API function does some work (like talking to a server), then calls your callback with the result.</li> <li>That result becomes available as a parameter in your callback function.</li> <li>You then use that result in the next step.</li> </ul> <p>Notice</p> <p>Each step depends on the previous callback. The code drifts to the right, forming what\u2019s called a Pyramid of Doom.</p> <p></p>"},{"location":"javascript/callback-hell/#minimal-example-with-dummy-functions","title":"Minimal Example (with Dummy Functions)","text":"<p>Here\u2019s a fully working, super-simplified mock-up using timeouts instead of real APIs:</p> callback-hell.js<pre><code>function createOrder(cart, cb) {\n  setTimeout(() =&gt; cb(\"order123\"), 500);\n}\n\nfunction proceedToPayment(order, cb) {\n  setTimeout(() =&gt; cb(\"paymentOK\"), 500);\n}\n\nfunction showOrderSummary(paymentInfo, cb) {\n  setTimeout(() =&gt; cb(\"summaryReady\"), 500);\n}\n\nfunction updateWallet(summary, cb) {\n  setTimeout(() =&gt; cb(\"wallet+$100\"), 500);\n}\n\nconst cart = [\"shoes\", \"pants\", \"kurta\"];\n\ncreateOrder(cart, function(order) {\n  proceedToPayment(order, function(paymentInfo) {\n    showOrderSummary(paymentInfo, function(summary) {\n      updateWallet(summary, function(walletStatus) {\n        console.log(\"Order complete. Wallet:\", walletStatus);\n      });\n    });\n  });\n});\n</code></pre> <p>Each callback gets its result as an argument\u2014just like real-world async APIs!</p>"},{"location":"javascript/callback-hell/#why-is-this-a-problem","title":"Why is This a Problem?","text":"<ul> <li>Difficult to Read: The deeper you nest, the harder it is to see what\u2019s going on.</li> <li>Hard to Debug: Tracing issues means jumping in and out of multiple nested functions.</li> <li>Unmaintainable: Adding new logic or handling errors becomes a nightmare.</li> </ul>"},{"location":"javascript/callback-hell/#the-inversion-of-control-trap","title":"The Inversion of Control Trap","text":"<p>A callback doesn\u2019t just mess with code structure\u2014it hands over program flow to someone else.</p> <p>Suppose the API authors aren\u2019t careful:</p> <ul> <li>What if your callback is never called?</li> <li>What if it's called twice?</li> <li>What if errors aren\u2019t handled?</li> </ul> <p>You\u2019ve lost control, and debugging becomes frustrating.</p> <p>Inversion of Control</p> <p>When you pass a function to another module, you trust it to handle your logic correctly\u2014but you can\u2019t be sure it will!</p>"},{"location":"javascript/callback-hell/#modern-solutions-to-callback-hell","title":"Modern Solutions to Callback Hell","text":"<p>Want cleaner code? Explore how Promises and async/await can flatten the pyramid and return control to your hands.</p> <p> Continue to: Promises \u2192</p>"},{"location":"javascript/closure-interview-questions/","title":"Interview Questions: Closures","text":""},{"location":"javascript/closure-interview-questions/#what-are-closures-in-js","title":"What are closures In JS?","text":"<p>Imagine a function that carries a little backpack with it. This backpack holds all the variables that were around when the function was created. That's essentially a closure!</p> <p>More formally, a closure is a function that retains access to its lexical scope (the environment where it was written), even when the function is executed outside that original scope. It \"remembers\" the variables from its birthplace.</p>"},{"location":"javascript/closure-interview-questions/#how-youll-explain-more-about-it","title":"How you\u2019ll explain more about it?","text":"<p>Every function in JavaScript automatically gets access to variables and functions defined in its parent's environment (its outer lexical scope).</p> <p>The key part of a closure is this: even if you take that inner function and run it somewhere else entirely (like returning it from the outer function and calling it later), it still remembers and can use the variables from its original parent scope.</p>"},{"location":"javascript/closure-interview-questions/#what-about-an-example-to-explain-all-this","title":"What about an example to explain all this?","text":"<p>Sure, let's look at a classic example:</p> <pre><code>function outer() {\n  var a = 10; // Variable defined in outer's scope\n\n  function inner() {\n    // inner() can access 'a' because it's in its lexical scope\n    console.log(a);\n  }\n\n  return inner; // Return the inner function itself\n}\n\n// Execute outer(), which returns the inner function.\n// Then immediately execute the returned inner function.\nouter()(); // Output: 10\n</code></pre> <p>In this code:</p> <ol> <li><code>inner()</code> is defined inside <code>outer()</code>.</li> <li><code>inner()</code> has access to the variable <code>a</code> from <code>outer()</code>'s scope.</li> <li>We return <code>inner</code> from <code>outer</code>.</li> <li>When we call <code>outer()()</code>, the <code>inner</code> function is executed after <code>outer</code> has finished.</li> <li>Even though <code>outer</code> has finished, <code>inner</code> still remembers <code>a</code> (which is 10) because it formed a closure over <code>outer</code>'s scope.</li> </ol> <p>So, <code>inner()</code> is the closure here.</p>"},{"location":"javascript/closure-interview-questions/#what-is-outer-why-there-are-two-parenthesis","title":"What is <code>outer()()</code>? Why there are two parenthesis?","text":"<p>The double parentheses <code>()</code> <code>()</code> are used because <code>outer()</code> returns a function, and we then immediately want to call that returned function.</p> <p>Let's break it down:</p> <ol> <li><code>outer()</code>: This first call executes the <code>outer</code> function. Its job is to set up the variable <code>a</code> and return the <code>inner</code> function definition.<ul> <li>Output of just <code>outer()</code>:     <pre><code>\u0192 inner() {\n    console.log(a);\n}\n</code></pre></li> </ul> </li> <li><code>()</code>: This second set of parentheses calls the function that was returned by <code>outer()</code>, which is the <code>inner</code> function. This is when <code>console.log(a)</code> actually runs.<ul> <li>Output of <code>outer()()</code>:     <pre><code>10\n</code></pre></li> </ul> </li> </ol> <p>You could achieve the same result more explicitly like this:</p> <pre><code>function outer() {\n  var a = 10;\n  function inner() {\n    console.log(a);\n  }\n  return inner;\n}\n\nvar close = outer(); // 'close' now holds the 'inner' function\nclose();             // Now call the 'inner' function. Output: 10\n</code></pre> <p>This shows clearly that <code>outer()</code> returns a function, which we store in <code>close</code>, and then we execute <code>close</code>. The <code>outer()()</code> syntax is just a shorthand for this.</p>"},{"location":"javascript/closure-interview-questions/#what-if-var-declaration-is-moved-just-before-return-will-it-still-be-a-closure","title":"What if <code>var</code> declaration is moved just before return? Will it still be a Closure?","text":"<p>Yes, absolutely! Let's see:</p> <pre><code>function outer() {\n  function inner() {\n    // inner still knows about 'a' due to lexical scoping rules,\n    // even though 'a' is declared later in the outer scope.\n    console.log(a);\n  }\n  var a = 10; // Declaration moved down\n  return inner;\n}\n\nvar close = outer();\nclose(); // Output: 10\n</code></pre> <p>It still works and <code>inner</code> is still a closure. Why? Because JavaScript determines the scope of variables based on where functions are lexically (physically) written in the code, not based on the order of execution or declaration within that scope (thanks to hoisting for <code>var</code>). The <code>inner</code> function is defined within the scope of <code>outer</code>, so it has access to all variables declared within <code>outer</code>, regardless of whether they are declared before or after <code>inner</code> itself.</p>"},{"location":"javascript/closure-interview-questions/#what-if-var-is-replaced-by-let-what-will-happen","title":"What if <code>var</code> is replaced by <code>let</code>? What will happen?","text":"<p>It still works perfectly fine, and <code>inner</code> remains a closure.</p> <pre><code>function outer() {\n  function inner() {\n    console.log(a); // Still has access to 'a'\n  }\n  let a = 10; // Using 'let' instead of 'var'\n  return inner;\n}\n\nvar close = outer();\nclose(); // Output: 10\n</code></pre> <p>Using <code>let</code> (or <code>const</code>) doesn't change the fundamental concept of lexical scoping or closures. The <code>inner</code> function is still defined within the scope where <code>a</code> exists, so it closes over <code>a</code>. The main difference <code>let</code> introduces is block scoping and the temporal dead zone, but that doesn't prevent the closure from forming here.</p>"},{"location":"javascript/closure-interview-questions/#what-if-outer-have-a-parameter-what-happens-then","title":"What if <code>outer()</code> have a parameter? What happens then?","text":"<p>Parameters of a function are also part of its local scope. So, an inner function can close over its outer function's parameters just like it closes over its variables.</p> <pre><code>function outer(b) { // 'b' is a parameter of outer\n  function inner() {\n    // inner can access both 'a' (variable) and 'b' (parameter)\n    console.log(a, b);\n  }\n  let a = 10;\n  return inner;\n}\n\n// Pass an argument when calling outer()\nvar close = outer(\"Hi Closures\");\nclose(); // Output: 10 Hi Closures\n</code></pre> <p>It works exactly as you'd expect. The parameter <code>b</code> is part of <code>outer</code>'s environment, and <code>inner</code> forms a closure over that environment, remembering both <code>a</code> and <code>b</code>.</p>"},{"location":"javascript/closure-interview-questions/#what-if-outer-function-is-nested-into-another-function-will-inner-have-access-to-the-outermost-functions-environment-as-well","title":"What if <code>outer()</code> function is nested into another function? Will <code>inner()</code> have access to the outermost function\u2019s environment as well?","text":"<p>Yes! This demonstrates the scope chain. An inner function has access to its own scope, its parent's scope, its grandparent's scope, and so on, all the way up to the global scope.</p> <pre><code>function outest() {\n  var c = 12; // Variable in the outermost function\n\n  function outer(b) { // Middle function with parameter 'b'\n    function inner() {\n      // inner can access 'a', 'b', and 'c'\n      console.log(a, b, c);\n    }\n    let a = 10; // Variable in the middle function\n    return inner;\n  }\n  return outer; // outest returns the outer function\n}\n\n// Call outest() to get the 'outer' function\n// Then call the returned 'outer' function with an argument (\"Hi Closures\")\n// This returns the 'inner' function\nvar close = outest()(\"Hi Closures\");\n\n// Finally, call the 'inner' function\nclose(); // Output: 10 Hi Closures 12\n</code></pre> <p>The <code>inner</code> function forms a closure that encompasses the scopes of both <code>outer</code> (including <code>a</code> and <code>b</code>) and <code>outest</code> (including <code>c</code>).</p>"},{"location":"javascript/closure-interview-questions/#what-if-we-have-global-variable-with-conflicted-name","title":"What if we have global variable with conflicted name?","text":"<p>JavaScript uses lexical scoping, meaning it looks for variables starting from the innermost scope and working outwards. The first scope where it finds the variable is the one it uses.</p> <p>Scenario 1: Local variable shadows global variable</p> index.js<pre><code>function outest() {\n  var c = 12;\n  function outer(b) {\n    function inner() {\n      // Looks for 'a' in inner's scope (not found)\n      // Looks for 'a' in outer's scope (found!) -&gt; uses let a = 10\n      console.log(a, b, c);\n    }\n    let a = 10; // This 'a' is local to 'outer'\n    return inner;\n  }\n  return outer;\n}\n\nlet a = 100; // Global variable 'a'\n\nvar close = outest()(\"Hi Closures\");\nclose(); // Output: 10 Hi Closures 12\n</code></pre> <p>Here, <code>inner()</code> finds <code>a</code> in its parent <code>outer</code>'s scope (<code>let a = 10</code>). It uses that one and stops looking. The global <code>let a = 100</code> is ignored because the closer, local <code>a</code> \"shadows\" it.</p> <p>Scenario 2: Local variable commented out</p> index.js<pre><code>function outest() {\n  var c = 12;\n  function outer(b) {\n    function inner() {\n      // Looks for 'a' in inner's scope (not found)\n      // Looks for 'a' in outer's scope (not found)\n      // Looks for 'a' in outest's scope (not found)\n      // Looks for 'a' in global scope (found!) -&gt; uses let a = 100\n      console.log(a, b, c);\n    }\n    // let a = 10; // Commented out\n    return inner;\n  }\n  return outer;\n}\n\nlet a = 100; // Global variable 'a'\n\nvar close = outest()(\"Hi Closures\");\nclose(); // Output: 100 Hi Closures 12\n</code></pre> <p>Now, since <code>inner</code> can't find <code>a</code> in <code>outer</code>'s scope, it continues searching outwards and finds the global <code>a = 100</code>.</p> <p>Scenario 3: Both local and global commented out</p> index.js<pre><code>function outest() {\n  var c = 12;\n  function outer(b) {\n    function inner() {\n      // Looks for 'a' everywhere up to global scope (not found)\n      console.log(a, b, c);\n    }\n    // let a = 10; // Commented out\n    return inner;\n  }\n  return outer;\n}\n\n// let a = 100; // Commented out\n\nvar close = outest()(\"Hi Closures\");\n// close(); // This would cause an error!\n// Output: ReferenceError: a is not defined\n</code></pre> <p>If <code>a</code> isn't found anywhere in the scope chain, trying to access it results in a <code>ReferenceError</code>.</p>"},{"location":"javascript/closure-interview-questions/#what-are-the-advantages-of-closure","title":"What are the advantages of Closure?","text":"<p>Closures are powerful and enable several important patterns and techniques in JavaScript:</p> <ul> <li>Data Hiding and Encapsulation: Creating private variables and functions that are protected from the outside world, but accessible to privileged functions. This is fundamental to the Module Pattern.</li> <li>Module Design Pattern: Creating self-contained pieces of code with private state and public interfaces, avoiding global scope pollution.</li> <li>Currying: Transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.</li> <li>Function Factories: Creating functions with specific configurations based on the outer function's arguments (like in the <code>outer(b)</code> example earlier).</li> <li>Maintaining State in Asynchronous Operations: Callbacks (like those used in <code>setTimeout</code>, event listeners, or Promises) often rely on closures to access variables from the scope where they were created, even if the callback executes much later.</li> <li>Implementing Iterators: Creating functions that remember their state between calls to generate sequences of values.</li> <li>Memoization: Caching the results of expensive function calls and returning the cached result when the same inputs occur again. Closures can hold the cache.</li> <li>Creating Functions like <code>once</code>: Designing functions that can only be executed a single time.</li> </ul>"},{"location":"javascript/closure-interview-questions/#what-are-disadvantages-of-closure","title":"What are disadvantages of Closure?","text":"<p>While powerful, closures aren't without potential downsides:</p> <ul> <li>Memory Consumption: Since closures retain references to their outer scope variables, those variables cannot be garbage collected as long as the closure exists. If many closures are created, or if closures hold references to large data structures that are no longer needed otherwise, it can lead to higher memory usage than expected.</li> <li>Memory Leaks (if not careful): In older browsers or specific scenarios (like circular references involving DOM elements and JavaScript objects), closures could inadvertently prevent memory from being reclaimed, leading to memory leaks if the closures themselves were never released. Modern JavaScript engines and garbage collectors are much better at handling this, but it's still a theoretical possibility if closures are managed improperly.</li> </ul>"},{"location":"javascript/closure-interview-questions/#what-is-garbage-collector","title":"What is Garbage Collector?","text":"<p>A Garbage Collector (GC) is an automatic memory management feature found in many high-level programming languages like JavaScript. Its main job is to identify and free up memory that is no longer being used by the program.</p> <ul> <li>How it works (simplified): The GC periodically looks at all the objects (variables, functions, etc.) the program has created. It figures out which objects are still reachable (can be accessed by the program, starting from the root, like the global object) and which are unreachable. Unreachable objects are considered \"garbage\" because the program can no longer use them. The GC then reclaims the memory occupied by this garbage, making it available for new objects.</li> <li>Contrast with manual management: In languages like C or C++, the programmer is often responsible for explicitly allocating memory when needed and deallocating (freeing) it when it's no longer required. Forgetting to deallocate leads to memory leaks. JavaScript's GC automates this process, reducing the burden on the developer.</li> </ul>"},{"location":"javascript/closure-interview-questions/#how-closures-and-garbage-collector-related-to-each-other","title":"How Closures and Garbage Collector related to each other?","text":"<p>Closures directly influence how the Garbage Collector operates because they keep variables \"alive\".</p> <p>Consider this example:</p> <pre><code>function a() {\n  var x = 10; // 'x' is local to function 'a'\n  return function b() { // 'b' is a closure\n    console.log(x); // 'b' references 'x' from its parent scope\n  };\n}\n\nvar y = a(); // 'y' now holds the function 'b'\n// At this point, function 'a' has finished executing.\n\n// Later...\n// y(); // If we call y(), it needs access to 'x'\n</code></pre> <p>Here's the relationship:</p> <ol> <li>Normally, when function <code>a</code> finishes executing, its local variable <code>x</code> would become unreachable and eligible for garbage collection.</li> <li>However, function <code>a</code> returned function <code>b</code>.</li> <li>Function <code>b</code> is a closure and maintains a reference to its lexical scope, which includes the variable <code>x</code>.</li> <li>Because the function <code>b</code> (now referenced by the global variable <code>y</code>) might be called later, and it needs <code>x</code> to work correctly, the JavaScript engine ensures that <code>x</code> is not garbage collected. It's kept in memory specifically for the closure <code>b</code>.</li> </ol> <p>So, closures prevent the GC from reclaiming the memory of the variables they close over, for as long as the closure itself is reachable. This is essential for closures to work but is also why they can increase memory usage (as mentioned in the disadvantages).</p>"},{"location":"javascript/closure-interview-questions/#what-is-smartly-garbaged-variable-examples","title":"What is Smartly garbaged variable, examples?","text":"<p>Modern JavaScript engines often employ optimizations in their garbage collection related to closures. They can sometimes detect if a variable within the outer scope is actually used by the inner closure or not. If a variable is part of the outer scope but not referenced by the returned inner function(s), the engine might be smart enough to garbage collect it, even if other variables from the same scope are kept alive by the closure.</p> <p>Example:</p> <pre><code>function a() {\n  var x = 10; // Referenced by the closure 'b'\n  var z = 20; // NOT referenced by the closure 'b'\n\n  return function b() {\n    // This closure only uses 'x'\n    console.log(x);\n  };\n}\n\nvar y = a(); // 'y' holds the closure 'b'\n// y(); // Calling y would print 10\n</code></pre> <p>In this case:</p> <ul> <li>The closure <code>b</code> (held by <code>y</code>) needs <code>x</code>, so <code>x</code> cannot be garbage collected.</li> <li>The closure <code>b</code> does not need or reference <code>z</code> in any way.</li> <li>A smart garbage collector can recognize that <code>z</code> is no longer reachable after function <code>a</code> finishes, even though <code>x</code> from the same scope is being kept alive. Therefore, <code>z</code> can be garbage collected (\"smartly garbaged\"), while <code>x</code> remains in memory for the closure.</li> </ul> <p>This optimization helps mitigate the memory overhead of closures by only keeping the necessary parts of the outer scope alive.</p>"},{"location":"javascript/closures/","title":"Closures in JavaScript","text":"<p>Have you ever wondered what happens to a function's local variables after the function has finished executing? Can inner functions still access them? This is where the powerful concept of closures comes into play in JavaScript.</p> <p> Goto Scope Chain, Scope and Lexical Environment</p> <p>Let's start by understanding the foundation: Lexical Scoping.</p> <p>Consider this simple example:</p> index.js<pre><code>function x() {\n    var a = 7; // 'a' is lexically scoped to function x\n    function y() {\n        // 'y' is lexically inside 'x'\n        console.log(a); // Tries to find 'a' in y's scope, then looks up to x's scope\n    }\n    y();\n}\nx();\n</code></pre> <p>When <code>y()</code> is executed, it needs the value of <code>a</code>. JavaScript's lexical scoping rule means <code>y()</code> first looks in its own local scope. Not finding <code>a</code> there, it looks up to its lexical parent's scope, which is <code>x()</code>. It finds <code>a</code> in <code>x()</code>'s scope and uses its value.</p> Expected Output<pre><code>7\n</code></pre> <p>This seems straightforward. But what happens when we return the inner function before executing it?</p>"},{"location":"javascript/closures/#the-magic-of-returning-functions","title":"\u2728 The Magic of Returning Functions","text":"<p>Let's modify the previous example:</p> index.js<pre><code>function x() {\n    var a = 7;\n    function y() {\n        console.log(a);\n    }\n    return y; // Return the function y itself, not its result\n}\n\nvar z = x(); // Execute x(), which returns function y. Store y in z.\nconsole.log(z);\n\n// What happens now when we call z()?\nz();\n</code></pre> <p>Here's the puzzle:</p> <ol> <li>We execute <code>x()</code>, and it returns the entire function <code>y</code>. This returned function is stored in the variable <code>z</code>.</li> <li>After line 9 (<code>var z = x();</code>), the function <code>x()</code> has finished executing. Its execution context is gone from the call stack. Normally, we'd expect its local variable <code>a</code> to be garbage collected.</li> <li>But then, on line 13 (<code>z();</code>), we execute the function that used to be <code>y</code>. This function still needs to access variable <code>a</code>. How does it find it if <code>x()</code> is gone?</li> </ol> Expected Output<pre><code>\u0192 y() {\n    console.log(a);\n}\n7\n</code></pre> <p>It still prints <code>7</code>!</p> <p>This happens because of closures.</p>"},{"location":"javascript/closures/#what-is-a-closure","title":"\ud83e\udd14 What is a Closure?","text":"<p>A closure is the combination of a function bundled together with references to its surrounding state (the lexical environment). In simpler terms, a closure gives you access to an outer function\u2019s scope from an inner function, even after the outer function has finished executing.</p> <p>When <code>y</code> was returned from <code>x</code>, it didn't just return the function's code; it returned the function along with a persistent reference to its lexical environment, which included the variable <code>a</code>. This \"package\" of the function and its environment is the closure.</p> Illustrative debugger view showing `y` retaining access to `a` via closure"},{"location":"javascript/closures/#closures-capture-references-not-just-values","title":"Closures Capture References, Not Just Values","text":"<p>Closures don't just capture the value of a variable at the moment the closure is created; they capture a reference to the variable itself. This means if the variable's value changes before the closure is executed, the closure will see the updated value.</p> <p>Consider this:</p> index.js<pre><code>function x() {\n    var a = 7;\n    function y() {\n        console.log(a); // 'a' here refers to the variable 'a' in x's scope\n    }\n    a = 100; // Change 'a' *after* y is defined, but *before* y is returned/called\n    return y;\n}\n\nvar z = x();\nconsole.log(z);\nz(); // Execute the closure\n</code></pre> <p>What will <code>z()</code> print now?</p> Expected Output<pre><code>\u0192 y() {\n    console.log(a);\n}\n100\n</code></pre> <p>It prints <code>100</code> because the closure associated with <code>y</code> holds a reference to the variable <code>a</code>. By the time <code>z()</code> (which is <code>y</code>) is executed, the value of <code>a</code> in its remembered lexical scope is <code>100</code>. The variable <code>a</code> wasn't garbage collected because the closure still held a reference to it.</p> Illustrative debugger view showing the closure referencing the updated value of <code>a</code>"},{"location":"javascript/closures/#nested-functions-and-chained-closures","title":"Nested Functions and Chained Closures","text":"<p>Closures work across multiple levels of nested functions. An inner function forms closures over the scope of all its parent functions.</p> index.js<pre><code>function grandParent() {\n  var c = 900;\n  function parent() {\n    var b = 20;\n    function child() {\n      var a = 10;\n      console.log(a, b, c); // Accesses variables from all parent scopes\n    }\n    child();\n  }\n  parent();\n}\n\ngrandParent();\n</code></pre> <p>When <code>child()</code> executes, it needs <code>a</code>, <code>b</code>, and <code>c</code>.</p> <ul> <li>It finds <code>a</code> in its own scope.</li> <li>It finds <code>b</code> in its lexical parent's scope (<code>parent</code>).</li> <li>It finds <code>c</code> in its grandparent's scope (<code>grandParent</code>).</li> </ul> <p>If <code>child</code> were returned, it would form a closure containing references to <code>a</code>, <code>b</code>, and <code>c</code>.</p> Expected Output<pre><code>10 20 900\n</code></pre> Illustrative debugger view showing closures for both <code>parent</code> (containing <code>b</code>) and <code>grandParent</code> (containing <code>c</code>) scopes"},{"location":"javascript/closures/#why-use-closures-use-cases","title":"Why Use Closures? (Use Cases)","text":"<p>Closures are fundamental to many patterns and techniques in JavaScript:</p> <ul> <li>Data Hiding and Encapsulation: Creating private variables and methods (Module Pattern).</li> <li>Maintaining State in Asynchronous Operations: Callbacks in <code>setTimeout</code>, event listeners, or promises often rely on closures to access variables from their original context.</li> <li>Function Factories: Creating functions with preset configurations (e.g., currying).</li> <li>Memoization: Caching results of expensive function calls.</li> <li>Iterators: Implementing custom iteration logic.</li> <li>Partial Application &amp; Currying: Creating specialized functions from more general ones.</li> </ul>"},{"location":"javascript/closures/#potential-downsides","title":"Potential Downsides","text":"<p>While powerful, closures should be used mindfully:</p> <ul> <li>Memory Consumption: Since variables within a closure's scope are not garbage collected as long as the closure exists, they can potentially consume significant memory if closures are created excessively or hold large data structures unnecessarily.</li> <li>Memory Leaks: If closures are inadvertently kept alive (e.g., circular references, uncleared event listeners), the memory they hold onto will never be released, leading to memory leaks.</li> </ul> <p>Understanding closures is key to mastering JavaScript, enabling you to write more elegant, efficient, and powerful code.</p>"},{"location":"javascript/debouncing-throttling/","title":"Debouncing and Throttling","text":"<p>Debouncing and throttling are two powerful techniques used to optimize performance in JavaScript applications, especially when dealing with events that can fire rapidly (like scrolling, resizing, or input events).</p>"},{"location":"javascript/debouncing-throttling/#debouncing","title":"Debouncing","text":"<p>Debouncing delays the execution of a function until after a specified time has passed since it was last invoked. It's like saying, \"Wait until the user stops typing before making the API call.\"</p>"},{"location":"javascript/debouncing-throttling/#how-it-works","title":"How It Works","text":"debounce.js<pre><code>const debounce = (fn, delay) =&gt; {\n    let timer;\n    return function() {\n        const context = this;\n        const args = arguments;\n\n        clearTimeout(timer);\n\n        timer = setTimeout(() =&gt; {\n            fn.apply(context, args);\n        }, delay);\n    }\n}\n</code></pre>"},{"location":"javascript/debouncing-throttling/#real-world-example","title":"Real-World Example","text":"debounce-example.js<pre><code>// Function we want to debounce\nconst getData = (searchTerm) =&gt; {\n    console.log('Fetching:', searchTerm);\n    // API call would go here\n}\n\n// Create debounced version\nconst debouncedGetData = debounce(getData, 300);\n\n// Use it with an input field\ndocument.getElementById('search').addEventListener('input', function(e) {\n    debouncedGetData(e.target.value);\n});\n</code></pre> <p>In this example, the API call is only made 300ms after the user stops typing.</p>"},{"location":"javascript/debouncing-throttling/#throttling","title":"Throttling","text":"<p>Throttling limits how often a function can be called in a given time period. It's like saying, \"No matter how many times this event fires, only execute the function once every X milliseconds.\"</p>"},{"location":"javascript/debouncing-throttling/#how-it-works_1","title":"How It Works","text":"throttle.js<pre><code>const throttle = (fn, limit) =&gt; {\n    let flag = true;\n    return function() {\n        const context = this;\n        const args = arguments;\n\n        if (flag) {\n            fn.apply(context, args);\n            flag = false;\n\n            setTimeout(() =&gt; {\n                flag = true;\n            }, limit);\n        }\n    }\n}\n</code></pre>"},{"location":"javascript/debouncing-throttling/#real-world-example_1","title":"Real-World Example","text":"throttle-example.js<pre><code>// Create throttled version of getData\nconst throttledGetData = throttle(getData, 400);\n\n// Use it with an input field\ndocument.getElementById('search2').addEventListener('input', function(e) {\n    throttledGetData(e.target.value);\n});\n</code></pre> <p>With throttling, the function executes immediately, then waits for the specified time before it can execute again.</p>"},{"location":"javascript/debouncing-throttling/#when-to-use-which","title":"When to Use Which?","text":"<ul> <li>Use debouncing when you want to wait for a pause in activity before taking action (search inputs, window resizing)</li> <li>Use throttling when you want to ensure an action happens at a regular interval regardless of event frequency (infinite scrolling, game controls)</li> </ul>"},{"location":"javascript/debouncing-throttling/#key-differences","title":"Key Differences","text":"Debouncing Throttling Delays function execution until after a period of inactivity Executes function at a regular interval regardless of how many times the event is fired Ideal for search inputs, form validation Ideal for scroll events, mousemove, game input Function might never execute if events keep firing Function will execute at least once within the time interval <p>Both techniques are essential tools for frontend developers to create responsive and performant user interfaces.</p>"},{"location":"javascript/event-deligation/","title":"Event Delegation","text":"<p>Event propagation is how events travel through the DOM tree. When an event occurs on an element, it doesn't just affect that element but also travels through its ancestors in the DOM hierarchy. There are two main phases of event propagation:</p> <ol> <li>Capturing Phase: Events start from the root element and travel down to the target element</li> <li>Bubbling Phase: Events start from the target element and bubble up to the root element</li> </ol>"},{"location":"javascript/event-deligation/#the-event-flow","title":"The Event Flow","text":"<p>The complete event flow consists of three phases:</p> <p></p> <ol> <li>Capturing Phase: From window to the target element</li> <li>Target Phase: The event reaches the target element</li> <li>Bubbling Phase: From the target element back up to the window</li> </ol>"},{"location":"javascript/event-deligation/#example-capturing-vs-bubbling","title":"Example: Capturing vs Bubbling","text":"<pre><code>&lt;div id=\"grandparent\"&gt;\n  &lt;div id=\"parent\"&gt;\n    &lt;div id=\"child\"&gt;Click me!&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>document.querySelector('#grandparent').addEventListener('click', function () {\n    console.log('Grandparent clicked');\n}, true); // true enables capturing phase\n\ndocument.querySelector('#parent').addEventListener('click', function () {\n    console.log('Parent clicked');\n}, true);\n\ndocument.querySelector('#child').addEventListener('click', function (e) {\n    console.log('Child clicked');\n    e.stopPropagation(); // Stops the event from further propagation\n}, false); // false (default) uses bubbling phase\n</code></pre>"},{"location":"javascript/event-deligation/#what-happens-when-the-child-is-clicked","title":"What happens when the child is clicked?","text":"<ol> <li>Capturing phase starts: Grandparent \u2192 Parent</li> <li>Target phase: Child</li> <li>Bubbling phase: Stops immediately due to <code>e.stopPropagation()</code></li> </ol> <p>Without <code>stopPropagation()</code>, the event would continue bubbling up.</p>"},{"location":"javascript/event-deligation/#event-delegation_1","title":"Event Delegation","text":"<p>Event delegation is a technique that leverages event bubbling to handle events efficiently, especially when dealing with multiple similar elements.</p>"},{"location":"javascript/event-deligation/#example","title":"Example","text":"<pre><code>document.querySelector('#parent').addEventListener('click', function (e) {\n    if (e.target.id === 'child') {\n        console.log('Child clicked');\n    }\n});\n</code></pre> <p>This pattern is particularly useful for:</p> <ul> <li>Dynamic elements that might be added/removed from the DOM</li> <li>Lists with many items</li> <li>Performance optimization when dealing with many elements</li> </ul>"},{"location":"javascript/event-deligation/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<ol> <li>Efficiency: Only one event listener for multiple elements</li> <li>Dynamic elements: Works with elements added after page load</li> <li>Memory: Reduces the number of event handlers in memory</li> <li>Simplicity: Centralizes event handling logic</li> </ol> <p>This pattern is particularly useful when working with lists, tables, or any UI where you have multiple similar interactive elements.</p>"},{"location":"javascript/event-deligation/#practical-tips","title":"Practical Tips","text":"<ul> <li>Use capturing rarely, bubbling is more common</li> <li><code>stopPropagation()</code> prevents further propagation in either direction</li> <li><code>stopImmediatePropagation()</code> prevents other handlers on the same element from executing</li> <li>Event delegation can significantly improve performance for complex UIs</li> </ul>"},{"location":"javascript/event-deligation/#further-reading","title":"Further Reading","text":"<ol> <li>Event Deligation:</li> </ol> <ol> <li>JavaScript Event Listeners:</li> </ol>"},{"location":"javascript/first-class-functions/","title":"First-Class Functions","text":"<p>Functions are fundamental building blocks in JavaScript. But have you ever wondered why sometimes you can call a function before you define it, and other times you can't? This difference often boils down to how the function is created. Let's dive in!</p>"},{"location":"javascript/first-class-functions/#statement-vs-expression-the-hoisting-puzzle","title":"Statement vs. Expression: The Hoisting Puzzle","text":"<p>One of the most crucial differences between the two main ways of creating functions lies in hoisting. Hoisting is JavaScript's behavior of moving declarations (like function declarations and <code>var</code> variables) to the top of their scope before code execution.</p> <p>The difference between function statement and function expression is hoisting.</p> <p>Consider this:</p> index.js<pre><code>greet(); // \u2705 This works! Why? Because function *statements* are fully hoisted.\n\n// greetMe(); // \u274c TypeError: greetMe is not a function. Why? Function *expressions* are not fully hoisted like statements.\n\nconsole.log('--------Function Statement aka function Declaration--------');\n// Definition below\n\nconsole.log('--------Function Expression--------');\n// Definition below\n</code></pre> <p>Let's break down each type.</p>"},{"location":"javascript/first-class-functions/#function-statement-aka-function-declaration","title":"Function Statement (aka Function Declaration)","text":"<p>This is the classic way to define a function.</p> index.js<pre><code>function greet() {\n    console.log('This way of defining function is called Function Statement');\n}\n\n// You can call it before or after its definition in the code (due to hoisting)\ngreet();\n</code></pre> <p>Key characteristics:</p> <ul> <li>Starts with the <code>function</code> keyword.</li> <li>Requires a function name (<code>greet</code> in this case).</li> <li>The entire function definition is hoisted, making it available throughout its scope even before the line it's defined on.</li> </ul>"},{"location":"javascript/first-class-functions/#function-expression","title":"Function Expression","text":"<p>Here, a function is created and assigned to a variable. The function itself often doesn't have a name (making it anonymous), although it can (see Named Function Expression).</p> index.js<pre><code>var greetMe = function () {\n    console.log('Function acts like a value and can be assigned to a variable');\n    console.log('This way of defining function is called Function Expression');\n}\n\n// You can only call it *after* the assignment\ngreetMe();\n</code></pre> <p>Key characteristics:</p> <ul> <li>The function is treated like a value.</li> <li>It's assigned to a variable (<code>greetMe</code>).</li> <li>If using <code>var</code>, the variable declaration (<code>var greetMe</code>) is hoisted, but the assignment (<code>= function() {...}</code>) is not. This is why you get a <code>TypeError</code> if you call it before the assignment line \u2013 <code>greetMe</code> exists but holds <code>undefined</code> initially, not the function.</li> </ul>"},{"location":"javascript/first-class-functions/#anonymous-function","title":"Anonymous Function","text":"<p>An anonymous function is simply a function without a name.</p> index.js<pre><code>// Standalone anonymous function - This causes an error!\n/*\nfunction () {\n    console.log('Function without a name is called Anonymous Function');\n    // Uncaught SyntaxError: Function statements require a function name\n}\n*/\n\n// Use Case: Assigning to a variable (making it a Function Expression)\nvar sayHi = function () {\n    console.log('Anonymous function is assigned to a variable');\n};\nsayHi();\n\n// Another Use Case: Passing as an argument (see First-Class Functions)\nsetTimeout(function() {\n    console.log(\"This anonymous function runs after 1 second\");\n}, 1000);\n</code></pre> <p>Why the error?</p> <p>Function statements require a name. Anonymous functions are typically used where functions are treated as values, like in function expressions or when passed as arguments.</p>"},{"location":"javascript/first-class-functions/#named-function-expression","title":"Named Function Expression","text":"<p>This is similar to a function expression, but the function being assigned does have a name.</p> index.js<pre><code>var greetYou = function innerGreet() {\n    console.log('Function with a name assigned to a variable is a Named Function Expression');\n    // The name 'innerGreet' is primarily useful for debugging (stack traces)\n    // and recursion within the function itself.\n};\n\ngreetYou();\n</code></pre> <p>Corner Case Gotcha</p> index.js<pre><code>var b = function xyz() {\n    console.log('Trying to access xyz from outside...');\n    // console.log(xyz); // This would work inside the function for recursion\n};\n\n// b(); // This works\n\n// xyz(); // \u274c Uncaught ReferenceError: xyz is not defined\n</code></pre> <p>Important</p> <p>The name in a named function expression (<code>innerGreet</code>, <code>xyz</code>) is typically only available within the function's own scope. It's not created in the outer (global or enclosing) scope. You still call the function using the variable it was assigned to (<code>greetYou</code>, <code>b</code>).</p>"},{"location":"javascript/first-class-functions/#parameters-vs-arguments","title":"Parameters vs. Arguments","text":"<p>These terms are often confused, but they have distinct meanings:</p> <ul> <li>Parameters are the names listed in the function definition. They act as placeholders or local variables within the function.</li> <li>Arguments are the actual values passed to the function when it is called (invoked).</li> </ul> index.js<pre><code>// 'param1' and 'param2' are parameters\nfunction greetWithParameters(param1, param2) {\n    console.log('Parameter 1 (param1): ' + param1);\n    console.log('Parameter 2 (param2): ' + param2);\n}\n\n// 'Hello' and 'World' are arguments\ngreetWithParameters('Hello', 'World');\n</code></pre>"},{"location":"javascript/first-class-functions/#first-class-functions_1","title":"\u2728 First-Class Functions","text":"<p>In JavaScript, functions are \"first-class citizens\". This fancy term means you can treat functions just like any other value (like numbers, strings, or objects). This ability includes:</p> <ol> <li>Assigning functions to variables (as seen in Function Expressions).</li> <li>Passing functions as arguments to other functions.</li> <li>Returning functions from other functions.</li> </ol> <p>This is a powerful concept that enables patterns like callbacks and higher-order functions.</p> index.js<pre><code>// 1. Passing a function as an argument\nfunction logGreeting(fn) { // 'fn' is a parameter expected to be a function\n    console.log(\"Executing the function passed as an argument:\");\n    fn(); // Calling the passed-in function\n}\n\n// Passing an anonymous function expression\nlogGreeting(function () {\n    console.log('Hello World (from anonymous function argument)');\n});\n\n// Passing a named function\nfunction sayGoodbye() {\n    console.log('Goodbye! (from named function argument)');\n}\nlogGreeting(sayGoodbye);\n\n\n// 2. Returning a function from another function\nfunction createGreeter() {\n    // This function creates and returns *another* function\n    return function() {\n        console.log('This function was returned from createGreeter!');\n    };\n}\n\nvar generatedGreeter = createGreeter(); // generatedGreeter now holds the returned function\ngeneratedGreeter(); // Execute the returned function\n\n// You can also call the returned function immediately\nconsole.log(\"Calling the returned function immediately:\");\ncreateGreeter()(); // Calls createGreeter, then calls the function it returns\n</code></pre>"},{"location":"javascript/first-class-functions/#arrow-functions-es6","title":"\u27a1\ufe0f Arrow Functions (ES6)","text":"<p>Introduced in ES6 (ECMAScript 2015), arrow functions provide a more concise syntax for writing function expressions. They also have some differences in how they handle the <code>this</code> keyword (which is a topic for another discussion).</p> index.js<pre><code>// Traditional function expression\nvar add = function(a, b) {\n  return a + b;\n};\n\n// Equivalent arrow function\nvar addArrow = (a, b) =&gt; {\n  return a + b;\n};\n\n// Even shorter for single return expressions\nvar addArrowConcise = (a, b) =&gt; a + b;\n\nconsole.log('--------Arrow Functions--------');\nconsole.log(\"Traditional:\", add(2, 3));\nconsole.log(\"Arrow:\", addArrow(2, 3));\nconsole.log(\"Concise Arrow:\", addArrowConcise(2, 3));\n\nvar greetArrow = () =&gt; {\n    console.log('Arrow functions offer a shorter syntax!');\n}\ngreetArrow();\n</code></pre> <p>Arrow functions are very common in modern JavaScript due to their brevity.</p>"},{"location":"javascript/function-currying/","title":"Function Currying","text":"<p>Ever needed to create specialized versions of a function without rewriting it? Function currying offers an elegant solution!</p> <p>Currying is a functional programming technique where a function that takes multiple arguments is transformed into a sequence of functions, each taking only a single argument. Instead of accepting all arguments at once, the curried function takes the first argument and returns a new function. This new function then takes the second argument and returns another function, and so on, until all arguments have been provided. The final function in the chain then returns the result.</p>"},{"location":"javascript/function-currying/#prerequisite","title":"Prerequisite","text":"<p> call, apply, and bind method in JavaScript</p> <p> Closures in JavaScript</p>"},{"location":"javascript/function-currying/#why-use-currying","title":"Why Use Currying?","text":"<ul> <li>Creating Specialized Functions: Easily create new functions with some arguments pre-set.</li> <li>Improving Reusability: Break down complex functions into smaller, reusable pieces.</li> <li>Enhancing Readability: Can sometimes make function composition clearer.</li> </ul>"},{"location":"javascript/function-currying/#how-to-achieve-currying-in-javascript","title":"How to Achieve Currying in JavaScript","text":"<p>There are two primary ways to implement function currying in JavaScript:</p>"},{"location":"javascript/function-currying/#1-using-the-bind-method","title":"1. Using the <code>bind</code> Method","text":"<p>The <code>bind()</code> method creates a new function that, when called, has its <code>this</code> keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called. We can leverage this to \"pre-fill\" arguments.</p> <p>Example of a <code>multiply</code> function that multiplies two numbers using <code>bind</code> for currying</p> <pre><code>let multiply = function (x, y) {\n    console.log(x * y);\n};\n</code></pre> <p>Now, let's use <code>bind</code> to create specialized versions:</p> <pre><code>// Create a function that always multiplies by 2\nlet multiplyByTwo = multiply.bind(this, 2);\nmultiplyByTwo(5); // Output: 10 (x is bound to 2, y is 5)\n\n// Create a function that always multiplies by 3\nlet multiplyByThree = multiply.bind(this, 3);\nmultiplyByThree(5); // Output: 15 (x is bound to 3, y is 5)\n\n// Bind only 'this', arguments are provided later\nlet multiplyByFour = multiply.bind(this);\nmultiplyByFour(4, 5); // Output: 20 (x is 4, y is 5)\n</code></pre> <p>In the examples <code>multiplyByTwo</code> and <code>multiplyByThree</code>, <code>bind</code> creates new functions where the first argument (<code>x</code>) is fixed (or bound) to <code>2</code> and <code>3</code> respectively. The new functions only need the second argument (<code>y</code>) to complete the calculation. In <code>multiplyByFour</code>, no arguments are bound initially, so it behaves like the original <code>multiply</code> function.</p>"},{"location":"javascript/function-currying/#2-using-closures","title":"2. Using Closures","text":"<p>Closures provide a natural way to achieve currying. A closure occurs when a function remembers its lexical scope (the environment in which it was created), even when the function is executed outside that scope. We can use nested functions to create this effect.</p> <p>Example of a <code>sum</code> function that adds two numbers using closures for currying</p> <pre><code>let sum = function (a) {\n    // This inner function forms a closure, remembering 'a'\n    return function (b) {\n        console.log(a + b);\n    };\n}\n\n// Create a specialized function 'addTwo' where 'a' is fixed to 2\nlet addTwo = sum(2);\n\n// Call the inner function with 'b' = 3\naddTwo(3); // Output: 5 (a was 2, b is 3)\n</code></pre> <p>Here's how it works:</p> <ol> <li>Calling <code>sum(2)</code> executes the outer function with <code>a = 2</code>.</li> <li>It returns the inner function <code>function (b) { console.log(a + b); }</code>.</li> <li>Crucially, this inner function remembers that <code>a</code> was <code>2</code> because of the closure.</li> <li>When we call <code>addTwo(3)</code>, we are executing the inner function, providing <code>b = 3</code>. It accesses the remembered <code>a = 2</code> and calculates <code>2 + 3</code>.</li> </ol> <p>Both <code>bind</code> and closures are effective ways to implement function currying in JavaScript, allowing you to create more flexible and reusable functions.</p>"},{"location":"javascript/function-invocation-and-variable-environment/","title":"Function Invocation and Variable Environment in JavaScript","text":"<p>This section explains how JavaScript handles function calls and manages variables using execution contexts, illustrated with an example involving two functions, <code>a()</code> and <code>b()</code>, each declaring a variable named <code>x</code> but with different values. We also include a global variable <code>x</code> to demonstrate scope differences.</p> <p>Understanding this process is fundamental to grasping concepts like scope and closures in JavaScript</p> <p>Consider the following code:</p> index.js<pre><code>var x = 1;\na();\nb();\nconsole.log(x);\n\nfunction a(){\n    var x= 10;\n    console.log(x)\n}\n\nfunction b(){\n    var x= 100;\n    console.log(x)\n}\n</code></pre> The expected output is<pre><code>10                                  index.js:8\n100                                 index.js:13\n1                                   index.js:4\n</code></pre> <p>Let's break down the execution step-by-step:</p> <p>Execution Context Overview</p> <p>When a JavaScript program runs, a Global Execution Context (GEC) is created. Every execution context has two phases:</p> <ol> <li>Creation Phase: The JavaScript engine sets up the memory space for variables and functions (the Variable Environment). Variables declared with <code>var</code> are initialized with <code>undefined</code>. Function declarations are stored entirely.</li> <li>Execution Phase: The code is executed line by line.</li> </ol> <p>The Call Stack manages execution contexts. The GEC is the base of the stack. When a function is called, a new Function Execution Context (FEC) is created and pushed onto the stack. When the function finishes, its FEC is popped off the stack.</p>"},{"location":"javascript/function-invocation-and-variable-environment/#step-by-step-execution","title":"Step-by-Step Execution:","text":"<ol> <li> <p>GEC Creation:</p> <ul> <li>The GEC is created and pushed onto the Call Stack.</li> <li>Memory is allocated for <code>x</code>, <code>a</code>, and <code>b</code> in the GEC's Variable Environment. <code>x</code> is initialized to <code>undefined</code>. <code>a</code> and <code>b</code> store their function definitions. </li> </ul> </li> <li> <p>GEC Execution (Line 1):</p> <ul> <li><code>var x = 1;</code> is executed.</li> <li>The value <code>1</code> is assigned to the global variable <code>x</code>. </li> </ul> </li> <li> <p>GEC Execution (Line 2): <code>a()</code> Invocation:</p> <ul> <li>Function <code>a()</code> is called.</li> <li>A new Function Execution Context (FEC) for <code>a</code> is created.</li> <li><code>a</code> FEC Creation Phase: Memory is allocated for <code>a</code>'s local variable <code>x</code>, initialized to <code>undefined</code>.</li> <li>The <code>a</code> FEC is pushed onto the Call Stack. Control enters function <code>a</code>.</li> </ul> </li> <li> <p><code>a</code> FEC Execution (Line 7):</p> <ul> <li><code>var x = 10;</code> is executed within <code>a</code>.</li> <li>The value <code>10</code> is assigned to the local variable <code>x</code> within <code>a</code>'s FEC.</li> </ul> </li> <li> <p><code>a</code> FEC Execution (Line 8):</p> <ul> <li><code>console.log(x);</code> is executed.</li> <li>JavaScript looks for <code>x</code> in the current FEC (<code>a</code>'s context). It finds the local <code>x</code> with the value <code>10</code>.</li> <li><code>10</code> is printed to the console. </li> </ul> </li> <li> <p><code>a</code> FEC Completion (End of function <code>a</code>):</p> <ul> <li>Function <code>a</code> finishes execution.</li> <li>The FEC for <code>a</code> is popped off the Call Stack and destroyed. Control returns to the GEC at the point where <code>a</code> was called (after line 2). </li> </ul> </li> <li> <p>GEC Execution (Line 3): <code>b()</code> Invocation:</p> <ul> <li>Control is now at line 3 in the GEC. </li> <li>Function <code>b()</code> is called.</li> <li>A new FEC for <code>b</code> is created.</li> <li><code>b</code> FEC Creation Phase: Memory is allocated for <code>b</code>'s local variable <code>x</code>, initialized to <code>undefined</code>.</li> <li>The <code>b</code> FEC is pushed onto the Call Stack. Control enters function <code>b</code>.</li> </ul> </li> <li> <p><code>b</code> FEC Execution (Line 12):</p> <ul> <li><code>var x = 100;</code> is executed within <code>b</code>.</li> <li>The value <code>100</code> is assigned to the local variable <code>x</code> within <code>b</code>'s FEC.</li> </ul> </li> <li> <p><code>b</code> FEC Execution (Line 13):</p> <ul> <li><code>console.log(x);</code> is executed.</li> <li>JavaScript looks for <code>x</code> in the current FEC (<code>b</code>'s context). It finds the local <code>x</code> with the value <code>100</code>.</li> <li><code>100</code> is printed to the console. </li> </ul> </li> <li> <p><code>b</code> FEC Completion (End of function <code>b</code>):</p> <ul> <li>Function <code>b</code> finishes execution.</li> <li>The FEC for <code>b</code> is popped off the Call Stack and destroyed. Control returns to the GEC at the point where <code>b</code> was called (after line 3).  </li> </ul> </li> <li> <p>GEC Execution (Line 4):</p> <ul> <li>Control is now at line 4 in the GEC.</li> <li><code>console.log(x);</code> is executed.</li> <li>JavaScript looks for <code>x</code> in the current execution context (the GEC). It finds the global <code>x</code> with the value <code>1</code>.</li> <li><code>1</code> is printed to the console. </li> </ul> </li> <li> <p>GEC Completion:</p> <ul> <li>The script reaches the end.</li> <li>The GEC is popped off the Call Stack. The program finishes. </li> </ul> </li> </ol> <p>This detailed breakdown illustrates how JavaScript manages separate execution contexts for global code and each function call, ensuring variables in different scopes do not interfere with each other.</p> <p>For video explanation, refer to Namaste Javascript series.</p>"},{"location":"javascript/higher-order-functions/","title":"Higher-Order Functions in JavaScript","text":"<p>Imagine you have a list of numbers, say, the radii of different circles: <code>[3, 1, 2, 4]</code>. Now, what if you need to calculate the area for each circle? And then the circumference? And maybe the diameter too?</p> <p>You could write separate loops for each calculation, but that feels repetitive, right? There must be a more elegant way to apply different operations to the same list. This is where Higher-Order Functions come into play!</p>"},{"location":"javascript/higher-order-functions/#what-exactly-are-they","title":"What Exactly Are They?","text":"<p>Let's start with a simple definition and example:</p> <p>A function that either takes another function as an argument, returns a function, or does both, is called a Higher-Order Function (HOF). The function passed as an argument is often called a callback function.</p> <p>Consider this basic JavaScript code:</p> index.js<pre><code>// This is just a simple function\nfunction x() {\n    console.log(\"Hello\");\n}\n\n// This function 'y' takes another function ('x' in this case) as an argument\nfunction y(callbackFn) {\n    callbackFn(); // Execute the function that was passed in\n}\n\n// Here, we pass the function 'x' to the function 'y'\ny(x); // Output: Hello\n</code></pre> <p>In this example:</p> <ul> <li><code>y</code> is the Higher-Order Function because it accepts <code>x</code> as an argument.</li> <li><code>x</code> is the Callback Function because it's passed into <code>y</code> to be called later.</li> </ul>"},{"location":"javascript/higher-order-functions/#a-practical-example-calculating-with-radii","title":"A Practical Example: Calculating with Radii","text":"<p>Now, let's revisit our circle problem. We want to perform different calculations on an array of radii.</p> <p>First, define the specific calculation logic as separate functions:</p> main.js<pre><code>// Array of radii\nconst radius = [3, 1, 2, 4];\n\n// Function to calculate area\nconst area = function (radius) {\n    return Math.PI * radius * radius;\n};\n\n// Function to calculate circumference\nconst circumference = function (radius) {\n    return 2 * Math.PI * radius;\n};\n\n// Function to calculate diameter\nconst diameter = function (radius) {\n    return 2 * radius;\n};\n</code></pre> <p>JavaScript's built-in <code>Array.prototype.map</code> is a perfect example of a Higher-Order Function. It takes a callback function and applies it to each element in the array, returning a new array with the results.</p> <pre><code>// Use the built-in map HOF\nconsole.log(radius.map(area));\n// Output: [ 28.27..., 3.14..., 12.56..., 50.26... ]\n\nconsole.log(radius.map(circumference));\n// Output: [ 18.84..., 6.28..., 12.56..., 25.13... ]\n\nconsole.log(radius.map(diameter));\n// Output: [ 6, 2, 4, 8 ]\n</code></pre> <p>See how clean that is? We defined the what (the calculation logic: <code>area</code>, <code>circumference</code>, <code>diameter</code>) separately from the how (the iteration logic, handled by <code>map</code>).</p>"},{"location":"javascript/higher-order-functions/#building-our-own-higher-order-function","title":"Building Our Own Higher-Order Function","text":"<p>To really understand how HOFs work, let's create our own version of <code>map</code>, like a polyfill. We'll call it <code>calculate</code>.</p> main.js<pre><code>// Add a 'calculate' method to the Array prototype\nArray.prototype.calculate = function (logicFn) { // logicFn is our callback\n    const output = [];\n    // 'this' refers to the array instance (e.g., radius)\n    for (let i = 0; i &lt; this.length; i++) {\n        // Call the provided logic function for each element\n        output.push(logicFn(this[i]));\n    }\n    return output;\n};\n\n// Now use our custom HOF\nconsole.log(radius.calculate(area));\n// Output: [ 28.27..., 3.14..., 12.56..., 50.26... ]\n\nconsole.log(radius.calculate(circumference));\n// Output: [ 18.84..., 6.28..., 12.56..., 25.13... ]\n\nconsole.log(radius.calculate(diameter));\n// Output: [ 6, 2, 4, 8 ]\n</code></pre> <p>Our <code>calculate</code> function doesn't know or care what calculation <code>logicFn</code> performs. It only knows it needs to call some function for each element. This separation of concerns makes the code incredibly reusable and flexible.</p> <p></p>"},{"location":"javascript/higher-order-functions/#the-benefits","title":"The Benefits","text":"<p>Using Higher-Order Functions leads to:</p> <ol> <li>Reusability: Write common logic (like iterating over an array) once and reuse it with different callback functions.</li> <li>Abstraction: Hide complex or repetitive logic inside the HOF, making the code that uses the HOF cleaner and easier to understand.</li> <li>Readability: Functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> often make the intent of the code clearer than manual loops.</li> <li>Functional Programming: HOFs are a cornerstone of functional programming, encouraging the use of pure functions and immutable data.</li> </ol> <p>By treating functions as first-class citizens (meaning they can be passed around like any other variable), JavaScript empowers you to write more modular, expressive, and maintainable code.</p>"},{"location":"javascript/hoisting/","title":"Hoisting in JavaScript","text":"<p>Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope during the compilation phase. This means you can reference variables and functions before they are defined in the code.</p>"},{"location":"javascript/hoisting/#example-hoisting-with-var-and-functions","title":"Example: Hoisting with <code>var</code> and Functions","text":"index.js<pre><code>var x = 8;\n\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n\ngetName();\nconsole.log(x);\n</code></pre> Console Output<pre><code>Hellow World                    index.js:4\n8                               index.js:8\n</code></pre> <p>We can also try accessing them before their declarations:</p> index.js<pre><code>console.log(x);\ngetName();\n\nvar x = 8;\n\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> Console Output<pre><code>undefined                       index.js:1\nHellow World                    index.js:7\n</code></pre> <ul> <li><code>getName</code> is accessible and works as expected.</li> <li><code>x</code> is <code>undefined</code> because only the declaration is hoisted, not the initialization.</li> </ul> <p>If you remove <code>var x = 8;</code></p> index.js<pre><code>console.log(x);\ngetName();\n\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> Console Output<pre><code>Uncaught ReferenceError: x is not defined at index.js:1:6    index.js:1\nHellow World                                                 index.js:5\n</code></pre> <ul> <li>Now, <code>x</code> is not declared at all, so we get a ReferenceError.</li> </ul> <p>Is <code>undefined</code> and <code>not defined</code> are same thing?</p> <p>No, <code>undefined</code> means that the variable is declared but not initialised. <code>not defined</code> means the variable was never declared.</p>"},{"location":"javascript/hoisting/#inspecting-function-hoisting","title":"\ud83d\udd0d Inspecting Function Hoisting","text":"index.js<pre><code>function getName() {\n    console.log(\"Hellow World\");\n}\nconsole.log(getName)\n</code></pre> <p>Console Output<pre><code>\u0192 getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> It Just prints the function. </p> <p> What if try to get function name before initialising it like did for <code>x</code> which gives <code>undefined</code>?</p> index.js<pre><code>console.log(getName)\nvar x = 8;\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> Console Output<pre><code>f getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> <p>Why Does This Happen?</p> <p>Before JavaScript executes your code, it allocates memory for variables and functions. Functions are fully hoisted (their code is available), while variables declared with <code>var</code> are hoisted but initialized as <code>undefined</code>.</p> <p>So,</p> index.js<pre><code>getName();\nconsole.log(x);\nconsole.log(getName);\n\nvar x = 8;\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> Console Output<pre><code>Hellow World                            index.js:7\nundefined                               index.js:2\nf getName() {                           index.js:4\n    console.log(\"Hellow World\");\n}\n</code></pre> <p> So, let\u2019s dig down deep and see why it is behaving like this. Remember how Execution context works in previous sections.</p> <p>So, even before this whole javascript code executes in javascript, memory gets allocated to each and every variable and function. Evern if we put debugger here on first line of code, that means even first line of code is not executed yet but we can see variable and function already have memory allocated.</p> <p></p> index.js<pre><code>getName();\nconsole.log(x);\n\nconsole.log(getName);\n\nvar x = 8;\n\nfunction getName() {\n    console.log(\"Hellow World\");\n}\n</code></pre> <p></p> Console Output<pre><code>Hellow World                             index.js:9\nundefined                                index.js:2\nf getName() {                            index.js:4\n    console.log(\"Hellow World\");\n}\n</code></pre>"},{"location":"javascript/hoisting/#undefined-vs-not-defined","title":"<code>undefined</code> vs <code>not defined</code>","text":"<ul> <li>If a variable is declared but not initialized, it is undefined.</li> <li>If a variable is never declared, it is not defined and accessing it throws a ReferenceError.</li> </ul>"},{"location":"javascript/hoisting/#hoisting-with-arrow-functions","title":"Hoisting with Arrow Functions","text":"<p>Arrow functions behave differently:</p> index.js<pre><code>getName();\nconsole.log(x);\n\nconsole.log(getName);\n\nvar x = 8;\n\nvar getName = () =&gt; {\n    console.log(\"Hellow World\");\n}\n</code></pre> Console Output<pre><code>Uncaught TypeError: getName is not a function at index.js....\n</code></pre> <p>Why?</p> <p>Arrow functions are not hoisted in the same way as regular functions. They are treated like variables, so they are hoisted but not initialized. This means you cannot call them before their declaration. During the hoisting phase, <code>getName</code> is <code>undefined</code>.</p> <p></p> <p>Points to Remember</p> <p>Only function declarations are fully hoisted. Function expressions and arrow functions are treated as variables.</p> <p>For more details, check out this article on hoisting.</p>"},{"location":"javascript/how-javascript-works/","title":"Execution Context in JavaScript","text":"<ul> <li>Everything in JavaScript happens inside an execution context.</li> <li>Think of an execution context as a big box or container where the entire JavaScript code runs.</li> <li>The execution context has two main components:<ol> <li>Memory Component</li> <li>Code Component</li> </ol> </li> </ul>"},{"location":"javascript/how-javascript-works/#1-memory-component","title":"1. Memory Component","text":"<ul> <li>This is where all variables and functions are stored as key-value pairs.</li> <li>The memory component is also called the variable environment.</li> </ul>"},{"location":"javascript/how-javascript-works/#2-code-component","title":"2. Code Component","text":"<ul> <li>This is where the code is executed, one line at a time.</li> <li>The code component is also known as the thread of execution.</li> <li>The whole code is executed one line at a time.</li> </ul>"},{"location":"javascript/how-javascript-works/#visual-representation-execution-context","title":"Visual Representation: Execution Context","text":"Memory (Variable Environment) Code (Thread of Execution) key : value ... a : 10 .... fn : ..... <ul> <li>Memory: Stores variables and functions as key-value pairs.</li> <li>Code: Executes code one line at a time.</li> </ul> <p>Memory is also called the Variable Environment. Code is also known as the Thread of Execution.</p> <p>Is JavaScript Synchronous or Asynchronous?</p> <p>JavaScript is a synchronous, single-threaded language by default.</p> <ul> <li>It executes one command at a time, in a specific order.</li> <li>Each line of code runs only after the previous line has finished.</li> <li>This means JavaScript moves to the next line only when the current line is done.</li> </ul> <p>Note</p> <p>While JavaScript itself is synchronous, it can handle asynchronous operations (like callbacks, promises, and async/await) using its event loop and browser APIs. These features allow JavaScript to perform non-blocking operations, but the core execution model remains single-threaded and synchronous.</p>"},{"location":"javascript/javascript-call-stack/","title":"Execution Contexts and the Call Stack","text":""},{"location":"javascript/javascript-call-stack/#what-happens-when-you-run-javascript-code","title":"What happens when you run JavaScript Code?","text":"<ul> <li>Execution context is created when javascript code is run.</li> <li>Execution context is created in two phases<ol> <li>Memory creation phase</li> <li>Code execution phase</li> </ol> </li> </ul> <pre><code>var n =2;\n\nfunction square (num){\n    var ans = num * num;\n    return ans;\n}\n\nvar square2 = square(n);\nvar square4 = square(4);\n</code></pre> <p>Here's an explanation of how the JavaScript code is executed:</p>"},{"location":"javascript/javascript-call-stack/#1-global-execution-context-creation","title":"1\ufe0f\u20e3 Global Execution Context Creation","text":"<ul> <li>When the script starts, JavaScript creates a main container called the Global Execution Context.</li> <li>This context handles memory allocation and code execution.</li> </ul>"},{"location":"javascript/javascript-call-stack/#memory-creation-phase","title":"Memory Creation Phase","text":"<ul> <li>Memory is set aside for the variable <code>n</code> (initially <code>undefined</code>).</li> <li>The entire <code>square</code> function definition is stored in memory.</li> <li>Memory is set aside for variables <code>square2</code> and <code>square4</code> (initially <code>undefined</code>).</li> </ul>"},{"location":"javascript/javascript-call-stack/#code-execution-phase","title":"Code Execution Phase","text":"<ul> <li>The code is executed line by line.</li> <li><code>var n = 2;</code>: The value <code>2</code> is assigned to the variable <code>n</code>.</li> </ul>"},{"location":"javascript/javascript-call-stack/#2-first-function-call-squaren","title":"2\ufe0f\u20e3 First Function Call: <code>square(n)</code>","text":"<ul> <li><code>var square2 = square(n);</code>: The <code>square</code> function is called with the current value of <code>n</code> (which is <code>2</code>).</li> <li> <p>New Function Execution Context:  A new, temporary context is created specifically for this function call.</p> <ul> <li> <p>Memory Phase: Memory is allocated for the parameter <code>num</code> and the variable <code>ans</code> (both initially <code>undefined</code>).</p> Identifier Value num undefined ans undefined </li> <li> <p>Code Execution Phase:</p> <ul> <li><code>num</code> gets the value passed into the function (<code>2</code>).</li> <li><code>var ans = num * num;</code>: <code>ans</code> is calculated as <code>2 * 2</code>, which is <code>4</code>.</li> <li><code>return ans;</code>: The value <code>4</code> is returned from the function.</li> </ul> </li> </ul> </li> </ul> <p></p> <ul> <li>Context Deletion: The Function Execution Context for <code>square(2)</code> is destroyed.</li> <li>The returned value (<code>4</code>) is assigned to the variable <code>square2</code>.</li> </ul>"},{"location":"javascript/javascript-call-stack/#3-second-function-call-square4","title":"3\ufe0f\u20e3 Second Function Call: <code>square(4)</code>","text":"<ul> <li><code>var square4 = square(4);</code> is executed.</li> <li> <p>New Function Execution Context (for <code>square(4)</code>)</p> <ul> <li> <p>Memory Creation Phase: Memory is allocated for <code>num</code> and <code>ans</code> (both <code>undefined</code>).</p> Identifier Value num undefined ans undefined </li> <li> <p>Code Execution Phase:</p> <ul> <li><code>num</code> gets the value passed into the function (<code>4</code>).</li> <li><code>var ans = num * num;</code>: <code>ans</code> is calculated as <code>4 * 4</code>, which is <code>16</code>.</li> <li><code>return ans;</code>: The value <code>16</code> is returned.</li> </ul> </li> </ul> </li> </ul> <p></p> <ul> <li>Function context is destroyed.</li> <li><code>square4</code> is assigned the returned value <code>16</code>.</li> </ul>"},{"location":"javascript/javascript-call-stack/#4-end-of-script","title":"4\ufe0f\u20e3 End of Script","text":"<p>After all lines are executed, the Global Execution Context is deleted.</p>"},{"location":"javascript/javascript-call-stack/#final-output","title":"Final Output","text":"<p>After the code runs:</p> <ul> <li><code>n</code> will have the value <code>2</code>.</li> <li><code>square2</code> will have the value <code>4</code>.</li> <li><code>square4</code> will have the value <code>16</code>.</li> </ul> <p>Video Explanation</p> <ul> <li>For a more detailed explanation, check out the video by Akshay Saini</li> <li>YouTube - Namaste JavaScript</li> </ul>"},{"location":"javascript/javascript-call-stack/#call-stack-in-javascript","title":"Call Stack in JavaScript","text":"<p>The call stack is a fundamental mechanism in JavaScript that manages the creation, deletion, and control of execution contexts during code execution.</p> <p>The call stack works just like a physical stack\u2014last in, first out (LIFO). At the bottom of the stack is the Global Execution Context (GEC). Whenever a JavaScript program runs, the GEC is created and pushed onto the call stack.</p>"},{"location":"javascript/javascript-call-stack/#step-by-step-example","title":"Step-by-Step Example","text":"<pre><code>var n = 2;\nfunction square(num) {\n    var ans = num * num;\n    return ans;\n}\nvar square2 = square(n);\nvar square4 = square(4);\n</code></pre> <p>Here's how the call stack manages execution:</p> Call Stack <ul> <li> <p>Global Execution Context (GEC):</p> <p>When the script starts, the GEC is pushed onto the stack.</p> </li> <li> <p>Function Invocation:</p> <p>Each time a function is invoked (e.g., square(n) at line 6), a new execution context (let's call it E1) is created and pushed onto the stack above the GEC.</p> </li> <li> <p>Function Completion:</p> <p>Once the function finishes executing, E1 is popped off the stack, and control returns to the GEC.</p> </li> <li> <p>Subsequent Function Calls:</p> <p>When another function is called (e.g., square(4) at line 7), a new execution context (E2) is created and pushed onto the stack. After execution, E2 is also popped off, and control returns to the GEC.</p> </li> <li> <p>End of Script:</p> <p>After all code has executed, the GEC is removed, leaving the call stack empty.</p> </li> </ul> <p>Key Points</p> <ul> <li>The call stack is a LIFO structure that manages order of execution contexts.</li> <li>Each function call creates a new context, which is pushed onto the stack.</li> <li>When a function completes, its context is popped off the stack.</li> <li>The GEC is always at the bottom of the stack.</li> <li>The call stack is also known as:<ul> <li>Execution Context Stack</li> <li>Program Stack</li> <li>Control Stack</li> <li>Runtime Stack</li> <li>Machine Stack</li> </ul> </li> </ul>"},{"location":"javascript/javascript-call-stack/#further-reading","title":"Further Reading","text":"<p>Please refer to the  Asynchronous JavaScript &amp; Event Loop for more details on how the call stack interacts with asynchronous operations.</p>"},{"location":"javascript/js-engine-architecture/","title":"JavaScript Engine Architecture","text":"<p> Ever wondered how the JavaScript code you write actually runs? It's not magic! It happens inside something called a JavaScript Runtime Environment, and at the heart of it lies the JavaScript Engine. Let's peel back the layers and see what's going on under the hood, focusing on Google's powerful V8 engine.</p>"},{"location":"javascript/js-engine-architecture/#javascript-runtime-environment","title":"JavaScript Runtime Environment","text":"<p>Think of the JavaScript Runtime Environment (JRE) as a big container holding everything needed to execute JavaScript code. Whether it's in your browser or on a server using Node.js, the JRE provides the necessary components.</p> <p></p> <p>Key parts of a JRE typically include:</p> <ul> <li>JavaScript Engine: The core component that actually understands and executes your JS code. (We'll dive deep into this!)</li> <li>Web APIs / Node APIs: Connectors that allow your JavaScript code to interact with the outside world (like the browser's DOM, timers (<code>setTimeout</code>), file system access in Node.js, etc.).</li> <li>Callback Queue: A waiting area for callback functions that are ready to be executed (e.g., after a timer finishes or data arrives).</li> <li>Microtask Queue: A special queue, often with higher priority than the Callback Queue, used for things like Promises.</li> <li>Event Loop: The orchestrator that constantly checks if the Call Stack is empty and moves functions from the Callback Queue or Microtask Queue to the Call Stack for execution.</li> </ul> <p>The JS Engine is truly the heart of the JRE.</p>"},{"location":"javascript/js-engine-architecture/#browser-vs-nodejs-runtime","title":"Browser vs. Node.js Runtime","text":"<p>JavaScript isn't limited to browsers anymore!</p> <ol> <li>Browser: Executes JS code using its built-in JRE. This allows for dynamic websites and web applications.</li> <li>Node.js: An open-source JRE that lets you run JavaScript outside the browser, typically for server-side applications, build tools, and more.</li> </ol> <p>While both environments run JavaScript, the specific APIs available might differ. For example, browsers have APIs to manipulate the web page (DOM APIs), while Node.js has APIs for server-specific tasks like file system access or networking. However, some APIs, like <code>setTimeout</code>, exist in both, though their internal implementation might vary. The existence of JREs is why JavaScript can run on so many different devices!</p>"},{"location":"javascript/js-engine-architecture/#javascript-engines-the-heart-of-execution","title":"JavaScript Engines: The Heart of Execution","text":"<p>Different browsers and environments often use different JS engines.</p>"},{"location":"javascript/js-engine-architecture/#common-engines","title":"Common Engines","text":"<ul> <li>V8: Google's engine, used in Chrome, Edge, Node.js, Deno, and more. Known for its speed.</li> <li>SpiderMonkey: Mozilla's engine, used in Firefox. The original JS engine!</li> <li>JavaScriptCore (JSC): Apple's engine, used in Safari.</li> <li>Chakra: Microsoft's engine (though Edge now uses V8).</li> </ul> <p>All reputable engines strive to follow the ECMAScript standard, which is the official specification defining the JavaScript language. ECMAScript is the governing body ensuring consistency across different JavaScript implementations.</p>"},{"location":"javascript/js-engine-architecture/#the-first-engine","title":"The First Engine","text":"<p>The very first JavaScript engine was created by Brendan Eich, the inventor of JavaScript itself! It was initially called Mocha, then LiveScript, and eventually became SpiderMonkey, which powers Firefox today.</p>"},{"location":"javascript/js-engine-architecture/#busting-myths","title":"Busting Myths","text":"<ul> <li>Myth: A JS Engine is a physical machine.</li> <li>Reality: A JS Engine is sophisticated software, typically written in a lower-level language like C++. Google's V8, for instance, is primarily written in C++. These programs take the high-level JavaScript code we write and convert it into low-level machine code that the computer's processor can directly execute.</li> </ul>"},{"location":"javascript/js-engine-architecture/#inside-the-js-engine-how-code-becomes-reality","title":"Inside the JS Engine: How Code Becomes Reality","text":"<p>So, what actually happens when you feed JavaScript code into an engine like V8? It generally goes through three major phases:</p> <p></p>"},{"location":"javascript/js-engine-architecture/#1-parsing-breaking-down-the-code","title":"1. Parsing: Breaking Down the Code","text":"<p>The engine first needs to understand the structure of your code. This phase involves:</p> <ul> <li>Lexical Analysis (Tokenization): A Lexer or Tokenizer reads your code, breaking it into a sequence of individual units called tokens (e.g., keywords like <code>const</code>, identifiers, operators).</li> <li>Syntax Parsing: The Syntax Parser takes this stream of tokens and verifies that they form a grammatically correct structure according to JavaScript's syntax rules. If the syntax is valid, the parser builds an Abstract Syntax Tree (AST).</li> <li>Abstract Syntax Tree (AST): This is the tree-like data structure representing the logical structure of your code. Each node in the AST corresponds to a construct in your code (like a VariableDeclaration, FunctionDeclaration, or an operation).</li> </ul> <p>You can visualize ASTs using tools like AST Explorer. The generated AST is then passed on to the next phase.</p>"},{"location":"javascript/js-engine-architecture/#2-compilation-optimizing-for-speed","title":"2. Compilation: Optimizing for Speed","text":"<p>Modern JS engines don't just interpret code line by line anymore.They utilize sophisticated compilation techniques, often Just-In-Time (JIT) compilation, which combines the best of interpreters and compilers.</p> <ul> <li> <p>Interpreter (e.g., V8's Ignition): Takes the AST and quickly converts it into an intermediate representation called Bytecode. Bytecode is lower-level than JavaScript but not yet machine code. This allows the code to start executing relatively fast.</p> </li> <li> <p>Compiler (e.g., V8's TurboFan): While the interpreter is running, the engine monitors the code. If it identifies \"hot\" sections (code that runs frequently or could be made faster), the optimizing compiler kicks in. It uses profiling data to generate highly optimized machine code for those specific parts.</p> </li> <li> <p>Optimized Code: This optimized code replaces the Bytecode execution for subsequent runs, leading to significant performance improvements.</p> </li> <li> <p>Deoptimization: If assumptions made by the optimizing compiler are invalidated, the code can be deoptimized back to Bytecode.</p> </li> </ul> <p>Note: Some engines might also perform Ahead-of-Time (AOT) compilation in certain scenarios.</p> <p>Compilation and execution often happen hand-in-hand in modern engines.</p>"},{"location":"javascript/js-engine-architecture/#3-execution-running-the-code","title":"3. Execution: Running the Code","text":"<p>This is where the code actually does its work. Two crucial components managed by the engine are essential for execution: le  1.  Memory Heap: A large, unstructured region of memory where objects, variables, and function definitions are stored. This is where memory allocation happens. 2.  Call Stack: A data structure that keeps track of function calls. When a function is called, a new \"execution context\" (a frame containing the function's arguments and local variables) is pushed onto the stack. When the function finishes, its frame is popped off the stack. JavaScript is single-threaded, meaning it has only one call stack and can only do one thing at a time.</p>"},{"location":"javascript/js-engine-architecture/#interpreted-vs-compiled-the-javascript-debate","title":"Interpreted vs. Compiled: The JavaScript Debate","text":"<p>So, is JavaScript an interpreted or a compiled language? The answer is... it depends on the engine, but most modern engines make it both!</p> <ul> <li>Historically: JavaScript started as purely interpreted.</li> <li>Today: Most modern engines (like V8, SpiderMonkey, JSC) use Just-In-Time (JIT) compilation.</li> </ul> <p>JIT Compilation Recap:</p> <ol> <li>Code is initially interpreted (e.g., into Bytecode by V8's Ignition) for a fast startup.</li> <li>The engine monitors the running code.</li> <li>Frequently executed or optimizable parts are compiled into highly efficient machine code by an optimizing compiler (e.g., V8's TurboFan) during execution.</li> </ol> <p>This gives JavaScript the benefits of both: quick startup (like interpreters) and high performance for frequently run code (like compilers).</p>"},{"location":"javascript/js-engine-architecture/#garbage-collection","title":"Garbage Collection","text":"<p>Remember the Memory Heap? As your program runs, it allocates memory for variables and objects. What happens when that memory is no longer needed?</p> <ul> <li>Garbage Collector (GC): This is a background process within the JS engine responsible for automatically finding and freeing up memory that is no longer reachable or in use by the program. This prevents memory leaks and keeps the application running smoothly.</li> <li>Mark &amp; Sweep Algorithm: A common algorithm used by GCs (including variants in V8).<ol> <li>Mark: The GC starts from the root objects (like the global object) and traverses all reachable objects, marking them as \"in use\".</li> <li>Sweep: The GC scans the entire memory heap. Any object that was not marked is considered garbage and the memory it occupies is reclaimed.</li> </ol> </li> </ul> <p>V8 uses sophisticated garbage collectors like Orinoco and Oil Pan with various optimizations.</p> <p>Engines also perform other optimizations during compilation, such as:</p> <ul> <li>Inlining: Replacing a function call with the actual code of the function.</li> <li>Inline Caching: Optimizing repeated access to object properties.</li> <li>(And many more...)</li> </ul>"},{"location":"javascript/js-engine-architecture/#googles-v8-engine-a-closer-look","title":"Google's V8 Engine: A Closer Look","text":"<p>V8 is widely regarded as one of the fastest and most advanced JavaScript engines. Key components include:</p> <ul> <li>Ignition: V8's interpreter, responsible for generating and executing Bytecode. Provides fast startup.</li> <li>TurboFan: V8's optimizing compiler. Creates highly optimized machine code for hot functions.</li> <li>Orinoco &amp; Oil Pan: V8's state-of-the-art garbage collectors, employing parallel and concurrent techniques to minimize pauses.</li> </ul> <p>For deep dives, the official V8 blog is an excellent resource.</p>"},{"location":"javascript/js-engine-architecture/#trust-issues-with-settimeout","title":"TRUST ISSUES with setTimeout()","text":"<p>Let's switch gears slightly and talk about a common source of confusion: <code>setTimeout</code>. You might think <code>setTimeout(callback, 5000)</code> guarantees your <code>callback</code> function will run exactly 5 seconds later.</p> <p>Prepare for a surprise!</p>"},{"location":"javascript/js-engine-architecture/#the-problem-why-the-delay-isnt-guaranteed","title":"The Problem: Why the Delay Isn't Guaranteed?","text":"<p>The core issue is that <code>setTimeout</code> doesn't guarantee execution time, only minimum delay time before the callback is queued. JavaScript's single-threaded nature and the Event Loop model are key here.</p> <p>Here's the typical flow:</p> <ol> <li>Your main JavaScript code starts running (a Global Execution Context - GEC - is pushed onto the Call Stack).</li> <li>When <code>setTimeout(callback, delay)</code> is encountered:<ul> <li>The <code>callback</code> function is not executed immediately.</li> <li>It's handed off to a separate part of the Runtime Environment (like the Web API in browsers).</li> <li>A timer starts for the specified <code>delay</code>.</li> </ul> </li> <li>Crucially: Your main JavaScript code continues running without waiting for the timer. The Call Stack keeps processing synchronous code.</li> <li>Once the timer expires, the <code>callback</code> function is moved to the Callback Queue.</li> <li>The Event Loop constantly monitors: Is the Call Stack empty? If yes, it checks the Callback Queue.</li> <li>If the Call Stack is empty and there's a callback waiting in the queue, the Event Loop pushes that callback onto the Call Stack, finally allowing it to execute.</li> </ol> <p>The \"Trust Issue\": If your main thread (the Call Stack) is busy executing long-running synchronous code when the <code>setTimeout</code> timer expires, the callback must wait in the Callback Queue. It can only run when the Call Stack becomes empty, which might be significantly later than the <code>delay</code> you specified!</p> <p>This mechanism is part of JavaScript's concurrency model, allowing asynchronous operations (like timers, network requests) to happen without blocking the main thread entirely.</p>"},{"location":"javascript/js-engine-architecture/#blocking-the-main-thread","title":"Blocking the Main Thread","text":"<p>Let's see this delay in action. We'll use a <code>while</code> loop to deliberately block the main thread for 10 seconds after setting a 5-second timeout.</p> <p></p> <p>What happens?</p> <ol> <li>\"Start\" is logged.</li> <li><code>setTimeout</code> registers the callback with the browser/Node API and starts a 5-second timer. The main code continues.</li> <li>\"End\" is logged.</li> <li>The <code>while</code> loop starts, blocking the Call Stack.</li> <li>After 5 seconds: The <code>setTimeout</code> timer expires. The callback function is moved to the Callback Queue, waiting patiently.</li> <li>After 10 seconds: The <code>while</code> loop finally finishes. \"While loop finished!\" is logged. The Global Execution Context finishes its synchronous work.</li> <li>The Call Stack becomes empty.</li> <li>The Event Loop sees the empty Call Stack and the waiting callback in the Callback Queue.</li> <li>The Event Loop pushes the callback onto the Call Stack.</li> <li>\"Callback\" is finally logged, approximately 10 seconds after \"Start\", not 5!</li> </ol> <p>This demonstrates that <code>setTimeout</code> only guarantees the minimum time before queuing, not the exact execution time.</p>"},{"location":"javascript/js-engine-architecture/#what-about-settimeout0","title":"What About <code>setTimeout(0)</code>?","text":"<p>Setting a timeout of <code>0</code> milliseconds might seem like it should run the callback immediately, but it doesn't.</p> <pre><code>console.log(\"Start\");\n\nsetTimeout(() =&gt; {\n    // Even with 0ms delay, this waits!\n    console.log(\"Callback\");\n}, 0);\n\nconsole.log(\"End\");\n</code></pre> <p>Execution Flow:</p> <ol> <li>\"Start\" is logged.</li> <li><code>setTimeout</code> registers the callback and starts a timer (effectively 0ms).</li> <li>The main code continues. \"End\" is logged.</li> <li>The timer immediately expires (or very close to it), and the callback is moved to the Callback Queue.</li> <li>The synchronous code finishes, and the Global Execution Context is popped from the Call Stack.</li> <li>The Call Stack is now empty.</li> <li>The Event Loop moves the callback from the queue to the stack.</li> <li>\"Callback\" is logged.</li> </ol> Expected Outcome<pre><code>Start\nEnd\nCallback\n</code></pre> <p>So, <code>setTimeout(0)</code> is a useful trick to defer the execution of a function until the Call Stack is clear. It essentially says, \"Run this function as soon as possible, but after the current synchronous code finishes.\"</p> <p>Understanding the JRE, the engine, the call stack, and the event loop is crucial for writing efficient and predictable JavaScript, especially when dealing with asynchronous operations!</p>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/","title":"<code>let</code>, <code>const</code>, and the Temporal Dead Zone (TDZ)","text":"<p>We\u2019ll explore</p> <ol> <li>Why can we access <code>var</code> variables before declaration, but not <code>let</code> or <code>const</code>?</li> <li>Are <code>let</code> and <code>const</code> declarations hoisted?</li> <li>What exactly is the Temporal Dead Zone (TDZ)?</li> <li>What's the difference between SyntaxError, ReferenceError, and TypeError in this context?</li> </ol>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#are-let-and-const-declarations-hoisted","title":"Are <code>let</code> and <code>const</code> declarations hoisted?","text":"<p>Yes, they absolutely are! \ud83d\udc4d\ud83c\udffc</p> <p>However, they are hoisted differently than <code>var</code> declarations. While <code>var</code> variables are hoisted and initialized with <code>undefined</code> in the global or function scope, <code>let</code> and <code>const</code> are hoisted but remain uninitialized. They are placed in a different memory space, separate from the global object.</p> <p>This leads to a concept called the Temporal Dead Zone (TDZ).</p> <p>Let's compare:</p> index.js<pre><code>// Using var\nconsole.log(b); // Output: undefined\nvar b = 100;\n\n// Using let\nconsole.log(a); // Throws ReferenceError!\nlet a = 10;\n</code></pre> <p>With <code>var b = 100;</code>, memory is allocated for <code>b</code> and it's initialized to <code>undefined</code> before execution. So, <code>console.log(b)</code> works, even though it appears before the declaration line.</p> <p>But with <code>let a = 10;</code>, trying to access <code>a</code> before the <code>let a = 10;</code> line results in an error. Why? Because <code>a</code> is in the Temporal Dead Zone.</p>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#what-is-the-temporal-dead-zone-tdz","title":"What is the Temporal Dead Zone (TDZ)?","text":"<p>The Temporal Dead Zone is the period from the start of the scope until the <code>let</code> or <code>const</code> variable is declared and initialized.</p> <p>During this period:</p> <ol> <li>The variable has been hoisted (memory space is reserved).</li> <li>The variable is not initialized.</li> <li>Attempting to access the variable results in a <code>ReferenceError</code>.</li> </ol> index.js<pre><code>// Start of TDZ for 'a'\nconsole.log(a); // ReferenceError: Cannot access 'a' before initialization\n\nlet a = 10;     // End of TDZ for 'a'\nconsole.log(a); // Output: 10\n\nvar b = 100;\n</code></pre> <p>The TDZ exists to prevent bugs that can occur when accessing variables before they are explicitly assigned a value.</p> <p>Can we access <code>let</code>/<code>const</code> via window?</p> <p>Since <code>let</code> and <code>const</code> variables are not added to the global <code>window</code> object (unlike <code>var</code> declared in the global scope), you cannot access them using <code>window.variableName</code> or <code>this.variableName</code> (in the global context).</p> index.js<pre><code>let a = 10;\nvar b = 20;\n</code></pre> Console Output (Browser)<pre><code>&gt; window.a\n&lt; undefined\n\n&gt; window.b\n&lt; 20\n\n&gt; this.a\n&lt; undefined\n\n&gt; this.b\n&lt; 20\n</code></pre> <p>This demonstrates that <code>let</code> and <code>const</code> provide better scope encapsulation compared to <code>var</code>.</p>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#visualizing-hoisting-and-tdz","title":"Visualizing Hoisting and TDZ","text":"<p>Using browser developer tools helps visualize this:</p> <p></p> <p>Notice how <code>a</code> (declared with <code>let</code>) is listed under <code>Script</code> scope and shows <code>&lt;value unavailable&gt;</code>, indicating it's in the TDZ at that point. In contrast, <code>b</code> (declared with <code>var</code>) is directly attached to the <code>Global</code> object (or <code>Window</code>) and initialized with <code>undefined</code>.</p>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#redeclaring-variables","title":"\u274c Redeclaring Variables","text":""},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#let","title":"<code>let</code>","text":"<p>You cannot redeclare a <code>let</code> variable within the same scope.</p> index.js<pre><code>let a = 10;\nlet a = 100; // Error!\n</code></pre> Console output<pre><code>Uncaught SyntaxError: Identifier 'a' has already been declared\n</code></pre> <p>This also applies if you try to redeclare a <code>let</code> variable using <code>var</code>:</p> index.js<pre><code>let a = 10;\nvar a = 100; // Error!\n</code></pre> Console output<pre><code>Uncaught SyntaxError: Identifier 'a' has already been declared\n</code></pre> <p>A <code>SyntaxError</code> occurs because the code itself is grammatically incorrect according to JavaScript rules. The engine detects this before execution even begins.</p>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#var","title":"<code>var</code>","text":"<p>You can redeclare a <code>var</code> variable within the same scope without errors.</p> index.js<pre><code>var x = 10;\nconsole.log(x); // Output: 10\nvar x = 100;\nconsole.log(x); // Output: 100\n</code></pre>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#const","title":"<code>const</code>","text":"<p>Similar to <code>let</code>, you cannot redeclare a <code>const</code> variable within the same scope.</p> index.js<pre><code>const b = 100;\nconst b = 1000; // Error!\n</code></pre> Console output<pre><code>Uncaught SyntaxError: Identifier 'b' has already been declared\n</code></pre>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#const-initialization-and-re-assignment","title":"\u2728 <code>const</code> Initialization and Re-assignment","text":""},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#initialization","title":"Initialization","text":"<p><code>const</code> declarations must be initialized with a value on the same line.</p> index.js<pre><code>let a;   // OK - initialized with undefined implicitly\nvar c;   // OK - initialized with undefined implicitly\nconst b; // Error!\n\na = 10;\nb = 100;\nc = 1000;\n</code></pre> Console output<pre><code>Uncaught SyntaxError: Missing initializer in const declaration\n</code></pre>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#re-assignment","title":"\ud83d\udd12 Re-assignment","text":"<p>You cannot re-assign a new value to a <code>const</code> variable after it has been initialized.</p> index.js<pre><code>let a = 10;\nconst b = 100;\n\na = 20; // OK\nb = 200; // Error!\n</code></pre> Console output<pre><code>Uncaught TypeError: Assignment to constant variable.\n</code></pre> <p>A <code>TypeError</code> occurs when an operation is performed on a value of an inappropriate type, like trying to re-assign a constant. This error happens during runtime when the invalid assignment is attempted.</p> <p>Which Declaration Should You Use?</p> <ol> <li><code>const</code> by default: Use <code>const</code> whenever you declare a variable whose value should not be reassigned after initialization. This makes your code more predictable.</li> <li><code>let</code> when reassignment is needed: Use <code>let</code> if you know the variable's value will need to change during its lifetime (e.g., loop counters, state variables).</li> <li>Avoid <code>var</code>: Generally, avoid using <code>var</code> in modern JavaScript due to its looser scoping rules and hoisting behavior, which can lead to unexpected bugs. <code>let</code> and <code>const</code> provide block scope and the TDZ, leading to safer code.</li> </ol>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#how-to-avoid-tdz-errors","title":"\ud83d\udee1\ufe0f How to Avoid TDZ Errors","text":"<p>The best way to avoid <code>ReferenceError</code> due to the TDZ is to always declare and initialize your <code>let</code> and <code>const</code> variables at the top of their scope before they are accessed.</p> Good Practice<pre><code>function exampleScope() {\n  // Declare and initialize at the top\n  let count = 0;\n  const MAX_RETRIES = 3;\n\n  // ... rest of the code that uses count and MAX_RETRIES\n  if (count &lt; MAX_RETRIES) {\n    // ...\n    count++;\n  }\n}\n</code></pre>"},{"location":"javascript/let-const-and-Temporal-Dead-Zone/#accessing-global-variables-from-block-scope","title":"\ud83d\udd17 Accessing Global Variables from Block Scope","text":"<p>If <code>let</code> and <code>const</code> aren't in the global scope, how can they access variables from the global scope?\"</p> index.js<pre><code>var x = 34; // Global scope\n\nfunction checkScope() {\n  // Function scope (inner scope)\n  let y = x; // Accessing global 'x' is fine!\n  console.log(y);\n}\n\ncheckScope();\n</code></pre> Console output<pre><code>34\n</code></pre> <p>Answer</p> <p>This works because of Lexical Scoping and the Scope Chain.</p> <ul> <li>Lexical Scoping: JavaScript determines the scope of variables based on where they are declared in the source code (lexically). Inner scopes automatically have access to variables declared in their outer scopes.</li> <li>Scope Chain: When JavaScript needs to find a variable, it first looks in the current scope. If it doesn't find it, it looks in the immediate outer scope, then the next outer scope, and so on, all the way up to the global scope.</li> </ul> <p>In the example above, when <code>let y = x;</code> is executed inside <code>checkScope</code>, JavaScript looks for <code>x</code> within <code>checkScope</code>. It doesn't find it, so it looks in the outer scope (the global scope), finds <code>var x = 34;</code>, and uses that value.</p>"},{"location":"javascript/loosely-typed-language/","title":"JavaScript: Loosely Typed Language","text":"<p>JavaScript is known as a loosely typed (or weakly typed) language. This means that variables in JavaScript are not bound to any specific data type. You can assign any type of value to a variable, and you can even change its type at any time during the program.</p>"},{"location":"javascript/loosely-typed-language/#loosely-typed-explained","title":"Loosely Typed Explained","text":"<p>In strictly typed languages (like C or C++), you must declare the type of a variable, and it can only store values of that type:</p> <pre><code>// C language example\nint a;\na = 10;        // \u2714 Valid\na = \"Hello\";   // \u2716 Error: Cannot assign string to int\n</code></pre> <p>In JavaScript, variables are flexible:</p> <pre><code>var a;\na = 10;           // a is now a number\na = \"Hello\";      // a is now a string\na = true;         // a is now a boolean\n</code></pre> <p>You can reassign different types of values to the same variable without any errors!</p>"},{"location":"javascript/loosely-typed-language/#example-changing-types-in-javascript","title":"Example: Changing Types in JavaScript","text":"<p>Here's a step-by-step example:</p> <pre><code>var a;\nconsole.log(\"Step 1, a =\", a); // undefined\n\na = 10;\nconsole.log(\"Step 2, a =\", a); // number\n\na = \"Hello World\";\nconsole.log(\"Step 3, a =\", a); // string\n</code></pre> Console Output<pre><code>Step 1, a =  undefined\nStep 2, a =  10\nStep 3, a =  Hello World\n</code></pre> <p>Key Takeaway</p> <ul> <li>Loosely typed means you don't need to declare variable types.</li> <li>Variables can change their type at runtime.</li> <li>This provides flexibility, but you need to be careful to avoid type-related bugs</li> </ul>"},{"location":"javascript/map-filter-reduce/","title":"Higher-Order Functions: Filter, Map, Reduce","text":"<p>JavaScript offers powerful built-in methods called higher-order functions that operate on arrays.</p> <p>What makes them \"higher-order\"?</p> <p>They take other functions as arguments, allowing you to write expressive and concise code for common data manipulation tasks. Let's dive into three of the most frequently used ones: <code>filter</code>, <code>map</code>, and <code>reduce</code>.</p> <p>Remember, <code>filter</code>, <code>map</code>, and <code>reduce</code> are all higher-order functions because they accept another function as an argument to perform their specific task.</p>"},{"location":"javascript/map-filter-reduce/#filter","title":"<code>filter</code>","text":"<p>Ever found yourself needing to sift through a list (an array) and pick out only the items that meet a specific criterion? Maybe you want only the even numbers, or only the users who are active. That's precisely what the <code>filter()</code> method is designed for!</p> <p><code>filter()</code> doesn't change your original array. Instead, it creates and returns a new array containing only the elements from the original array that pass the test you provide in your function.</p> <p>Example: Let's say we have an array of numbers and want a new array containing only numbers greater than 2.</p> <p><pre><code>const arr = [2, 5, 10, 15];\n\n// The function passed to filter() is called for each element (num).\n// It should return true to keep the element, or false to discard it.\nconst output = arr.filter((num) =&gt; num &gt; 2);\n\nconsole.log(output); // Output: [ 5, 10, 15 ]\nconsole.log(arr);    // Output: [ 2, 5, 10, 15 ] (Original array is untouched)\n</code></pre> See? The original <code>arr</code> remains unchanged. <code>filter</code> gives us a fresh array with just the elements we wanted.</p>"},{"location":"javascript/map-filter-reduce/#map","title":"<code>map</code>","text":"<p>What if you have an array, but you need to transform each item in that array into something else? Perhaps you have an array of user objects, but you only need an array of their email addresses. Or maybe you have a list of prices and need to apply a discount to each one. This is where <code>map()</code> shines.</p> <p>The <code>map()</code> method creates a new array by taking each element from the original array and applying a transformation function to it. The result of this function for each element becomes an item in the new array.</p> <p>Example: Given a list of user objects, let's create a new array containing just their full names.</p> <pre><code>const users = [\n    { firstname: 'John', lastname: 'Doe', age: 30 },\n    { firstname: 'Jane', lastname: 'Doe', age: 25 },\n    { firstname: 'Jim', lastname: 'Carrey', age: 50 },\n    { firstname: 'David', lastname: 'Doe', age: 30 }\n];\n\n// The function passed to map() defines how each 'user' object\n// is transformed into a string (their full name).\nconst fullNames = users.map((user) =&gt; {\n    let name = user.firstname + ' ' + user.lastname;\n    return name;\n});\n\nconsole.log(fullNames); // Output: [ 'John Doe', 'Jane Doe', 'Jim Carrey', 'David Doe' ]\nconsole.log(users);     // Original 'users' array remains unchanged.\n</code></pre> <p>Just like <code>filter</code>, <code>map</code> is non-destructive. It returns a brand new array reflecting the transformations.</p>"},{"location":"javascript/map-filter-reduce/#reduce","title":"<code>reduce</code>","text":"<p>Imagine you have a whole list of items, and your goal is to boil it all down to one single value. This could be:</p> <ul> <li>Finding the sum of all numbers in an array.</li> <li>Finding the maximum or minimum value.</li> <li>Counting occurrences of items.</li> <li>Grouping complex objects based on a property.</li> </ul> <p>This is the superpower of the <code>reduce()</code> method. It iterates through an array and accumulates a single result based on a function you provide.</p> <p>How it works:</p> <p>The <code>reduce()</code> method executes a \"reducer\" function on each element of the array.</p> <ul> <li>The Reducer Function: This function typically takes two main arguments:<ul> <li><code>accumulator</code> (<code>acc</code>): This is the value that gets carried over from one iteration to the next. It accumulates the result. Think of it as the \"result so far\".</li> <li><code>currentValue</code> (<code>curr</code>): This is the current element from the array being processed.</li> </ul> </li> <li>The Initial Value (Optional but Recommended): <code>reduce()</code> also takes a second argument, which is the initial value for the <code>accumulator</code>. If you omit this, the first element of the array becomes the initial accumulator, and iteration starts from the second element. Providing an initial value is often clearer and safer.</li> </ul> <p>Example 1: Summing Array Elements</p> <p>Let's find the sum of numbers in an array. The classic way involves a loop:</p> <pre><code>function findSum(arr) {\n    let sum = 0; // Initialize sum\n    for (let i = 0; i &lt; arr.length; i++) {\n        sum += arr[i]; // Accumulate in each step\n    }\n    return sum;\n}\n\nconst arr = [2, 5, 10, 15];\nconsole.log(findSum(arr)); // Output: 32\n</code></pre> <p>Now, let's achieve the same result elegantly using <code>reduce</code>:</p> <p><pre><code>const arr = [2, 5, 10, 15];\n\n// acc: accumulator (starts at 0)\n// curr: current value being processed\n// 0: initial value for the accumulator\nconst sum = arr.reduce((acc, curr) =&gt; {\n    // The return value of this function becomes the 'acc' for the next iteration\n    return acc + curr;\n}, 0); // Start the accumulator at 0\n\nconsole.log(\"Sum by Reduce:\", sum); // Output: Sum by Reduce: 32\n</code></pre> Much cleaner, right? The logic of \"accumulating\" is captured directly by <code>reduce</code>.</p> <p>Example 2: Grouping Data (Advanced Use Case)</p> <p><code>reduce</code> isn't limited to simple calculations. It's incredibly versatile for restructuring data. Let's tackle a common problem: counting how many users belong to each age group. We want an output object like <code>{ '25': 1, '30': 2, '50': 1 }</code>.</p> <p><pre><code>const users = [\n    { firstname: 'John', lastname: 'Doe', age: 30 },\n    { firstname: 'Jane', lastname: 'Doe', age: 25 },\n    { firstname: 'Jim', lastname: 'Carrey', age: 50 },\n    { firstname: 'David', lastname: 'Doe', age: 30 }\n];\n\n// Here, the initial value for the accumulator is an empty object {}\nconst ageGroupCount = users.reduce((acc, curr) =&gt; {\n    const age = curr.age; // Get the age of the current user\n\n    // Check if this age already exists as a key in our accumulator object\n    if (acc[age]) {\n        // If yes, increment its count\n        acc[age]++;\n    } else {\n        // If no, initialize the count for this new age to 1\n        acc[age] = 1;\n    }\n\n    // IMPORTANT: Always return the accumulator for the next iteration!\n    return acc;\n}, {}); // Start with an empty object {}\n\nconsole.log(ageGroupCount); // Output: { '25': 1, '30': 2, '50': 1 }\n</code></pre> In this case, the accumulator (<code>acc</code>) starts as <code>{}</code> and we progressively build this object during each iteration based on the <code>currentUser</code>.</p>"},{"location":"javascript/map-filter-reduce/#chaining-methods","title":"Chaining Methods","text":"<p>One of the most elegant aspects of <code>filter</code>, <code>map</code>, (and other array methods that return arrays) is that you can chain them together. Since <code>filter</code> returns a new array, you can immediately call <code>map</code> on that result, and so on. This allows for creating complex data transformation pipelines that remain highly readable.</p> <p>Problem: Get the first names of all users who are younger than 31.</p> <p>Solution using Chaining <code>filter</code> and <code>map</code>:</p> <ol> <li>Filter: First, select only the users whose <code>age</code> is less than 31.</li> <li>Map: Then, take the resulting array of younger users and transform it into an array containing only their <code>firstname</code>.</li> </ol> <p><pre><code>const users = [\n    { firstname: 'John', lastname: 'Doe', age: 30 },\n    { firstname: 'Jane', lastname: 'Doe', age: 25 },\n    { firstname: 'Jim', lastname: 'Carrey', age: 50 },\n    { firstname: 'David', lastname: 'Doe', age: 30 }\n];\n\n// Chain filter() and map() together\nconst youngUserFirstNames = users\n    .filter((user) =&gt; user.age &lt; 31) // Step 1: Returns an array of users younger than 31\n    .map(user =&gt; user.firstname);    // Step 2: Maps that array to an array of first names\n\nconsole.log(youngUserFirstNames); // Output: [ 'John', 'Jane', 'David' ]\n</code></pre> This reads almost like plain English: \"Take users, filter by age less than 31, then map to first name.\"</p> <p>Alternative using only <code>reduce</code>:</p> <p>While chaining is often clearer for sequential filtering and mapping, you can achieve the same result using only <code>reduce</code>. This demonstrates its flexibility, though it might be slightly less intuitive for this specific problem compared to the chain.</p> <pre><code>const users = [\n    { firstname: 'John', lastname: 'Doe', age: 30 },\n    { firstname: 'Jane', lastname: 'Doe', age: 25 },\n    { firstname: 'Jim', lastname: 'Carrey', age: 50 },\n    { firstname: 'David', lastname: 'Doe', age: 30 }\n];\n\nconst youngUsersAgain = users.reduce((acc, currentUser) =&gt; {\n    // Check the condition directly within the reducer\n    if (currentUser.age &lt; 31) {\n        // If the user is young enough, push their firstname onto the accumulator array\n        acc.push(currentUser.firstname);\n    }\n    // Return the accumulator (our growing list of names) for the next iteration\n    return acc;\n}, []); // Start with an empty array [] as the initial accumulator\n\nconsole.log(youngUsersAgain); // Output: [ 'John', 'Jane', 'David' ]\n</code></pre> <p>Mastering <code>filter</code>, <code>map</code>, and <code>reduce</code> unlocks a more functional and expressive way to work with arrays in JavaScript, often leading to cleaner and more maintainable code.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/","title":"Promise APIs","text":"<p>Ever scrambled to manage several asynchronous tasks in JavaScript\u2014like fetching data from different APIs all at once? JavaScript\u2019s Promise APIs give you powerful tools to coordinate these operations, regardless of whether you\u2019re waiting for everything, just need the first result, or want to know every outcome.</p> <p>The four key APIs we\u2019ll explore are:</p> <ol> <li><code>Promise.all()</code></li> <li><code>Promise.allSettled()</code></li> <li><code>Promise.race()</code></li> <li><code>Promise.any()</code></li> </ol> <p>Each is suited for common, real-world async scenarios. Let\u2019s see how they solve our toughest concurrency problems.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#promiseall-wait-until-everything-succeeds","title":"<code>Promise.all()</code>: Wait Until Everything Succeeds","text":"<p>Problem: You need to fetch data for multiple users and only want to act when all calls finish successfully.</p> <p>Solution: Use <code>Promise.all()</code>.</p> <ul> <li>Input: An array (or iterable) of promises.</li> <li>Behavior: Waits for all promises to resolve.<ul> <li>If all succeed: Resolves with an array containing the results of each promise, in the same order they were passed in.</li> <li>If any fail: Rejects immediately with that first error (others keep running, but their results are ignored). It doesn't wait for the others; it \"fails fast.\"</li> </ul> </li> <li>Use this when: Every task is critical before you can move on.</li> </ul>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiseall-handles-success","title":"How <code>Promise.all()</code> Handles Success","text":"<p>Let's say we have three promises: P1 (takes 3s), P2 (takes 1s), and P3 (takes 2s). All of them will eventually resolve successfully.</p> <p></p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#what-happens-when-a-promise-fails-in-promiseall","title":"What Happens When a Promise Fails in <code>Promise.all()</code>?","text":"<p>Now, what if one of those promises rejects? Let's use the same timings (P1: 3s, P2: 1s, P3: 2s), but this time, P2 rejects after 1 second.</p> <p></p> <p>Important Note</p> <p>Even though <code>Promise.all()</code> rejects early, the other promises (P1 and P3 in this case) will continue running until they complete. You just won't get their results via this <code>Promise.all()</code> call. JavaScript doesn't provide a standard way to cancel a promise once it's started.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#promiseallsettled-getting-all-outcomes","title":"<code>Promise.allSettled()</code>: Getting All Outcomes","text":"<p>Problem: What if you want to run multiple independent tasks and need a result for every one, whether it succeeded or failed?</p> <p>Solution: Try <code>Promise.allSettled()</code>.</p> <ul> <li>Input: An array (or iterable) of promises.</li> <li>Behavior: Waits for all promises to settle (resolve or reject).</li> <li>Output: Resolves with an array of objects:<ul> <li>For fulfilled promises: <code>{ status: \"fulfilled\", value: &lt;resolved_value&gt; }</code></li> <li>For rejected promises: <code>{ status: \"rejected\", reason: &lt;rejection_reason&gt; }</code></li> </ul> </li> <li>Use Case: Ideal when you need to perform several independent tasks and want to know the result of each one, regardless of individual successes or failures.</li> </ul>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiseallsettled-handles-failure","title":"How <code>Promise.allSettled()</code> Handles Failure","text":"<p>Now, let's say P2 (1s) rejects, while P1 (3s) and P3 (2s) resolve.</p> <p></p> <p>Key Difference</p> <p><code>Promise.all()</code> is \"fail-fast,\" while <code>Promise.allSettled()</code> waits for all results, success or failure.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#promiserace-the-fastest-result-wins","title":"<code>Promise.race()</code>: The Fastest Result Wins","text":"<p>Problem: You have several possible data sources (like redundant servers) and want whichever responds first, no matter which.</p> <p>Solution: Use <code>Promise.race()</code>!</p> <ul> <li>Input: An array (or iterable) of promises.</li> <li>Behavior: Resolves or rejects as soon as any promise settles.<ul> <li>If the first to settle resolves, so does <code>Promise.race()</code>.</li> <li>If the first to settle rejects, so does <code>Promise.race()</code>.</li> </ul> </li> <li>Use this when: You only care about the fastest result, regardless of success or failure.</li> </ul>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiserace-handles-success","title":"How <code>Promise.race()</code> Handles Success","text":"<p>Consider P1 (3s), P2 (1s), and P3 (2s), all resolving successfully.</p> <p></p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiserace-handles-failure","title":"How <code>Promise.race()</code> Handles Failure","text":"<p>What if the fastest promise rejects? Let's use P1 (3s, resolves), P2 (1s, rejects), P3 (2s, resolves).</p> <p></p> <p>In Short</p> <p><code>Promise.race()</code> mirrors the outcome of the very first promise to finish, regardless of whether it's a success or failure.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#promiseany-first-success-ignoring-failures","title":"<code>Promise.any()</code>: First Success (Ignoring Failures)","text":"<p>Problem: You only want the first successful result\u2014even if some tasks fail. Only fail if all options do.</p> <p>Solution: Choose <code>Promise.any()</code>.</p> <ul> <li>Input: An array (or iterable) of promises.</li> <li>Behavior: Waits for the first promise to fulfill.<ul> <li>Resolves with that result.</li> <li>Ignores all rejections unless every promise rejects.</li> </ul> </li> <li>On total failure: Rejects with an <code>AggregateError</code> (containing all rejection reasons).</li> <li>Use this when: You want any success, such as fallback or backup requests.</li> </ul> <p>It's a success seeking race.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiseany-handles-success","title":"How <code>Promise.any()</code> Handles Success","text":"<p>Let's use P1 (3s, resolves), P2 (1s, resolves), P3 (2s, resolves).</p> <p></p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiseany-handles-partial-failure","title":"How <code>Promise.any()</code> Handles Partial Failure","text":"<p>Now, what if the fastest promise fails? P1 (3s, resolves), P2 (1s, rejects), P3 (2s, resolves).</p> <p></p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#how-promiseany-handles-total-failure","title":"How <code>Promise.any()</code> Handles Total Failure","text":"<p>What if all promises reject? P1 (3s, rejects), P2 (1s, rejects), P3 (2s, rejects).</p> <p></p> <p>Key Distinction</p> <p><code>Promise.race()</code> settles with the first settled promise (success or failure). <code>Promise.any()</code> settles with the first fulfilled (successful) promise, only rejecting if all promises reject.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#code-examples-promiseall","title":"Code Examples: <code>Promise.all()</code>","text":"<p>Let's see <code>Promise.all()</code> in action. We'll create three promises with different resolution times.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#case-1-all-promises-resolve-successfully","title":"Case 1: All Promises Resolve Successfully","text":"<pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 1');\n    }, 3000); // Resolves after 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 2');\n    }, 1000); // Resolves after 1 second\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 3');\n    }, 2000); // Resolves after 2 seconds\n});\n\n\nPromise.all([promise1, promise2, promise3])\n    .then(function (values) {\n        // This runs only after ALL promises resolve (at ~3 seconds)\n        console.log(values);\n    })\n    .catch(function (err) {\n        // This won't run in this case\n        console.error(\"Promise.all rejected:\", err);\n    });\n</code></pre> Expected Console Output<pre><code>[ 'Value 1', 'Value 2', 'Value 3' ]\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#case-2-one-promise-rejects-fail-fast","title":"Case 2: One Promise Rejects (Fail-Fast)","text":"<p>Now, let's make <code>promise2</code> reject.</p> <pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error from Promise 2'); // Rejects!\n    }, 1000); // 1 second\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 3');\n    }, 2000); // 2 seconds\n});\n\nPromise.all([promise1, promise2, promise3])\n    .then(function (values) {\n        // This won't run\n        console.log(values);\n    })\n    .catch(function (err) {\n        // This runs as soon as promise2 rejects (at ~1 second)\n        console.error(\"Promise.all rejected:\", err);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.all rejected: Error from Promise 2\n</code></pre> <p>Important Note</p> <p>Always add a <code>.catch()</code> block when using <code>Promise.all()</code> to handle potential rejections gracefully. Relying on uncaught error handlers in the browser is not recommended.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#code-examples-promiseallsettled","title":"Code Examples: <code>Promise.allSettled()</code>","text":"<p>Let's use the same scenario where <code>promise2</code> rejects, but this time with <code>Promise.allSettled()</code>.</p> <pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error from Promise 2'); // Rejects!\n    }, 1000); // 1 second\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 3');\n    }, 2000); // 2 seconds\n});\n\nPromise.allSettled([promise1, promise2, promise3])\n    .then(function (results) {\n        // This runs only after ALL promises settle (at ~3 seconds)\n        console.log(JSON.stringify(results, null, 2)); // Pretty print the results\n    })\n    .catch(function (err) {\n        // This generally won't run unless there's an issue with the input itself\n        console.error(\"Promise.allSettled somehow failed:\", err);\n    });\n</code></pre> Expected Console Output<pre><code>[\n  { \"status\": \"fulfilled\", \"value\": \"Value 1\"},\n  { \"status\": \"rejected\", \"reason\": \"Error from Promise 2\"},\n  { \"status\": \"fulfilled\", \"value\": \"Value 3\"}\n]\n</code></pre> <p>Notice how <code>Promise.allSettled()</code> waited for all promises to complete and gave us a detailed report of each outcome.\"</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#code-examples-promiserace","title":"Code Examples: <code>Promise.race()</code>","text":"<p>Let's see who wins the race!</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#example-1-fastest-promise-succeeds","title":"Example 1: Fastest Promise Succeeds","text":"<p>P2 (1s) is the fastest and resolves successfully.</p> <pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 2'); // Resolves first!\n    }, 1000); // 1 second\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 3');\n    }, 2000); // 2 seconds\n});\n\nPromise.race([promise1, promise2, promise3])\n    .then(function (winnerValue) {\n        // This runs as soon as promise2 resolves (at ~1 second)\n        console.log(\"Promise.race winner (resolved):\", winnerValue);\n    })\n    .catch(function (winnerError) {\n        // This won't run\n        console.error(\"Promise.race winner (rejected):\", winnerError);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.race winner (resolved): Value 2\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#example-2-fastest-promise-rejects","title":"Example 2: Fastest Promise Rejects","text":"<p>P3 (2s) is the fastest, but it rejects.</p> <pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('P1 successfully resolved');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('P2 successfully resolved');\n    }, 5000); // 5 seconds\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('P3 failed'); // Rejects first!\n    }, 2000); // 2 seconds\n});\n\nPromise.race([promise1, promise2, promise3])\n    .then(function (winnerValue) {\n        // This won't run\n        console.log(\"Promise.race winner (resolved):\", winnerValue);\n    })\n    .catch(function (winnerError) {\n        // This runs as soon as promise3 rejects (at ~2 seconds)\n        console.error(\"Promise.race winner (rejected):\", winnerError);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.race winner (rejected): P3 failed\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#code-examples-promiseany","title":"Code Examples: <code>Promise.any()</code>","text":"<p>Let's see how <code>Promise.any()</code> seeks the first success.</p>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#example-1-first-success-wins-ignoring-earlier-failure","title":"Example 1: First Success Wins (Ignoring Earlier Failure)","text":"<p>P2 rejects quickly (1s), but P3 resolves successfully later (2s). <code>Promise.any()</code> should give us P3's result.</p> promise-any.js<pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error from P2'); // Rejects first!\n    }, 1000); // 1 second\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 3'); // Resolves successfully after P2 fails\n    }, 2000); // 2 seconds\n});\n\nPromise.any([promise1, promise2, promise3])\n    .then(function (firstSuccessValue) {\n        // This runs when P3 resolves (at ~2 seconds)\n        console.log(\"Promise.any first success:\", firstSuccessValue);\n    })\n    .catch(function (aggregateError) {\n        // This won't run\n        console.error(\"Promise.any failed:\", aggregateError);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.any first success: Value 3\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#example-2-waiting-for-the-only-success","title":"Example 2: Waiting for the Only Success","text":"<p>P3 fails first (2s), P1 fails next (3s), but P2 eventually succeeds (5s).</p> promise-any.js<pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error from P1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('Value 2'); // The only success, takes the longest\n    }, 5000); // 5 seconds\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error from P3'); // Rejects first\n    }, 2000); // 2 seconds\n});\n\nPromise.any([promise1, promise2, promise3])\n    .then(function (firstSuccessValue) {\n        // This runs when P2 resolves (at ~5 seconds)\n        console.log(\"Promise.any first success:\", firstSuccessValue);\n    })\n    .catch(function (aggregateError) {\n        // This won't run\n        console.error(\"Promise.any failed:\", aggregateError);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.any first success: Value 2\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#example-3-all-promises-fail","title":"Example 3: All Promises Fail","text":"<p>If every promise rejects, <code>Promise.any()</code> rejects with an <code>AggregateError</code>.</p> <pre><code>const promise1 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error P1');\n    }, 3000); // 3 seconds\n});\n\nconst promise2 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error P2');\n    }, 5000); // 5 seconds (last one to fail)\n});\n\nconst promise3 = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        reject('Error P3');\n    }, 2000); // 2 seconds\n});\n\nPromise.any([promise1, promise2, promise3])\n    .then(function (firstSuccessValue) {\n        // This won't run\n        console.log(\"Promise.any first success:\", firstSuccessValue);\n    })\n    .catch(function (aggregateError) {\n        // This runs when the last promise (P2) rejects (at ~5 seconds)\n        console.error(\"Promise.any failed as all promises rejected.\");\n        console.error(\"Aggregate Error:\", aggregateError);\n        // You can inspect the individual errors\n        console.error(\"Individual errors:\", aggregateError.errors);\n    });\n</code></pre> Expected Console Output<pre><code>Promise.any failed as all promises rejected.\nAggregate Error: [AggregateError: All promises were rejected] {\n  [errors]: [ 'Error P1', 'Error P2', 'Error P3' ]\n}\nIndividual errors: [ 'Error P1', 'Error P2', 'Error P3' ]\n</code></pre>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#handling-aggregate-errors-in-promiseany","title":"Handling Aggregate Errors in <code>Promise.any()</code>","text":"<p>When <code>Promise.any()</code> rejects because all input promises failed, the error object it provides is an <code>AggregateError</code>. This object has a useful property: <code>errors</code>.</p> <ul> <li><code>aggregateError.errors</code>: This is an array containing the rejection reason from each of the promises that failed, in the order they were originally passed to <code>Promise.any()</code>.</li> </ul>"},{"location":"javascript/promise-apis-all-allsettled-race-any/#key-terms-concepts","title":"Key Terms &amp; Concepts","text":"<ul> <li>Pending: The initial state; the promise is neither fulfilled nor rejected.</li> <li>Fulfilled (or Resolved): The asynchronous operation completed successfully. The promise now has a resulting value. This is a final state.</li> <li>Rejected: The asynchronous operation failed. The promise now has a reason (usually an error object) for the failure. This is also a final state.</li> <li> <p>Settled: The promise is no longer pending; it has either been fulfilled or rejected. It has reached its final state.</p> <p></p> </li> </ul> <p>Think of it like this:</p> <ul> <li>A promise settles when it's done.</li> <li>Settling can result in fulfillment (success) or rejection (failure).</li> <li><code>resolve()</code> is the function you call to move a promise to the fulfilled state.</li> <li><code>reject()</code> is the function you call to move a promise to the rejected state.</li> </ul>"},{"location":"javascript/promises-async-await/","title":"Promises, Async, and Await","text":"<p>Mastering asynchronous JavaScript can be tricky. This guide walks you through the problems callbacks introduce, how Promises help, and why <code>async</code>/<code>await</code> makes your code cleaner and more readable.</p>"},{"location":"javascript/promises-async-await/#what-is-async-in-javascript","title":"What Is <code>async</code> in JavaScript?","text":"<p>Problem: You want a function that always returns a Promise.</p> <p>Solution: Prefix it with <code>async</code>.</p> <ul> <li>An <code>async</code> function always returns a Promise.</li> <li>If you return a non-Promise value, JavaScript wraps it in a resolved Promise.</li> </ul> <pre><code>async function getData() {\n  return \"Hello World\";  // Returns Promise.resolve(\"Hello World\")\n}\n\nconst dataPromise = getData();\nconsole.log(dataPromise); // Promise {&lt;fulfilled&gt;: \"Hello World\"}\ndataPromise.then(res =&gt; console.log(res)); // Hello World\n</code></pre> <p>If you return a Promise explicitly, it stays as is:</p> <pre><code>const p = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Delayed\"), 2000));\n\nasync function getData() {\n  return p; // returns p unwrapped\n}\n\ngetData().then(console.log); // after 2s logs \"Delayed\"\n</code></pre>"},{"location":"javascript/promises-async-await/#handling-promises-then-vs-await","title":"Handling Promises: <code>.then()</code> vs <code>await</code>","text":""},{"location":"javascript/promises-async-await/#1-using-then-old-way","title":"1. Using <code>.then()</code> (Old Way)","text":"Using .then()<pre><code>const p = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(\"Hello\"), 2000));\n\nfunction getData() {\n  p.then(res =&gt; console.log(res));\n  console.log(\"Runs before promise resolves\");\n}\n\ngetData();\n</code></pre> Console Output<pre><code>Runs before promise resolves\nHello\n</code></pre>"},{"location":"javascript/promises-async-await/#2-using-asyncawait","title":"2. Using <code>async</code>/<code>await</code>","text":"Using async/await<pre><code>async function getData() {\n  console.log(\"Waiting for promise...\");\n  const res = await p;          // pauses here\n  console.log(res);\n  console.log(\"After await\");\n}\n\ngetData();\n</code></pre> Console Output<pre><code>Waiting for promise...\nHello\nAfter await\n</code></pre>"},{"location":"javascript/promises-async-await/#behind-the-scenes-of-await","title":"Behind the Scenes of <code>await</code>","text":"<p>When you <code>await</code> a Promise:</p> <ol> <li>The async function is suspended at that point.</li> <li>It\u2019s removed from the call stack (the main thread is free).</li> <li>When the Promise resolves, the function resumes where it left off.</li> </ol> <p>This prevents blocking the UI and keeps your app responsive.</p>"},{"location":"javascript/promises-async-await/#real-world-example-fetch","title":"Real-World Example: <code>fetch</code>","text":"<p>Problem: You need to fetch JSON data from an API.</p> <pre><code>const API_URL = \"https://api.github.com/users/yourusername\";\n\nasync function fetchUser() {\n  try {\n    const response  = await fetch(API_URL);      // 1. fetch() returns a Promise\n    const jsonValue = await response.json();      // 2. response.json() returns a Promise\n    console.log(jsonValue);\n  } catch (err) {\n    console.error(\"Error fetching user:\", err);\n  }\n}\n\nfetchUser();\n</code></pre> <p>Key Points:</p> <ul> <li> Both <code>fetch()</code> and <code>response.json()</code> return Promises.</li> <li> <code>await</code> pauses only the async function, not the entire JavaScript engine.</li> <li> Use <code>try/catch</code> to handle network or parsing errors.</li> </ul>"},{"location":"javascript/promises-async-await/#error-handling","title":"Error Handling","text":""},{"location":"javascript/promises-async-await/#1-trycatch-inside-an-async-function","title":"1. <code>try\u2026catch</code> inside an async function","text":"<pre><code>async function safeFetch(url) {\n  try {\n    const res  = await fetch(url);\n    const data = await res.json();\n    return data;\n  } catch (err) {\n    console.error(\"Fetch error:\", err);\n  }\n}\n</code></pre>"},{"location":"javascript/promises-async-await/#2-catch-on-the-returned-promise","title":"2. <code>.catch()</code> on the returned Promise","text":"<pre><code>async function badFetch() {\n  const res = await fetch(\"https://invalid.url\");\n  return res.json();\n}\n\nbadFetch().catch(err =&gt; console.error(\"Caught:\", err));\n</code></pre>"},{"location":"javascript/promises-async-await/#quick-interview-tips","title":"Quick Interview Tips","text":"<p>What is <code>async</code>?</p> <p>Marks a function to always return a Promise.</p> <p>What is <code>await</code>?</p> <p>Pauses an async function until a Promise settles.</p> <p>Why use async/await?</p> <p>Cleaner syntax, easier error handling.</p> <p>When not to use it?</p> <p>For small one-off Promises or in environments without ES2017 support.</p>"},{"location":"javascript/promises-async-await/#asyncawait-vs-thencatch","title":"<code>async</code>/<code>await</code> vs <code>.then()</code>/<code>.catch()</code>","text":"<ul> <li> <p>Syntax &amp; Readability</p> <ul> <li><code>.then()</code>: chaining callbacks, can become nested</li> <li><code>async/await</code>: flat, \u201ctop-to-bottom\u201d flow</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li><code>.catch()</code>: single or per-chain handlers</li> <li><code>try\u2026catch</code>: group multiple awaits or isolate individual calls</li> </ul> </li> <li> <p>Sequential vs. Parallel</p> <ul> <li>Sequential by default in both (<code>await a; await b;</code>)</li> <li>Parallel with <code>Promise.all([\u2026, \u2026])</code></li> </ul> </li> <li> <p>Debugging &amp; Stack Traces</p> <ul> <li><code>.then()</code>: anonymous callbacks in traces</li> <li><code>async/await</code>: resembles sync code, easier breakpoints</li> </ul> </li> <li> <p>When to Use</p> <ul> <li><code>async/await</code>: multiple dependent steps, cleaner logic, modern codebases</li> <li><code>.then()/.catch()</code>: simple one-off Promises, existing promise-only libraries</li> </ul> </li> </ul> <p>Both patterns run on Promises; choose based on readability, error-handling style, and project needs. <code>async/await</code> is purely syntactic sugar.</p>"},{"location":"javascript/promises/","title":"Promises in JavaScript","text":"<p>Promises offer a cleaner, more reliable way to handle asynchronous operations in JavaScript compared to traditional callbacks. Let's explore how they work and why they're beneficial.</p>"},{"location":"javascript/promises/#the-problem-handling-asynchronous-operations","title":"The Problem: Handling Asynchronous Operations","text":"<p>Imagine you're building an e-commerce feature. You need to perform a sequence of actions:</p> <ol> <li>Create an order based on the items in the cart.</li> <li>Proceed to payment using the Order ID obtained from step 1.</li> </ol> <p>Both <code>createOrder(cart)</code> and <code>proceedToPayment(orderId)</code> are asynchronous operations \u2013 they take some time to complete, and we don't know exactly how long. Crucially, <code>proceedToPayment</code> depends on <code>createOrder</code> finishing first.</p>"},{"location":"javascript/promises/#the-old-way-callbacks","title":"The Old Way: Callbacks","text":"<p>Before Promises, we often used callback functions. You'd pass the next step (<code>proceedToPayment</code>) as a function into the first step (<code>createOrder</code>).</p> <pre><code>const cart = [ \"item1\", \"item2\", \"item3\" ];\n\n// Define the functions (simplified)\nfunction createOrder(cart, callback) {\n  console.log(\"Creating order...\");\n  // Simulate async operation\n  setTimeout(() =&gt; {\n    const orderId = \"12345\";\n    // Call the callback function *after* order is created\n    callback(orderId);\n  }, 1000);\n}\n\nfunction proceedToPayment(orderId) {\n  console.log(\"Proceeding to payment for order:\", orderId);\n  // Simulate async payment\n  setTimeout(() =&gt; {\n    console.log(\"Payment successful for order:\", orderId);\n  }, 500);\n}\n\n// Using the callback approach\ncreateOrder(cart, function(orderId) { // Pass proceedToPayment (wrapped in an anonymous function) as a callback\n  proceedToPayment(orderId);\n});\n</code></pre> <p>The Problem with Callbacks: Inversion of Control</p> <p>When you pass a callback function (<code>proceedToPayment</code>) to another function (<code>createOrder</code>), you're giving up control. You trust that <code>createOrder</code> will:</p> <ol> <li>Call your callback function correctly.</li> <li>Call it only once.</li> <li>Call it with the correct data (<code>orderId</code>).</li> </ol> <p>What if the <code>createOrder</code> function (perhaps written by someone else or part of a library) has a bug? It might never call your callback, or it might call it multiple times. This loss of control is called Inversion of Control, and it makes code harder to reason about and debug.</p>"},{"location":"javascript/promises/#the-solution-promises","title":"The Solution: Promises","text":"<p>Promises provide a way to manage asynchronous operations without giving up control.</p> <p>Instead of passing a callback into the asynchronous function, the function returns a special object called a Promise.</p> <p>What is a Promise?</p> <p>Think of a Promise as a placeholder for a future value. It represents the eventual result of an asynchronous operation. Initially, this result is unknown.</p> <p>Let's rewrite <code>createOrder</code> to return a Promise:</p> <pre><code>function createOrderPromise(cart) {\n  // Return a new Promise\n  const promise = new Promise(function(resolve, reject) {\n    // Basic validation\n    if (!cart || cart.length === 0) {\n      const err = new Error(\"Cart is empty\");\n      reject(err); // Reject the promise if validation fails\n      return;\n    }\n\n    // Simulate async operation\n    setTimeout(() =&gt; {\n      const orderId = \"12345\";\n      console.log(\"Order created (Promise):\", orderId);\n      // If successful, resolve the promise with the result\n      resolve(orderId);\n    }, 1000);\n  });\n  return promise; // Return the promise object immediately\n}\n</code></pre> <p>Now, when you call <code>createOrderPromise(cart)</code>, it doesn't take a callback. Instead, it immediately returns a <code>promise</code> object.</p> <pre><code>const cart = [ \"item1\", \"item2\", \"item3\" ];\nconst orderPromise = createOrderPromise(cart); // Returns a Promise object right away\n\nconsole.log(orderPromise); // Initially, this will likely show a Promise in a \"pending\" state\n</code></pre> <p>This <code>orderPromise</code> object acts as that placeholder. At first, it's like an empty box: <code>{ data: undefined }</code> (conceptually). The asynchronous <code>createOrderPromise</code> operation runs in the background. When it eventually finishes successfully, it fills the box with the result (the <code>orderId</code>) using the <code>resolve</code> function. If it fails, it uses the <code>reject</code> function.</p> <p></p> <p></p> <p></p>"},{"location":"javascript/promises/#using-then-to-attach-callbacks","title":"Using <code>.then()</code> to Attach Callbacks","text":"<p>So, how do we run <code>proceedToPayment</code> after the <code>orderPromise</code> is filled (resolved)? We attach our callback function to the promise using the <code>.then()</code> method.</p> <pre><code>const cart = [ \"item1\", \"item2\", \"item3\" ];\n\n// Assume createOrderPromise and proceedToPayment are defined as above\n\nconst orderPromise = createOrderPromise(cart);\n\n// Attach a function to run *when* the promise resolves successfully\norderPromise.then(function(orderId) {\n  // This function only runs *after* createOrderPromise resolves\n  // and it receives the resolved value (orderId)\n  proceedToPayment(orderId);\n});\n</code></pre> <p>Key Difference:</p> <ul> <li>Callbacks: You pass your function into the async function (<code>createOrder(cart, callback)</code>). Control is inverted.</li> <li>Promises: The async function returns a promise (<code>orderPromise = createOrderPromise(cart)</code>). You attach your function to the promise (<code>orderPromise.then(callback)</code>). Control stays with you.</li> </ul> <p>The <code>.then()</code> method guarantees that the attached function will be called:</p> <ol> <li>Only after the promise resolves.</li> <li>Exactly once.</li> <li>With the resolved value.</li> </ol> <p>This solves the Inversion of Control problem!</p>"},{"location":"javascript/promises/#why-are-promises-important","title":"Why Are Promises Important?","text":"<ul> <li>Trust &amp; Reliability: Promises provide guarantees about when and how your callback code will execute.</li> <li>Control: You retain control over the execution flow, attaching callbacks rather than passing them in.</li> <li>Readability (Chaining): They help avoid \"Callback Hell\" (deeply nested callbacks) through promise chaining (see below).</li> <li>Error Handling: Promises have built-in mechanisms for handling errors (<code>.catch()</code>).</li> <li>Composability: Promises can be combined and managed in powerful ways (e.g., <code>Promise.all</code>, <code>Promise.race</code>).</li> </ul>"},{"location":"javascript/promises/#anatomy-of-a-promise-object","title":"Anatomy of a Promise Object","text":"<p>Let's look at a real-world example using <code>fetch</code>, a browser API for making network requests, which returns a Promise.</p> <pre><code>const GITHUB_API = \"https://api.github.com/users/\";\nconst username = \"rajandangi\";\nconst userPromise = fetch(GITHUB_API + username); // fetch returns a Promise\n\nconsole.log(\"Promise created:\", userPromise); // Logs the Promise object immediately\n\nuserPromise.then(function(response) {\n  // This runs when the fetch completes and the server responds\n  console.log(\"Promise fulfilled:\", response);\n  // Note: fetch resolves with a Response object.\n  // You often need another step to get the actual data (e.g., JSON)\n  return response.json(); // .json() also returns a Promise!\n})\n.then(function(userData) {\n    // This runs after response.json() resolves\n    console.log(\"User data:\", userData);\n})\n.catch(function(error) {\n    // This runs if fetch() or response.json() fails (e.g., network error, invalid JSON)\n    console.error(\"Promise rejected:\", error);\n});\n</code></pre> <p></p> <p>When you inspect a Promise object (e.g., in browser developer tools), you'll typically see two key things:</p> <ol> <li> <p>State: The current status of the Promise. It can be:</p> <ul> <li><code>pending</code>: The initial state; the asynchronous operation is still in progress.</li> <li><code>fulfilled</code> (or <code>resolved</code>): The operation completed successfully.</li> <li><code>rejected</code>: The operation failed.</li> <li>A Promise transitions from <code>pending</code> to either <code>fulfilled</code> or <code>rejected</code> exactly once.</li> </ul> </li> <li> <p>Result (or Value): The outcome of the operation.</p> <ul> <li>If <code>fulfilled</code>, this holds the resolved value (e.g., the <code>orderId</code>, the <code>Response</code> object from <code>fetch</code>).</li> <li>If <code>rejected</code>, this holds the reason for failure (usually an <code>Error</code> object).</li> <li>The result is <code>undefined</code> while the promise is <code>pending</code>.</li> </ul> </li> </ol> <p>Immutability: Once a Promise settles (becomes <code>fulfilled</code> or <code>rejected</code>), its state and result cannot change. This makes them reliable carriers of asynchronous outcomes. You can pass a settled promise around without worrying about its value being mutated.</p>"},{"location":"javascript/promises/#promise-chaining-escaping-callback-hell","title":"Promise Chaining: Escaping Callback Hell","text":"<p>Consider a more complex sequence:</p> <p>Create Order \u2192 Proceed to Payment \u2192 Show Order Summary \u2192 Update Wallet</p> <p>With callbacks, this leads to nested code, often called \"Callback Hell\":</p> <pre><code>// Callback Hell Example (Conceptual)\ncreateOrder(cart, function(orderId){\n    proceedToPayment(orderId, function(paymentInfo){\n        showOrderSummary(paymentInfo, function(summary){\n            updateWallet(summary, function(walletStatus){\n                console.log(\"Order complete! Final wallet status:\", walletStatus);\n                // ...and so on, potentially deeper nesting\n            });\n        });\n    });\n});\n</code></pre> <p>This code grows horizontally and becomes very difficult to read and maintain.</p> <p>Promises solve this elegantly with chaining. Since <code>.then()</code> itself often returns a new Promise (especially if the function inside <code>.then()</code> returns a Promise, like <code>response.json()</code>, you can chain <code>.then()</code> calls one after another:</p> Promise Chaining Example<pre><code>const cart = ['Shoes', 'Shirt', 'Pant', 'Socks'];\n\nfunction validateCart(cart) {\n    if (cart.length) {\n        return true;\n    }\n    return false;\n}\n\nfunction createOrder(cart) {\n    const pr = new Promise(function (resolve, reject) {\n        // validate cart\n        if (!validateCart(cart)) {\n            const err = new Error('Invalid Cart');\n            reject(err);\n        }\n        // Logic for create order\n        const orderID = \"ORD\" + Math.floor(Math.random() * 1000);\n        if (orderID) {\n            setTimeout(function () {\n                resolve(orderID);\n            }, 5000);\n        }\n    })\n    return pr;\n}\n\nfunction proceedToPayment(orderId) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            resolve('Payment Done for Order ID: ' + orderId);\n        }, 5000);\n    })\n}\n\ncreateOrder(cart)\n    .then(function (orderId) {\n        console.log('Order ID: ', orderId);\n        return orderId;\n    })\n    .catch(function (err) {\n        // this will only catch the error from the createOrder function\n        console.log('Error: ', err.message);\n    })\n    .then(function (orderId) {\n        return proceedToPayment(orderId)\n    })\n    .then(function (paymentInfo) {\n        console.log('Payment Info: ', paymentInfo);\n    })\n    .catch(function (err) {\n        console.log('Error: ', err.message);\n    });\n</code></pre> <p>Key Points for Chaining:</p> <ul> <li>Return Promises: Inside a <code>.then()</code>, if your next step is asynchronous, return its promise. This allows the next <code>.then()</code> in the chain to wait for it. If you forget to <code>return</code>, the chain might break or behave unexpectedly.</li> <li>Readability: Code flows vertically, making it much easier to follow the sequence of asynchronous operations.</li> <li>Error Handling: A single <code>.catch()</code> at the end can handle errors from any point in the chain.</li> </ul>"},{"location":"javascript/promises/#using-arrow-functions-concise-syntax","title":"Using Arrow Functions (Concise Syntax)","text":"<p>Arrow functions make promise chains even more concise:</p> Arrow Function Example<pre><code>createOrderPromise(cart)\n    .then(orderId =&gt; proceedToPaymentPromise(orderId))\n    .then(paymentInfo =&gt; showOrderSummaryPromise(paymentInfo))\n    .then(summary =&gt; updateWalletPromise(summary))\n    .then(walletStatus =&gt; {\n        console.log(\"Order complete! Final wallet status:\", walletStatus);\n    })\n    .catch(error =&gt; {\n        console.error(\"An error occurred:\", error);\n    });\n</code></pre> <p>Summary: Key Takeaways</p> <ul> <li>Purpose: Promises manage the results of asynchronous operations. They are placeholders for future values.</li> <li>States: <code>pending</code>, <code>fulfilled</code>, <code>rejected</code>. A promise settles only once.</li> <li>Result: The value (on fulfillment) or reason (on rejection).</li> <li><code>.then()</code>: Attaches callbacks to run when a promise is fulfilled.</li> <li><code>.catch()</code>: Attaches callbacks to run when a promise is rejected.</li> <li>Control: Promises solve the \"Inversion of Control\" problem seen with raw callbacks.</li> <li>Chaining: <code>.then()</code> allows chaining asynchronous operations sequentially, avoiding \"Callback Hell\" and improving readability. Remember to <code>return</code> promises within the chain.</li> <li>Immutability: Once settled, a promise's state and result cannot change.</li> </ul>"},{"location":"javascript/scope-chain-scope-lexical-environment/","title":"Scope Chain, Scope and Lexical Environment","text":"<p>This article explores three fundamental concepts in JavaScript: Scope, Lexical Environment, and the Scope Chain. Understanding these is crucial for writing predictable and bug-free code.</p> <ul> <li>What is Scope?</li> <li>What is Lexical Environment?</li> <li>What is Scope Chain?</li> </ul> <p>Scope in JavaScript is intrinsically linked to the Lexical Environment. Let's start with an example:</p> <pre><code>function a(){\n   console.log(b); // Tries to access 'b'\n}\n\nvar b = 10; // 'b' is declared in the global scope\na();        // Call function a\n</code></pre> <p>When the JavaScript engine executes <code>console.log(b)</code> inside function <code>a()</code>, it first looks for <code>b</code> within the local scope (memory space) of <code>a()</code>. Since <code>b</code> wasn't declared inside <code>a()</code>, it's not found there.</p> <p>What happens next? Will it print <code>undefined</code>, throw an error, or find the value?</p> <p>Running this code gives:</p> Console Output<pre><code>10\n</code></pre> <p>Somehow, the function <code>a()</code> was able to access the variable <code>b</code> defined outside of it.</p> <p>Let's add another layer of nesting:</p> <pre><code>function a(){\n    c(); // Call nested function c\n    function c(){\n        console.log(b); // Tries to access 'b' from within c\n    }\n}\n\nvar b = 10; // 'b' is still global\na();        // Call function a\n</code></pre> <p>Running this version yields the same result:</p> Console Output<pre><code>10\n</code></pre> <p>Function <code>c()</code> can also access the global variable <code>b</code>.</p> <p>Now, let's try the opposite: define <code>b</code> inside <code>a()</code> and try to access it globally:</p> <pre><code>function a(){\n    var b = 10; // 'b' is local to function a\n    c();\n    function c(){\n       // Function c is empty now\n    }\n}\n\na();\nconsole.log(b); // Try to access 'b' globally\n</code></pre> <p>This time, we get an error:</p> Console Output<pre><code>Uncaught ReferenceError: b is not defined\n</code></pre> <p>This error occurs because <code>b</code> is defined only within the scope of <code>a()</code> and is not accessible outside of it. This brings us to the concept of Scope.</p>"},{"location":"javascript/scope-chain-scope-lexical-environment/#what-is-scope","title":"What is Scope? \ud83c\udfaf","text":"<p>Scope determines the accessibility or visibility of variables and functions in your code during runtime. It answers two main questions:</p> <ol> <li>What is the scope of a specific variable/function? (Where is it accessible?)</li> <li>Is a variable/function within the current scope? (Can I access it from here?)</li> </ol> <p>Consider the previous example where the <code>ReferenceError</code> occurred:</p> <pre><code>function a(){\n    var b = 10; // Scope of 'b' is function 'a'\n    c();\n    function c(){\n       // Scope of 'c' is function 'a'\n    }\n}\na();\nconsole.log(b); // 'b' is NOT in the global scope\n</code></pre> <p>When this program runs:</p> <ol> <li>A Global Execution Context (GEC) is created and pushed onto the Call Stack.</li> <li><code>a()</code> is invoked. A new Execution Context for <code>a</code> is created and pushed onto the stack.</li> <li>Memory is allocated within <code>a</code>'s context for its local variable <code>b</code> (initially <code>undefined</code>) and local function <code>c</code>.</li> <li>The code inside <code>a</code> executes: <code>b</code> is assigned the value <code>10</code>.</li> <li><code>c()</code> is invoked. A new Execution Context for <code>c</code> is created and pushed onto the stack.</li> <li><code>c</code> executes (it's empty in this version). Its context is popped from the stack.</li> <li><code>a</code> finishes. Its context is popped from the stack.</li> <li>The global <code>console.log(b)</code> executes. The engine looks for <code>b</code> in the GEC. It doesn't find it, resulting in the <code>ReferenceError</code>.</li> </ol> <p></p>"},{"location":"javascript/scope-chain-scope-lexical-environment/#what-is-lexical-environment","title":"What is Lexical Environment?","text":"<p>Whenever an Execution Context is created, a Lexical Environment is also created.</p> <p>Info</p> <p>Lexical Environment = Local Memory + Reference to the Lexical Environment of its Parent.</p> <p>Lexical refers to the way code is physically written or structured. It means hierarchy or sequence based on the code structure, not the call order.</p> <p>In this code:</p> <pre><code>// Global Scope\nfunction a(){ // a is lexically inside Global Scope\n    var b = 10;\n    c();\n    function c(){ // c is lexically inside function a\n        // ...\n    }\n}\na();\nconsole.log(b);\n</code></pre> <ul> <li>Function <code>c</code> is lexically nested within function <code>a</code>.</li> <li>Function <code>a</code> is lexically nested within the global scope.</li> </ul> <p>So:</p> <ol> <li>The Lexical Environment for <code>c</code> contains its local memory (empty in this case) and a reference to the Lexical Environment of <code>a</code>.</li> <li>The Lexical Environment for <code>a</code> contains its local memory (<code>b</code>, <code>c</code>) and a reference to the Lexical Environment of the Global Scope.</li> <li>The Lexical Environment for the Global Scope contains its memory (<code>a</code>) and a reference to <code>null</code> (it has no outer lexical environment).</li> </ol> <p>Let's visualize the parent references (represented by the orange box in the original description):</p> <p></p>"},{"location":"javascript/scope-chain-scope-lexical-environment/#how-the-scope-chain-works","title":"How the Scope Chain Works \u26d3\ufe0f","text":"<p>Let's revisit the example where <code>b</code> was accessed from within <code>c</code>:</p> <pre><code>function a(){\n    var b = 10; // 'b' is local to 'a'\n    c();\n    function c(){\n        console.log(b); // Access 'b' here\n    }\n}\na();\n// console.log(b); // This would cause an error\n</code></pre> <p>When <code>console.log(b)</code> runs inside <code>c</code>:</p> <ol> <li>The JS engine looks for <code>b</code> in the local memory (Lexical Environment) of <code>c</code>. It's not found.</li> <li>The engine follows the reference to the parent's Lexical Environment, which is <code>a</code>'s environment.</li> <li>It looks for <code>b</code> in <code>a</code>'s local memory. It finds <code>b</code> with the value <code>10</code>.</li> <li>The value <code>10</code> is retrieved and printed to the console.</li> </ol> <p></p> <p>What if <code>b</code> was defined globally instead?</p> <pre><code>function a(){\n    c();\n    function c(){\n        console.log(b); // Access 'b' here\n    }\n}\nvar b = 10; // 'b' is now global\na();\n// console.log(b); // This would print 10\n</code></pre> <p>Now, the lookup process is:</p> <ol> <li>Look for <code>b</code> in <code>c</code>'s local memory. Not found.</li> <li>Follow the reference to <code>a</code>'s Lexical Environment. Look for <code>b</code>. Not found.</li> <li>Follow the reference from <code>a</code>'s environment to the Global Lexical Environment. Look for <code>b</code>. Found! (<code>b = 10</code>).</li> <li>The value <code>10</code> is retrieved and printed.</li> </ol> <p></p> <p>Finally, what if <code>b</code> is not defined anywhere?</p> <pre><code>function a(){\n    c();\n    function c(){\n        console.log(b); // Try to access 'b'\n    }\n}\n// 'b' is never defined\na();\n</code></pre> <p>Lookup process:</p> <ol> <li>Look for <code>b</code> in <code>c</code>'s local memory. Not found.</li> <li>Follow reference to <code>a</code>'s Lexical Environment. Look for <code>b</code>. Not found.</li> <li>Follow reference to Global Lexical Environment. Look for <code>b</code>. Not found.</li> <li>The engine has reached the end of the chain (<code>null</code> reference from Global LE) without finding <code>b</code>.</li> <li>A <code>ReferenceError</code> is thrown.</li> </ol> <p></p> Console Output<pre><code>Uncaught ReferenceError: b is not defined\n</code></pre> <p>In this case, we say \"<code>b</code> is not in the scope.\"</p> <p>Scope Chain</p> <p>This mechanism of searching for a variable by looking in the current local scope, and if not found, looking in the parent's lexical environment, and then the grandparent's, and so on, up to the global scope, is called the SCOPE CHAIN.</p>"},{"location":"javascript/scope-chain-scope-lexical-environment/#summary","title":"Summary \u2728","text":"<ol> <li>A Lexical Environment is created with every Execution Context. It consists of the Local Memory (variables/functions defined within that context) plus a reference to the parent's Lexical Environment.</li> <li>The parent (Lexical Parent) is determined by where a function is physically written in the code, not by how it's called.</li> <li>The Scope Chain is the chain of Lexical Environments, linked by their parent references. It dictates whether a variable or function is accessible (in scope) from a particular point in the code.</li> </ol>"},{"location":"javascript/scope-chain-scope-lexical-environment/#scope-chain-in-the-browser-debugger","title":"Scope Chain in the Browser Debugger","text":"<p>You can observe the Scope Chain using browser developer tools. Set a breakpoint inside the innermost function and inspect the \"Scope\" panel.</p> <pre><code>function a(){\n    var b = 10;\n    function c(){\n        console.log(b); // Set breakpoint here\n    }\n    c();\n}\na();\n</code></pre> <p>When paused at the breakpoint:</p> <ol> <li> <p>Call Stack: Shows the active execution contexts (<code>c</code>, <code>a</code>, <code>(anonymous)</code> for global).</p> <p></p> </li> <li> <p>Scope Panel (for <code>a</code> if inspected earlier): Would show its Local scope (<code>b</code>, <code>c</code>) and its closure scope pointing to Global.</p> <p></p> </li> <li> <p>Scope Panel (for <code>c</code>): Shows its Local scope (empty), its Closure scope (containing <code>b</code> from <code>a</code>), and the Global scope. This visually represents the Scope Chain.</p> <p></p> </li> </ol>"},{"location":"javascript/setTimeout-and-closures/","title":"Interview Questions: setTimeout and Closures","text":"<p>Prerequisite: If you don\u2019t understand how Closures work, I highly recommend reading this first:</p> <p> Closures in JavaScript</p> <p>Basic Definition: <code>setTimeout</code></p> <p>The <code>setTimeout()</code> function executes a provided function or code snippet once after a specified delay (in milliseconds).</p> <p>Syntax: <pre><code>setTimeout(callbackFunction, delayInMilliseconds);\n</code></pre></p> <ul> <li><code>callbackFunction</code>: The function to run after the delay.</li> <li><code>delayInMilliseconds</code>: The time, in milliseconds, to wait before executing the function.</li> </ul> <p>Let's look at a simple example:</p> index.js<pre><code>function x() {\n    var i = 99;\n    // Schedule the console.log(i) to run after 3000ms (3 seconds)\n    setTimeout(function () {\n        console.log(i); // Accesses 'i' via closure\n    }, 3000);\n    console.log('Hello'); // This runs almost immediately\n}\n\nx();\n</code></pre> <p>If we run this program, what do you expect to see in the console?</p> Expected Output<pre><code>Hello\n99\n</code></pre> <p>You might initially expect <code>setTimeout()</code> to pause execution for 3 seconds, print <code>i</code>, and then print 'Hello'. But that's not how it works! It prints \"Hello\" first, then waits 3 seconds, and finally prints the value of <code>i</code>.</p>"},{"location":"javascript/setTimeout-and-closures/#what-settimeout-actually-does","title":"What <code>setTimeout()</code> Actually Does","text":"<ol> <li>Closure: The anonymous function <code>function () { console.log(i); }</code> passed to <code>setTimeout</code> forms a closure. This means it \"remembers\" the variable <code>i</code> from its surrounding scope (<code>function x</code>). Crucially, it remembers the reference to <code>i</code>, not its value at that exact moment.</li> <li>Scheduling: <code>setTimeout()</code> takes this callback function, hands it off to the browser's timer mechanism (or equivalent in other environments), and sets the 3000ms timer.</li> <li>Non-Blocking: JavaScript execution doesn't pause. It immediately moves to the next line: <code>console.log('Hello');</code>.</li> <li>Callback Execution: After 3000ms elapse, the timer mechanism places the callback function onto the message queue. When the JavaScript call stack is empty, the event loop picks up the callback from the queue and executes it. At this point, the callback accesses the current value of the <code>i</code> it closed over (which is still 99).</li> </ol> <p>Now, let's tackle a common interview question that combines <code>setTimeout</code> and closures within a loop.</p>"},{"location":"javascript/setTimeout-and-closures/#the-challenge-sequential-logging-with-delay","title":"The Challenge: Sequential Logging with Delay","text":"<p>Problem: Print the numbers 1, 2, 3, 4, 5 to the console, but with a delay. Print 1 after 1 second, 2 after 2 seconds, 3 after 3 seconds, and so on. How would you achieve this?</p> <p>A common first attempt involves using a <code>for</code> loop with <code>setTimeout()</code> inside, like this:</p> index.js<pre><code>function y() {\n    for (var i = 1; i &lt;= 5; i++) {\n        setTimeout(function () {\n            console.log(i); // What will this print?\n        }, i * 1000);\n    }\n    console.log('Hello');\n}\ny();\n</code></pre> <p>Let\u2019s check the output:</p> Expected Output<pre><code>Hello\n6\n6\n6\n6\n6\n</code></pre> <p>This is not what we wanted! Why does it print 6 five times? \ud83e\uddd0</p> <p>Explanation:</p> <ol> <li>Closures Capture References: As we established, the callback function passed to <code>setTimeout</code> forms a closure. When using <code>var</code>, this closure captures a reference to the same variable <code>i</code> across all loop iterations. <code>var</code> has function scope (or global scope), not block scope, so there's only one <code>i</code> variable being updated.</li> <li>Loops Finish Quickly: JavaScript doesn't wait for <code>setTimeout</code> timers. The <code>for</code> loop runs to completion almost instantly. It schedules five <code>setTimeout</code> callbacks (for 1000ms, 2000ms, ..., 5000ms).</li> <li>Final Value of <code>i</code>: By the time the loop finishes, the condition <code>i &lt;= 5</code> becomes false. This happens when <code>i</code> is incremented to 6. So, the single <code>i</code> variable now holds the value 6.</li> <li>Callback Execution Time: Later, when the first timer (1000ms) expires and its callback function finally runs, it looks up the value of the <code>i</code> it has a reference to. At this point, <code>i</code> is 6. The same happens for the callbacks at 2000ms, 3000ms, etc. All five callbacks reference the same <code>i</code>, which holds the value 6.</li> </ol>"},{"location":"javascript/setTimeout-and-closures/#why-do-they-point-to-the-same-reference","title":"\ud83e\udd2f Why Do They Point to the Same Reference?","text":"<p>Because <code>var</code> declarations are scoped to the nearest function (or globally), not to the loop block (<code>{...}</code>). In the <code>y()</code> function, there is only one <code>i</code> variable created. Each iteration of the loop updates this single variable. All the <code>setTimeout</code> callbacks created within the loop close over this same <code>i</code>.</p>"},{"location":"javascript/setTimeout-and-closures/#how-can-we-fix-this","title":"\ud83d\udca1 How Can We Fix This?","text":"<p>We need each <code>setTimeout</code> callback to close over the value of <code>i</code> as it was during that specific loop iteration.</p> <p>Solution 1: Use <code>let</code> (Modern JavaScript)</p> <p>The simplest and most common solution today is to use <code>let</code> instead of <code>var</code>:</p> index.js<pre><code>function z() {\n    for (let i = 1; i &lt;= 5; i++) {\n        // 'let' creates a new binding for 'i' in each iteration\n        setTimeout(function () {\n            console.log(i); // Prints 1, 2, 3, 4, 5 correctly\n        }, i * 1000);\n    }\n    console.log('Hello');\n}\nz();\n</code></pre> Expected Output<pre><code>Hello\n1\n2\n3\n4\n5\n</code></pre> <p>It works!</p>"},{"location":"javascript/setTimeout-and-closures/#why-let-works","title":"\u2728 Why <code>let</code> Works","text":"<ol> <li>Block Scope: <code>let</code> (and <code>const</code>) have block scope. This means a new <code>i</code> variable is created for each iteration of the <code>for</code> loop block.</li> <li>Separate Closures: When the <code>setTimeout</code> callback is created in each iteration, it forms a closure over that iteration's specific, unique <code>i</code> variable.</li> <li>Correct Values Captured: The first callback closes over an <code>i</code> with value 1, the second closes over a different <code>i</code> with value 2, and so on. When the callbacks eventually execute, they each access the correct value they captured.</li> </ol> <p>Solution 2: Use <code>var</code> with Closures (Older Approach)</p> <p>What if you must use <code>var</code> (perhaps due to older environment constraints or interview requirements)? You need to manually create a new scope for each iteration.</p> <p>Method A: Using a separate function</p> index.js<pre><code>function a() {\n    for (var i = 1; i &lt;= 5; i++) {\n        // Create a new scope by calling a function\n        function createClosure(value) {\n            setTimeout(function () {\n                console.log(value); // Closes over 'value'\n            }, value * 1000);\n        }\n        createClosure(i); // Pass the current value of 'i'\n    }\n    console.log('Hello');\n}\na();\n</code></pre> <p>Method B: Using an Immediately Invoked Function Expression (IIFE)</p> index.js<pre><code>function b() {\n    for (var i = 1; i &lt;= 5; i++) {\n        // Create a new scope using an IIFE\n        (function (value) {\n            setTimeout(function () {\n                console.log(value); // Closes over 'value'\n            }, value * 1000);\n        })(i); // Immediately call the function, passing the current 'i'\n    }\n    console.log('Hello');\n}\nb();\n</code></pre> <p>Both <code>a()</code> and <code>b()</code> produce the desired output:</p> Expected Output<pre><code>Hello\n1\n2\n3\n4\n5\n</code></pre> <p>Why these <code>var</code> solutions work:</p> <ol> <li>New Scope Creation: Both the separate function (<code>createClosure</code>) and the IIFE create a new function scope during each loop iteration.</li> <li>Passing by Value: The loop's <code>i</code> is passed as an argument (<code>value</code>) into this new scope. Inside the scope, <code>value</code> holds the value of <code>i</code> at that specific moment in the iteration (1, then 2, then 3...).</li> <li>Closure Captures Local Value: The <code>setTimeout</code> callback is created inside this new scope. It forms a closure over the <code>value</code> variable, which is local to that scope and holds the correct number for that iteration.</li> </ol> <p>For more examples and explanations of <code>setTimeout</code>, you might find this article helpful: Playing with JavaScript setTimeout</p>"},{"location":"javascript/this-keyword/","title":"\ud83e\ude9f The <code>this</code> Keyword in JavaScript","text":"<p>Understanding the <code>this</code> keyword is essential for mastering JavaScript, as its value changes depending on how and where it is used. Let's break down its behavior in different contexts.</p>"},{"location":"javascript/this-keyword/#global-context","title":"Global Context","text":"<p>Let\u2019s start with an empty JS file. Even if there's no code, when you run the file:</p> <ul> <li>The JavaScript engine creates a Global Execution Context (GEC).</li> <li>A global object, called <code>window</code> in browsers, is created.</li> <li>The <code>this</code> keyword is initialized to refer to this global object.</li> </ul> <p></p> <p>Open the browser console and type:</p> <pre><code>window; // [Window object]\nthis;   // [Window object]\nwindow === this; // true\n</code></pre> <p></p>"},{"location":"javascript/this-keyword/#explanation","title":"Explanation:","text":"<p>In the browser, the global object is named <code>window</code>. All globally declared functions and variables become properties of <code>window</code>. The <code>this</code> keyword, when used in the global scope, also refers to the <code>window</code> object.</p> <p></p>"},{"location":"javascript/this-keyword/#what-is-the-global-space","title":"What Is the \"Global Space\"?","text":"<p>Any variable or function declared outside of any function or block resides in the global space. For example:</p> <p></p> index.js<pre><code>var y = 10;\nfunction z() {\n    var x = 20;\n}\nconsole.log(window.y); // 10\nconsole.log(y); // 10\nconsole.log(this.y); // 10\nconsole.log(x); // ReferenceError: x is not defined\n</code></pre> <p>All the following refer to the same value in the global scope:</p> index.js<pre><code>window.y === y === this.y // true\n</code></pre> <p>Summary: How Does <code>this</code> Work?</p> <ul> <li>In the global scope (browser): <code>this</code> refers to <code>window</code>.</li> <li>In Node.js: <code>this</code> refers to the <code>global</code> object.</li> <li>Inside an object\u2019s method: <code>this</code> refers to the object itself.</li> <li>Inside a function (non-strict mode): <code>this</code> refers to the global object.</li> <li>Inside a function (strict mode): <code>this</code> is <code>undefined</code>.</li> <li>Arrow functions: <code>this</code> is lexically scoped and inherits <code>this</code> from the parent scope.</li> <li>DOM event handlers: <code>this</code> refers to the HTML element that triggered the event.</li> </ul>"},{"location":"javascript/this-keyword/#examples","title":"Examples","text":""},{"location":"javascript/this-keyword/#global-scope","title":"Global Scope","text":"<pre><code>// Uncommenting this line changes 'this' in functions to undefined\n// \"use strict\";\n\nconsole.log(this); // In browsers: window (global object)\n</code></pre>"},{"location":"javascript/this-keyword/#inside-a-function","title":"Inside a Function","text":"<pre><code>function myFunction() {\n    console.log(this);\n}\n\nmyFunction();         // non-strict mode: window | strict mode: undefined\nwindow.myFunction();  // window\n</code></pre>"},{"location":"javascript/this-keyword/#inside-an-object-method","title":"Inside an Object Method","text":"<pre><code>const student = {\n    name: 'Rajan',\n    getName: function () {\n        console.log(this);\n    }\n};\nstudent.getName(); // {name: 'Rajan', getName: \u0192}\n</code></pre>"},{"location":"javascript/this-keyword/#method-borrowing-with-call-apply-bind","title":"Method Borrowing with call, apply, bind","text":"<pre><code>const student2 = { name: 'Bhawana' };\n\n// Borrow getName method from student\nstudent.getName.call(student2); // { name: 'Bhawana' }\n</code></pre>"},{"location":"javascript/this-keyword/#inside-an-arrow-function","title":"Inside an Arrow Function","text":"<p>Tip</p> <p>Arrow functions do NOT have their own <code>this</code>; they inherit <code>this</code> from where they are defined.</p> <pre><code>const obj = {\n    name: 'Rajan',\n    getName: () =&gt; {\n        console.log(this);\n    }\n};\nobj.getName(); // window (or global object in Node.js)\n</code></pre>"},{"location":"javascript/this-keyword/#nested-arrow-functions","title":"Nested Arrow Functions","text":"<p><pre><code>const obj2 = {\n    name: 'Rajan',\n    getName: function () {\n        const inner = () =&gt; {\n            console.log(this);\n        };\n        inner();\n    }\n};\nobj2.getName(); // {name: 'Rajan', getName: \u0192}\n</code></pre> Here, the arrow function's <code>this</code> is inherited from its parent scope, which is the method where <code>this</code> refers to <code>obj2</code>.</p>"},{"location":"javascript/this-keyword/#this-in-dom-event-handlers","title":"<code>this</code> in DOM Event Handlers","text":"<pre><code>const button = document.querySelector('button');\nbutton.addEventListener('click', function () {\n    console.log(this); // Refers to the &lt;button&gt; element\n});\n</code></pre> <p>Quick Reference</p> <ul> <li>By default, <code>this</code> refers to the global object (<code>window</code> in browsers, <code>global</code> in Node.js).</li> <li>Inside an object method, <code>this</code> refers to the object.</li> <li>In arrow functions, <code>this</code> is inherited (lexical).</li> <li>In DOM event handlers, <code>this</code> is the element on which the handler is placed.</li> <li>In strict mode, <code>this</code> inside functions (not called as a method) is <code>undefined</code>.</li> </ul> <p>Tip</p> <p>An empty JS file is the shortest possible JS program, since it still sets up the global context (<code>window</code>, <code>this</code>, etc.).</p>"},{"location":"javascript/undefined-vs-not-defined/","title":"<code>undefined</code> vs <code>not defined</code> in JavaScript","text":"<p>JavaScript handles variables in a unique way compared to many other programming languages, especially regarding the concepts of <code>undefined</code> and <code>not defined</code>.</p>"},{"location":"javascript/undefined-vs-not-defined/#what-is-undefined","title":"What is <code>undefined</code>?","text":"<p>In JavaScript, <code>undefined</code> is a special keyword and primitive value. It is automatically assigned to variables that have been declared but not yet given a value.</p>"},{"location":"javascript/undefined-vs-not-defined/#why-does-this-happen","title":"Why does this happen?","text":"<ul> <li>When JavaScript code runs, it first creates a global execution context.</li> <li>During this process, JavaScript allocates memory for all variables and functions before any code is executed (this phase is called hoisting).</li> <li>For variables, JavaScript sets their initial value to <code>undefined</code> as a placeholder until they are assigned a real value.</li> </ul> Example: Hoisting and undefined<pre><code>console.log(\"a =\", a); // Output: a = undefined\nvar a = 10;\nconsole.log(\"a =\", a); // Output: a = 10\n</code></pre> <p>Explanation</p> <ul> <li><code>a</code> is declared with <code>var</code>. Before the value <code>10</code> is assigned, <code>a</code> exists in memory with the value <code>undefined</code>.</li> <li>After the assignment, <code>a</code> holds the value <code>10</code>.</li> </ul>"},{"location":"javascript/undefined-vs-not-defined/#what-is-not-defined","title":"What is <code>not defined</code>?","text":"<p>A variable is <code>not defined</code> when you try to access a variable that has never been declared in your code.</p> Example: not defined<pre><code>console.log(x); // ReferenceError: x is not defined\n</code></pre> <p>Explanation</p> <p><code>x</code> has not been declared anywhere in the code. Trying to access it causes a <code>ReferenceError</code>.</p>"},{"location":"javascript/undefined-vs-not-defined/#key-differences","title":"Key Differences","text":"<code>undefined</code> <code>not defined</code> When? Variable declared but unassigned Variable never declared Error? No error; value is <code>undefined</code> ReferenceError when accessed Example <code>var a; console.log(a); // undefined</code> <code>console.log(x); // ReferenceError: x is not defined</code>"},{"location":"javascript/undefined-vs-not-defined/#common-mistake-assigning-undefined","title":"Common Mistake: Assigning <code>undefined</code>","text":"<p>It's possible to assign <code>undefined</code> to a variable:</p> <pre><code>var b = undefined; // Technically allowed, but discouraged\n</code></pre> <p>However, this is generally considered bad practice because:</p> <ul> <li><code>undefined</code> is meant as a placeholder before a variable is assigned a value.</li> <li>Assigning <code>undefined</code> directly might make your code harder to understand and can lead to bugs or confusion.</li> </ul>"},{"location":"javascript/undefined-vs-not-defined/#quick-faqs","title":"Quick FAQs","text":"<ul> <li> <p>Is <code>undefined</code> the same as \"empty\"?</p> <p>No. An <code>undefined</code> variable has memory reserved for it; it's not the same as empty or non-existent.</p> </li> <li> <p>What if I declare a variable but never assign a value?</p> <p>It will hold the value <code>undefined</code> for its entire lifetime.</p> </li> <li> <p>Should I use <code>undefined</code> as a value on purpose?</p> <p>Best practice is to let JavaScript use <code>undefined</code> naturally rather than assigning it yourself.</p> </li> </ul> <p>Key Takeaway</p> <ul> <li><code>undefined</code>: Variable declared, memory reserved, but not yet assigned a value.</li> <li><code>not defined</code>: Variable does not exist in the current scope; accessing it throws a <code>ReferenceError</code>.</li> <li>Avoid directly assigning <code>undefined</code> to variables.</li> </ul>"},{"location":"nodejs/","title":"Node.js","text":"<p>Jeff Atwood</p> <p>Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>"},{"location":"nodejs/#introduction","title":"Introduction","text":"<p>Node.js is a cross-platform, open-source JavaScript runtime environment that can run on Windows, Linux, Unix, MacOS, and more. Node.js runs on the V8 JavaScript engine and executes JavaScript code outside of a web browser.</p> <ul> <li>Node.js is a JavaScript runtime environment built on Chrome's V8 JavaScript engine.</li> <li>It is maintained by the OpenJS Foundation.</li> <li>Node.js allows JavaScript to be executed outside of a web browser.</li> <li>This means that while JavaScript is traditionally associated with the web and   browsers, Node.js extends its reach, allowing you to run JavaScript code on   servers, desktops, and even embedded systems. This is why Node.js is often   described with the phrase \"Run JavaScript Everywhere.\"</li> <li>Node.js features an event-driven architecture and supports asynchronous I/O (non-blocking I/O).</li> </ul> <p>JS Engine</p> <p>To run JavaScript, you always need a JS engine. Everywhere you write JS code, there is a JS engine that executes the code.</p>"},{"location":"nodejs/#history-of-nodejs","title":"History of Node.js","text":"<ul> <li> <p>Node.js was created by Ryan Dahl in 2009.</p> </li> <li> <p>Ryan started with the SpiderMonkey JavaScript engine, which was the first JavaScript engine to be used in a web browser. SpiderMonkey is Mozilla's JavaScript and WebAssembly Engine, used in Firefox, Servo and various other projects. It is written in C++, Rust and JavaScript. But, after just two days he switched to the V8 JavaScript engine, which is the JavaScript engine used by Google Chrome, and never looked back.</p> </li> <li> <p>Initially, Ryan was working independently, but a company named Joyent was working on something similar to Node.js. They hired Ryan to work under them and funded his project, making a significant contribution to Node.js's development.</p> </li> <li> <p>The original name of Node.js was actually Web.js, but Ryan renamed it to Node.js because he intended it to be used for more than just web servers.</p> </li> <li> <p>Apache HTTP Server was a blocking server, so Ryan wanted to create a non-blocking server, which is why Node.js uses non-blocking I/O. The advantage of a non-blocking server is that it can handle multiple requests with fewer threads.</p> </li> <li> <p>In 2010, NPM (Node Package Manager) was introduced. NPM is a package manager for Node.js, and it played a critical role in the success of Node.js. Without NPM, Node.js might not have become as successful as it is today.</p> </li> <li> <p>Initially, Node.js was built only for macOS and Linux, but in 2011, it gained support for Microsoft Windows as well.</p> </li> <li> <p>In 2012, Isaac Z. Schlueter, the creator of NPM, began maintaining Node.js.</p> </li> <li> <p>In 2014, a developer named Fedor created a fork of Node.js called io.js, which led to controversy within the community. As a result, several developers began maintaining the io.js branch.</p> </li> <li> <p>In September 2015, Node.js and io.js were merged, and the combined project was named the Node.js Foundation.</p> </li> <li> <p>In 2019, the JS Foundation and the Node.js Foundation merged to form the OpenJS Foundation, which now maintains Node.js.</p> </li> </ul> <p> </p>"},{"location":"nodejs/creating-a-server/","title":"Creating a Server","text":""},{"location":"nodejs/creating-a-server/#what-is-a-server","title":"What is a Server","text":"<p>The term \"server\" can refer to both hardware and software, depending on the context.</p> <ul> <li>Hardware: A physical machine (computer) that provides resources and services to other computers (clients) over a network.</li> <li>Software: An application or program that handles requests and delivers data to clients.</li> </ul>"},{"location":"nodejs/creating-a-server/#deploying-an-application-on-a-server","title":"Deploying an Application on a Server","text":"<p>When someone says \"deploy your app on a server,\" they usually mean:</p> <ol> <li>Hardware Aspect: You need a physical machine (server) to run your application. This machine has a CPU, RAM, storage, etc.</li> <li>Operating System (OS): The server hardware runs an operating system like Linux or Windows. Your application runs on this OS.</li> <li>Server Software: The software (e.g., a web server like Apache or an application server built with Node.js) that handles requests from users.</li> </ol>"},{"location":"nodejs/creating-a-server/#and-cloud-computing","title":"and Cloud Computing","text":"<p> (Amazon Web Services) provides cloud-based resources, including servers.</p> <ul> <li>EC2 Instance: When you launch an EC2 instance, you\u2019re essentially renting a virtual server from AWS. AWS manages the underlying hardware, and you deploy your application on the virtual server.</li> <li>Scalability: AWS allows you to easily scale your resources. For example, you can increase the memory or processing power of your server with a few clicks, which is not as straightforward on a physical laptop or desktop.</li> <li>Reliability: AWS servers are equipped with constant power, internet backup, and redundant systems to ensure high availability, which is difficult to achieve with a personal computer.</li> </ul>"},{"location":"nodejs/creating-a-server/#can-you-use-your-own-laptop-as-a-server","title":"Can You Use Your Own Laptop as a Server?","text":"<p>Yes, but with limitations:</p> <ul> <li>Hardware Constraints: Your laptop likely has limited RAM, CPU, and storage, which may not be sufficient for handling a large number of requests.</li> <li>Internet Connectivity: A home internet connection is typically less reliable and has dynamic IP addresses, making it less suitable for hosting a publicly accessible server.</li> <li>Power and Maintenance: Ensuring that your laptop is always on, connected to the internet, and has backup power is challenging. AWS handles all these concerns for you.</li> </ul>"},{"location":"nodejs/creating-a-server/#software-servers-in-nodejs","title":"Software Servers in Node.js","text":"<p>When you create an HTTP server in Node.js, you\u2019re building an application that listens for requests from clients and responds to them. This is an example of a software server.</p>"},{"location":"nodejs/creating-a-server/#client-server-architecture","title":"Client-Server Architecture","text":"<p>The term \"client\" refers to someone accessing a server. Imagine a user sitting at a computer wanting to access a file from a server. For this, the client needs to open a socket connection (not to be confused with WebSocket). Every client has an IP address, and every server has an IP address as well. The client could be a web browser.</p> <p>To access the file, the client opens a socket connection. On the server side, there should be an application that is listening for such requests, retrieves the requested file, and sends it back to the client.</p> <p>There can be multiple clients, and each client creates a socket connection to get data. After the data is received, the socket connection is closed. If the client needs to make another request, a new socket connection is created, data is retrieved, and the connection is closed again.</p> <p>Sockets operate using the TCP/IP protocol (Transmission Control Protocol/Internet Protocol).</p>"},{"location":"nodejs/creating-a-server/#what-is-a-protocol","title":"What is a protocol?","text":"<p>A protocol is a set of rules that define how computers communicate with each other. Protocols determine the format in which data is sent between devices.</p> <ul> <li>FTP (File Transfer Protocol): Used for transferring files.</li> <li>SMTP (Simple Mail Transfer Protocol): Used for sending emails.</li> </ul> <p>When we talk about a web server, we usually mean an HTTP server. HTTP (HyperText Transfer Protocol) is a language or set of rules that defines how clients and servers communicate.</p> <p>Essentially, when we create a server, it's often built using HTTP to handle basic data exchanges.</p>"},{"location":"nodejs/creating-a-server/#how-is-data-sent-when-you-make-a-server-request","title":"How is data sent when you make a server request?","text":"<p>Data is sent in chunks, and these smaller units are known as packets. Whenever data is transmitted, it's broken down into these packets. Remember the term \"packets.\" The TCP/IP protocol is responsible for sending these packets and ensuring that the data transmission is properly managed.</p> <p>In Node.js, there are concepts of streams and buffers that are used for handling and writing code related to data transmission.</p>"},{"location":"nodejs/creating-a-server/#domain-names-and-ip-addresses","title":"Domain Names and IP Addresses","text":"<p>We don't generally communicate using IP addresses; instead, we use domain names like <code>youtube.com</code>. However, at the end of the day, everything maps to an IP address.</p> <p>As humans, we don\u2019t easily understand or remember IPs, similar to how we save contacts with names instead of memorizing phone numbers. Similarly, when we request a URL like <code>youtube.com</code>, internally, it is translated into an IP address. This is where the Domain Name System (DNS) comes into play.</p> <p>A DNS server manages the mapping between domain names and IP addresses. When you request a website, your browser calls a DNS server to resolve the domain name into an IP address. Once the IP is resolved, a call is made to the server.</p> <p>As a user, you don\u2019t see what happens behind the scenes. When you request an IP, it goes to the server where an HTTP server processes the request and sends back the video data. This data is sent in chunks, known as streams, and the process involves buffers, which is why you sometimes see the video buffering.</p>"},{"location":"nodejs/creating-a-server/#can-i-create-multiple-servers","title":"Can I create multiple servers?","text":"<p>Yes, you can create multiple HTTP servers.</p> <p>Now, suppose a user is sending a request. How do we know which server it should go to?</p> <p>When I mention creating an HTTP server, it means we are setting up two different Node.js applications. The distinction between these servers is defined by a port, which is a 4-digit number (e.g., port <code>3000</code>).</p> <p>For example, suppose an HTTP server with IP address <code>102.209.1.3</code> is running on port <code>3000</code>. This combination of IP address and port number (<code>102.209.1.3:3000</code>) indicates which specific HTTP server the request should be routed to.</p> <p>Essentially, this means there\u2019s a single computer (the server) that can run multiple applications, each with its internal servers. The port number determines which application or server the request is directed to.</p>"},{"location":"nodejs/creating-a-server/#mapping-domain-names-ips-ports-and-paths-to-applications","title":"Mapping Domain Names, IPs, Ports, and Paths to Applications","text":"<p>When you enter a domain name like <code>youtube.com</code>, it gets mapped to an IP address by a DNS (Domain Name System) server. The IP address identifies the specific server where the website is hosted.</p> <p>Now, when you combine the IP address with a port number, you can direct the request to a specific application running on that server. The port number acts as a gateway to different applications or services on the same server. For example:</p> <ul> <li><code>102.209.1.3:3000</code> could point to a React application.</li> <li><code>102.209.1.3:3001</code> could point to a Node.js application.</li> </ul> <p>But there's more! If you add a path to the URL, you can create specific API routes. For example:</p> <ul> <li>If you enter <code>youtube.com</code>, the server might direct you to the React application running on port <code>3000</code>.</li> <li>If you enter <code>youtube.com/api/...</code>, it might direct the request to a Node.js application running on port <code>3001</code>.</li> </ul>"},{"location":"nodejs/creating-a-server/#distributed-server-architecture","title":"Distributed Server Architecture","text":"<p>In large companies, the architecture is often distributed across multiple servers rather than relying on a single server. This approach helps manage different aspects of the application efficiently and ensures scalability, reliability, and performance.</p>"},{"location":"nodejs/creating-a-server/#1-separation-of-concerns","title":"1. Separation of Concerns:","text":"<ul> <li>Frontend Server: This server handles the user interface (UI) of the application. It serves the HTML, CSS, and JavaScript files that the browser needs to render the website. For example, <code>rajandangi.com.np</code> could be hosted on an AWS server that serves both the frontend and backend.</li> <li>Backend Server: This server processes the logic, handles requests, and interacts with the database. Even though the backend might be on the same server as the frontend in some cases, it\u2019s often separated in larger systems for better performance and security.</li> </ul>"},{"location":"nodejs/creating-a-server/#2-dedicated-database-server","title":"2. Dedicated Database Server:","text":"<p>The database is typically hosted on a separate, powerful server that is optimized for storing and managing data. When a client makes a request that involves data retrieval or storage, the backend server interacts with this database server to fulfill the request.</p>"},{"location":"nodejs/creating-a-server/#3-media-and-file-servers","title":"3. Media and File Servers:","text":"<p>Large files like videos, images, and other media are often stored on specialized servers. These servers are optimized for handling large amounts of data and delivering it quickly. When you request a video from <code>rajandangi.com.np</code>, the video might be fetched from a dedicated media server. Images might also be stored on a different server, often managed by a content delivery network (CDN) to ensure fast delivery to users worldwide.</p>"},{"location":"nodejs/creating-a-server/#4-inter-server-communication","title":"4. Inter-Server Communication:","text":"<p>When a client makes a request, the frontend or backend server might need to communicate with other servers to get the necessary data. For example, if you request a video on <code>rajandangi.com.np</code>, the server might make an API call to another server that hosts the video content, retrieve it, and then send it to the client.</p> <p>In many companies, the frontend and backend may also be hosted on different servers. This separation allows each part of the system to be optimized for its specific role, ensuring better performance and making the system more scalable and resilient.</p> <p>This distributed approach helps large companies manage massive amounts of data and traffic efficiently, ensuring that users have a smooth and responsive experience.</p>"},{"location":"nodejs/creating-a-server/#socket-vs-websockets","title":"Socket vs WebSockets","text":"<p>When a user makes a request to a website, a socket connection is established between the client and the server. This connection is typically used for a single request-response cycle: the client sends a request, the server processes it, sends back the response, and then the socket is closed. This process involves opening a new connection for each request.</p> <p>On the other hand, WebSockets introduce a more efficient method by allowing the connection to remain open. This means that after the initial connection is established, it stays active, allowing for continuous communication between the client and server. Both the client and server can send and receive data at any time without the need to re-establish the connection. This persistent connection is ideal for real-time applications, where continuous interaction is required, such as in chat applications, online gaming, or live updates.</p>"},{"location":"nodejs/creating-a-server/#creating-a-server_1","title":"Creating a Server","text":"<p>Now, I want to handle different responses for the URL <code>localhost:3000/getsecretdata</code>.</p> <p>Here's how you can create a basic HTTP server in Node.js to achieve this:</p> <pre><code>const http = require('http');\n\n// Create a server instance\nconst server = http.createServer(function (req, res) {\n  // Set the content type to plain text\n  res.setHeader('Content-Type', 'text/plain');\n\n  if (req.url === \"/getsecretdata\") {\n    res.end(\"There is no secret data\");\n  } else {\n    res.end(\"Hello World from your Node.js server!\");\n  }\n});\n\n// Listen for incoming requests on port 3000\nconst port = 3000;\nserver.listen(port, () =&gt; {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n</code></pre> <p>In this example: 1.  We require the built-in <code>http</code> module. 2.  We call <code>http.createServer()</code>, providing a callback function that will be executed for each incoming request (<code>req</code>). 3.  Inside the callback, we check if the requested <code>req.url</code> is <code>\"/getsecretdata\"</code>.     *   If it is, we send back the response \"There is no secret data\" using <code>res.end()</code>.     *   Otherwise, for any other URL, we send \"Hello World from your Node.js server!\". 4.  <code>server.listen(3000)</code> starts the server and makes it listen for connections on port <code>3000</code>.</p> <p>This is a fundamental way to create a server. For more complex applications, frameworks can simplify this process.</p> <p>We use Express to create a server. Express is a framework built on top of Node.js that makes our lives easier.</p>"},{"location":"nodejs/diving-into-nodejs-repo/","title":"Diving into Node.js Modules","text":"<p>In this section, we'll explore how Node.js modules work behind the scenes. We'll examine how modules are loaded, how Node.js handles multiple modules, and take a deep dive into the <code>module.exports</code> and <code>require</code> functions.</p>"},{"location":"nodejs/diving-into-nodejs-repo/#module-privacy-the-iife-wrapper","title":"Module Privacy: The IIFE Wrapper","text":"<p>Node.js ensures that variables and functions defined within a module remain private by default. This is achieved using a technique similar to function scope in JavaScript, but implemented with a special wrapper called an IIFE (Immediately Invoked Function Expression).</p>"},{"location":"nodejs/diving-into-nodejs-repo/#understanding-scope-in-javascript","title":"Understanding Scope in JavaScript","text":"<p>First, let's recall how function scope works in plain JavaScript:</p> <pre><code>function x () {\n  const a = 10; // 'a' is local to function x\n  function b () { // 'b' is local to function x\n    console.log(\"b\");\n  }\n  // 'a' and 'b' are only accessible inside function x\n}\n\n// console.log(a); // Error: a is not defined (outside x's scope)\n// x(); // Calling x executes its code, but doesn't expose 'a' or 'b' globally\n</code></pre> <p>Variables and functions declared inside a function are generally not accessible from outside that function.</p>"},{"location":"nodejs/diving-into-nodejs-repo/#nodejs-module-wrapping-with-iife","title":"Node.js Module Wrapping with IIFE","text":"<p>When you <code>require</code> a file in Node.js, the code within that file isn't executed directly in the global scope. Instead, Node.js wraps it inside an IIFE like this before execution:</p> <pre><code>(function (exports, require, module, __filename, __dirname) {\n    // All the code from your module file (e.g., myModule.js) runs here.\n\n    // Example:\n    // const myVar = 'Hello';\n    // function privateFunction() { /* ... */ }\n    // module.exports.myVar = myVar; // Only explicitly exported things are public.\n\n})(); // The final () immediately invokes the function\n</code></pre> <p>What is an IIFE?</p> <p>What is an IIFE? It's a function that is defined and executed immediately. This pattern is distinct from defining a function and calling it later:</p> Normal function definition and invocation<pre><code>function myFunction() { /* ... */ } // Definition\nmyFunction(); // Invocation\n</code></pre> IIFE - Definition and invocation combined<pre><code>(function() {\n    /* ... */\n})();\n</code></pre>"},{"location":"nodejs/diving-into-nodejs-repo/#why-use-an-iife-for-modules","title":"Why Use an IIFE for Modules?","text":"<ol> <li>Privacy: It prevents variables, functions, and classes defined within the module from polluting the global scope or conflicting with identifiers in other modules. Everything inside is local unless explicitly attached to <code>module.exports</code> or <code>exports</code>.</li> <li>Dedicated Scope: It creates a unique execution environment for the module.</li> <li>Module Globals: Node.js uses the function parameters to inject useful, module-specific variables:<ul> <li><code>exports</code>: An object initially referencing <code>module.exports</code>. Often used as a shorthand.</li> <li><code>require</code>: The function used to import other modules.</li> <li><code>module</code>: An object containing metadata about the current module, including the crucial <code>exports</code> property.</li> <li><code>__filename</code>: The absolute path to the current module file.</li> <li><code>__dirname</code>: The absolute path to the directory containing the current module file.</li> </ul> </li> </ol> <p>How are variables and functions kept private in different modules?</p> <p>Primarily due to the IIFE wrapper. Each module's code runs within its own isolated function scope created by the IIFE.</p> <p>Where do <code>module</code> and <code>module.exports</code> come from?</p> <p>They are provided by Node.js as parameters to the IIFE wrapper function when the module is loaded via <code>require</code>. Assigning to <code>module.exports</code> (or the <code>exports</code> object) defines what the module makes publicly available.</p>"},{"location":"nodejs/diving-into-nodejs-repo/#how-require-works-behind-the-scenes","title":"How <code>require()</code> Works Behind the Scenes","text":"<p>The <code>require()</code> function is the mechanism for importing modules in Node.js (specifically for CommonJS modules). Here's a breakdown of its process when you call <code>require('some-module')</code>:</p> <ol> <li>Resolving: Node.js determines the absolute path of <code>some-module</code>.<ul> <li>It first checks if it's a core module (like <code>fs</code>, <code>http</code>, <code>path</code>).</li> <li>If not, it checks if it starts with <code>./</code>, <code>/</code>, or <code>../</code>, indicating a local file or directory. It searches for <code>.js</code>, <code>.json</code>, and <code>.node</code> files.</li> <li>If not, it looks for <code>some-module</code> within <code>node_modules</code> directories, starting from the current directory and moving up the parent directory chain.</li> </ul> </li> <li>Loading: Node.js reads the content of the file found at the resolved path.</li> <li>Wrapping: The loaded file content (JavaScript code) is wrapped inside the IIFE discussed earlier, providing the module scope and injecting <code>exports</code>, <code>require</code>, <code>module</code>, <code>__filename</code>, <code>__dirname</code>.</li> <li>Evaluating: The wrapped code is executed by the V8 JavaScript engine. This is where the module defines its exports by assigning values to <code>module.exports</code> or <code>exports</code>.</li> <li>Caching: This is a critical optimization. The first time a module is required, its evaluated <code>module.exports</code> object is stored in a cache, keyed by its resolved filename. Subsequent <code>require()</code> calls for the exact same file will retrieve the cached <code>module.exports</code> directly, skipping steps 1-4 entirely.</li> </ol>"},{"location":"nodejs/diving-into-nodejs-repo/#importance-of-caching","title":"Importance of Caching","text":"<p>Caching ensures that:</p> <ul> <li>Performance: Module code is executed only once, even if required multiple times from different parts of an application. This avoids redundant file reading and execution overhead.</li> <li>Consistency: All parts of the application requiring the same module receive the exact same instance (the same object in memory). This is important for modules that maintain state or represent singletons.</li> </ul> <p>Imagine <code>app.js</code>, <code>serviceA.js</code>, and <code>serviceB.js</code> all need a utility module <code>./utils.js</code></p> <ul> <li> <p>First <code>require('./utils.js')</code> (e.g., in <code>app.js</code>):</p> <p>Node.js performs resolving, loading, wrapping, and evaluation. The resulting <code>module.exports</code> from <code>utils.js</code> is cached.</p> </li> <li> <p>Subsequent <code>require('./utils.js')</code> (e.g., in <code>serviceA.js</code>):</p> <p>Node.js finds the cached entry for the resolved path of <code>./utils.js</code> and immediately returns the same <code>module.exports</code> object created earlier. The <code>utils.js</code> code is not executed again.</p> </li> </ul>"},{"location":"nodejs/diving-into-nodejs-repo/#exploring-the-nodejs-source-code","title":"Exploring the Node.js Source Code","text":"<p>Node.js is open-source, and its codebase reveals how these mechanisms are implemented. You can explore it on GitHub: https://github.com/nodejs/node</p> <ul> <li> <p>Core Dependencies:</p> <ul> <li>V8 Engine: Integrates Google's V8 JavaScript engine for executing JS code.</li> <li>Libuv: Provides the crucial asynchronous I/O capabilities (event loop, file system operations, networking, etc.), enabling Node.js's non-blocking nature. Much of Node's power comes from <code>libuv</code>.</li> </ul> </li> <li> <p>JavaScript Modules (<code>lib</code> directory):</p> <p>The <code>lib</code> directory (https://github.com/nodejs/node/tree/main/lib) contains the JavaScript source code for Node.js's built-in modules (<code>fs</code>, <code>http</code>, <code>path</code>, <code>events</code>, <code>timers</code>, etc.). These modules often provide a JavaScript interface over underlying C++ functionality implemented using V8 and Libuv.</p> <p>Example: <code>lib/timers.js</code> contains logic related to <code>setTimeout</code>, <code>setInterval</code>.</p> </li> <li> <p><code>require</code> Implementation:</p> <p>The logic for the <code>require</code> function itself is implemented within internal modules:</p> <ul> <li><code>lib/internal/modules/cjs/loader.js</code>: Contains the core logic for the CommonJS module loader, including resolution, loading, wrapping, evaluation, and caching (<code>Module._load</code>, <code>Module._resolveFilename</code>, <code>Module.wrap</code>, <code>Module._cache</code>, etc.).</li> <li><code>lib/internal/modules/helpers.js</code>: Includes helper functions like <code>makeRequireFunction</code>, which creates the specific <code>require</code> function available inside each module.</li> </ul> </li> <li> <p>Error Handling:</p> <p>The loader code in <code>cjs/loader.js</code> also handles errors, such as throwing a <code>TypeError</code> if you pass an invalid argument (like <code>undefined</code>) to <code>require()</code>.</p> </li> </ul>"},{"location":"nodejs/diving-into-nodejs-repo/#further-reading","title":"Further Reading","text":"<ul> <li>NodeJS: Ever Wondered How \u2018require()\u2019 works</li> </ul>"},{"location":"nodejs/js-on-server/","title":"JavaScript on Server","text":"<p>What is a Server?</p> <p>A server is essentially a remote computer that provides resources, services, or programs to other computers (clients) over a network. When you interact with a website or app, your device communicates with servers behind the scenes.</p> <p>Think of it this way: your computer (the client) makes requests, and servers respond by providing what you need - whether that's a webpage, data from a database, or processing power.</p> <p>When a computer needs to communicate with a server, it sends a request using the server's IP address - a unique identifier that works like a digital postal address.</p>"},{"location":"nodejs/js-on-server/#what-is-an-ip-address","title":"What is an IP Address?","text":"<p>An IP address (Internet Protocol address) is a unique numerical label assigned to every device connected to the internet. It serves two primary functions:</p> <ul> <li>Identifying the host or network interface</li> <li>Providing the location of the device in the network</li> </ul> <p>IP addresses allow devices to find and communicate with each other across the internet.</p>"},{"location":"nodejs/js-on-server/#the-v8-engine","title":"The V8 Engine","text":"<p>V8 is Google's open-source, high-performance JavaScript and WebAssembly engine written in C++. It powers Chrome browser and Node.js, among other applications.</p> <pre><code>JavaScript Code \u2192 V8 Engine \u2192 Machine Code \u2192 Computer Execution\n</code></pre> <p>Key features of V8 include:</p> <ul> <li>Written in C++ with the ability to be embedded into any C++ application</li> <li>Implements ECMAScript and WebAssembly standards</li> <li>Runs on various operating systems (Windows, macOS, Linux) and processors (x64, IA-32, ARM)</li> <li>Compiles JavaScript directly to native machine code before execution, rather than interpreting it</li> </ul>"},{"location":"nodejs/js-on-server/#javascript-runtime-and-nodejs","title":"JavaScript Runtime and Node.js","text":"<p>Originally, JavaScript could only run in web browsers, limiting it to client-side development. However, Node.js changed everything by bringing JavaScript to the server side.</p> <p>Node.js is essentially a C++ application with the V8 engine embedded into it, but with added capabilities:</p> <ul> <li>File system operations</li> <li>Network requests</li> <li>Database connections</li> <li>Server creation and management</li> </ul> <p>These additional APIs extend beyond the ECMAScript standards that V8 follows, making Node.js more powerful than V8 alone.</p>"},{"location":"nodejs/js-on-server/#ecmascript-standards","title":"ECMAScript Standards","text":"<p>ECMAScript is the standard specification that defines JavaScript. JavaScript engines like V8 follow these standards to ensure consistent behavior across different environments.</p> <p>Think of ECMAScript as the blueprint, while JavaScript is the most popular implementation of that blueprint.</p>"},{"location":"nodejs/js-on-server/#from-high-level-to-low-level","title":"From High-Level to Low-Level","text":"<p>Ever wonder how your JavaScript code comes to life? </p> <p></p> <p>We write JavaScript (a high-level language), and then the V8 engine translates it into machine and assembly code (low-level code) so computers can understand and execute it. This transformation process is what makes it possible for our human-readable code to power applications!</p> <p>Low-level code refers to programming languages that are closer to machine language and hardware, with minimal abstraction:</p> <ol> <li>Assembly Language: Uses symbolic representations for operations, making it somewhat more readable for humans while still maintaining a direct correlation to machine instructions</li> <li>Machine Language: The most basic form, consisting of binary (0s and 1s) instructions that CPUs directly execute</li> </ol>"},{"location":"nodejs/libuv-%26-async-io/","title":"libuv and Async I/O","text":"<p>The Node.js Wikipedia page mentions that Node.js has an event-driven architecture capable of asynchronous I/O. This is a key feature of Node.js, made possible by the underlying library called libuv.</p> <p>In this section, we will explore this concept in detail, including how Node.js handles asynchronous I/O operations and the role of libuv in this process.</p>"},{"location":"nodejs/libuv-%26-async-io/#warmup","title":"Warmup","text":"<p>What is the callback queue (task queue)?</p> <ul> <li>After executing I/O tasks, JavaScript runtimes add them to the callback queue.</li> <li>The event loop picks these tasks from the callback queue and adds them to the call stack.</li> </ul> <p>Callback queue vs Microtask queue</p> <ul> <li>Task queue handles:<ul> <li><code>setTimeout</code>/<code>setInterval</code> callbacks</li> <li>I/O operations</li> </ul> </li> <li>Microtask queue handles:<ul> <li>Promise callbacks</li> </ul> </li> <li>The microtask queue has higher priority. The task queue will only be handled if the microtask queue is empty.</li> </ul>"},{"location":"nodejs/libuv-%26-async-io/#watch-the-video-before-we-start","title":"Watch the video before we start","text":"<p>Let's start with the fundamentals of JavaScript first.</p>"},{"location":"nodejs/libuv-%26-async-io/#what-is-a-thread","title":"What is a thread?","text":"<p>A thread is the smallest unit of execution within a process that can be scheduled by the operating system. It represents a single sequence of instructions that can be managed independently by a scheduler. Multiple threads can exist within a single process, sharing the same memory space but executing independently. This allows for parallel execution of tasks within a program, improving efficiency and responsiveness.</p>"},{"location":"nodejs/libuv-%26-async-io/#what-type-of-threading-does-javascript-use","title":"What type of threading does JavaScript use?","text":"<ul> <li> <p>JavaScript is a synchronous, single-threaded language, meaning there is only one thread in which the JavaScript engine (such as the V8 engine) runs. Code is executed line by line within this single thread.</p> </li> <li> <p>In other languages like C++ or Java, code can be executed across multiple threads. For example, a portion of the code might be executed in one thread, while another part runs simultaneously in a different thread. However, JavaScript executes code sequentially\u2014one line after the other.</p> </li> <li> <p>If you're executing line 2 in JavaScript, it will only run after line 1 has finished executing. This is the essence of synchronous execution: each task is performed one after the other, without overlap.</p> </li> </ul> <p>Twist: JavaScript is single-threaded, but how does Node.js handle asynchronous I/O?</p> <ul> <li>Node.js is built on top of JavaScript and uses a non-blocking I/O model. While JavaScript itself is single-threaded, Node.js can handle multiple I/O operations concurrently without blocking the main thread.</li> <li>This is achieved through the use of an event loop and a thread pool, which allows Node.js to perform asynchronous operations efficiently.</li> <li>This is where libuv comes into play. It provides the underlying mechanisms for handling asynchronous I/O operations in Node.js, enabling tasks like file reading, network requests, and database queries without blocking the main thread.</li> </ul> <p>What are the components inside the JS engine, and how is synchronous code executed by the JS engine?</p> <p>Must go through the following sections to understand the concept of the event loop and how the JS engine executes synchronous code:</p> <p> Execution Contexts and the Call Stack</p> <p> Callback Functions</p> <p> Asynchronous JavaScript &amp; The Event Loop</p> <p> JavaScript Engine Architecture</p>"},{"location":"nodejs/libuv-%26-async-io/#how-is-asynchronous-code-executed","title":"How is asynchronous code executed?","text":"<p>The JavaScript engine cannot handle asynchronous tasks alone; it needs additional capabilities. This is where Node.js comes into the picture, enabling interaction with operating system functionalities.</p> <p></p> <p>The JS engine gains its \"superpowers\" from Node.js. Node.js provides these powers through a library named libuv \u2014 our superhero.</p> <p>The JS engine cannot directly access OS files, so it relies on libuv. Libuv communicates with the OS, performs the necessary tasks, and then returns the response to the JS engine. It offloads the work and handles it efficiently behind the scenes.</p>"},{"location":"nodejs/libuv-%26-async-io/#how-does-javascript-exhibit-asynchronous-behavior","title":"How does JavaScript exhibit asynchronous behavior?","text":"<p>Runtime environments provide the ability to handle asynchronous tasks for the JavaScript engine.</p> <ul> <li> <p>Browser: Browsers provide the ability to handle asynchronous tasks using Web APIs. These APIs are built into the browser and allow JavaScript to perform tasks like making network requests, manipulating the DOM, and handling timers without blocking the main thread.</p> </li> <li> <p>Node.js: Node.js provides the ability to handle asynchronous tasks using the libuv library. This library allows Node.js to perform non-blocking I/O operations, such as reading files or making network requests, without blocking the main thread. It uses an event loop and a thread pool to manage these operations efficiently.</p> </li> <li> <p>Examples of asynchronous tasks in JavaScript:</p> <ul> <li>I/O operations: Reading and writing files, making network requests, etc.</li> <li>Timers: <code>setTimeout</code>, <code>setInterval</code>, etc. JavaScript does not have built-in timers; it relies on the runtime environment (browser or Node.js) to provide this functionality.</li> </ul> </li> </ul>"},{"location":"nodejs/libuv-%26-async-io/#browser-runtime-architecture","title":"Browser Runtime Architecture","text":""},{"location":"nodejs/libuv-%26-async-io/#nodejs-runtime-architecture","title":"Node.js Runtime Architecture","text":""},{"location":"nodejs/libuv-%26-async-io/#simple-workflow-of-handling-async-tasks","title":"Simple Workflow of Handling Async Tasks","text":"<ol> <li>Main Thread (Synchronous):<ul> <li>Executes JavaScript code line by line.</li> <li>When it encounters async tasks, delegates them to the runtime.</li> </ul> </li> <li>Runtime Environment:<ul> <li>Handles async tasks separately (not on the main thread).</li> <li>Browser Runtime:<ul> <li>Handles tasks using browser APIs.</li> <li>Puts completed tasks in the callback queue/microtask queue.</li> </ul> </li> <li>Libuv:<ul> <li>Handles tasks using libuv's libraries and thread pool.</li> <li>Puts completed tasks in the callback queue/microtask queue.</li> </ul> </li> </ul> </li> <li>Event Loop:<ul> <li>Continuously checks if the main thread is idle.</li> <li>Moves callbacks from the queue to the main thread.</li> </ul> </li> </ol>"},{"location":"nodejs/libuv-%26-async-io/#simple-async-code-execution","title":"Simple Async Code Execution","text":"Async Code Execution<pre><code>const fs = require(\"fs\");\nconst https = require(\"https\");\n\nconsole.log(\"Start\");\n\nvar a = 25;\nvar b = 10;\n\nhttps.get(\"https://dummyjson.com/products/1\", (res) =&gt;\n    console.log(\"Data Fetched Successfully\")\n);\n\nsetTimeout(() =&gt; {\n    console.log(\"setTimeout called for 5 sec\");\n}, 5000);\n\nfs.readFile(__dirname + \"/file.txt\", \"utf-8\", (err, data) =&gt; {\n    if (err) throw err;\n    console.log(data);\n});\n\nfunction multiply(a, b) {\n    return a * b;\n}\n\nvar c = multiply(a, b);\nconsole.log(c);\n\nconsole.log(\"End\");\n</code></pre> Output<pre><code>Start\n250\nEND\nThis is file content.\nData Fetched Successfully\nsetTimeout called for 5 sec\n</code></pre>"},{"location":"nodejs/libuv-%26-async-io/#key-points","title":"Key Points","text":"<ul> <li> <p>Synchronous Code: <code>console.log(\"Start\")</code>, <code>multiply(a,b)</code> and <code>console.log(\"End\")</code> are executed synchronously, meaning they are executed one after the other.</p> </li> <li> <p>Asynchronous Code: <code>https.get</code>, <code>setTimeout</code>, and <code>fs.readFile</code> are executed asynchronously. They are delegated to the runtime (Node.js) for execution, allowing the main thread to continue executing other code without waiting for these tasks to complete.</p> </li> <li> <p>Async code executes tasks in parallel. In the example, file reading is the fastest task because it's a small local file and completes within a few milliseconds (20-30 ms). Another task is making a network request, which generally takes longer (around 100-200 ms). Finally, the <code>setTimeout</code> function is called after 5 seconds.</p> </li> <li> <p>However,changing <code>fs.readFile</code> in to <code>fs.readFileSync</code> function is synchronous, which means it blocks execution until the file is read and returns the file content directly (or throws an error). It does not accept a callback function.</p> </li> </ul> Async Code Execution<pre><code>fs.readFile(__dirname + \"/file.txt\", \"utf-8\", (err, data) =&gt; {\n    if (err) throw err;\n    console.log(data);\n});\n\n+ const data = fs.readFileSync(__dirname + \"/file.txt\", \"utf-8\");\n+ console.log(data);\n</code></pre> Output<pre><code>Hello World\nThis is file content.\n250\nEnd of sync execution\nData Fetched Successfully\nsetTimeout called for 5 sec\n</code></pre> <ul> <li>Callback Execution: Once the asynchronous tasks are completed, their callbacks are added to the callback queue. The event loop checks if the main thread is idle and moves the callbacks from the queue to the main thread for execution.</li> </ul> <p>This process ensures that JavaScript remains non-blocking and can handle multiple asynchronous tasks efficiently, even though it is single-threaded.</p>"},{"location":"nodejs/libuv-%26-async-io/#what-is-the-libuv-library","title":"What is the libuv library? \ud83d\udcda","text":"<ul> <li><code>libuv</code> is an open-source, cross-platform C library that provides support for asynchronous I/O operations. It was originally designed for Node.js.</li> <li>Features of libuv:<ul> <li>Event Loop</li> <li>Thread Pool</li> <li>Asynchronous I/O</li> <li>Cross-platform compatibility</li> </ul> </li> </ul>"},{"location":"nodejs/libuv-%26-async-io/#how-does-nodejs-utilize-libuv-to-achieve-async-io","title":"How does Node.js utilize libuv to achieve Async I/O? \ud83d\udee0\ufe0f","text":""},{"location":"nodejs/libuv-%26-async-io/#what-is-libuvs-thread-pool","title":"What is libuv's thread pool?","text":"<ul> <li>The thread pool is a collection of threads that can perform tasks concurrently. It allows Node.js to offload blocking I/O operations to separate threads, freeing up the main thread to continue executing JavaScript code.</li> <li>The thread pool is managed by libuv and uses a fixed number of threads (default is 4) to handle I/O operations. When a blocking I/O operation is requested, libuv assigns it to one of the available threads in the pool. Once the operation is complete, the result is passed back to the main thread through a callback function.</li> </ul>"},{"location":"nodejs/libuv-%26-async-io/#why-the-term-asynchronous-io","title":"Why the term \"Asynchronous I/O\"?","text":"<p>All I/O tasks are delegated to libuv, which executes them asynchronously using the thread pool. These tasks run in parallel with the main thread, hence the term Async I/O.</p>"},{"location":"nodejs/libuv-%26-async-io/#why-the-term-non-blocking-io","title":"Why the term \"Non-Blocking I/O\"?","text":"<p>Since all I/O tasks are delegated to libuv and run on the thread pool, the main thread remains unblocked. None of the I/O tasks block the main thread, hence the term Non-Blocking I/O.</p>"},{"location":"nodejs/libuv-%26-async-io/#why-is-non-blocking-io-advantageous","title":"Why is Non-Blocking I/O advantageous?","text":"<p>Blocking I/O tasks make the CPU sit idle until a response is received, wasting resources. Since JavaScript is single-threaded, unresolved requests would prevent other requests from being served (assuming only one server instance is running). Non-blocking I/O avoids this issue, improving efficiency and scalability.</p>"},{"location":"nodejs/libuv-%26-async-io/#further-reading","title":"Further Reading","text":"<ul> <li>Trust Issue with setTimeout</li> </ul>"},{"location":"nodejs/libuv-and-event-loop/","title":"Libuv and Event Loop","text":"<p>Node.js utilizes libuv for its asynchronous, non-blocking operations. Understanding libuv's management of the event loop, callback queues, and thread pool is key to grasping Node.js internals.</p> <p>User written synchronous Javascript code takes priority over async code that the runtime would like to execute. Only after the call stack is empty, the event loop comes into the picture.</p> <p>To explain in an easy-to-understand way, if the code that is currently running is in the synchronous segment, the callback of the asynchronous codes that have just been executed will not be called until all synchronous codes (or empty callstack) are executed.</p>"},{"location":"nodejs/libuv-and-event-loop/#core-components","title":"Core Components","text":"<ul> <li>Event Loop: The heart of Node.js's asynchronous processing. It allows Node.js to handle non-blocking I/O operations efficiently, despite JavaScript being single-threaded.</li> <li>Callback Queue: Stores callback functions corresponding to completed asynchronous operations. The event loop processes this queue when the call stack is empty.</li> <li>Thread Pool: Libuv uses a thread pool to handle more intensive tasks that would otherwise block the event loop. Examples include file system operations (like <code>fs.readFile</code>) or cryptographic functions.</li> </ul> <p>Tasks offloaded to libuv include:</p> <ul> <li>File system operations</li> <li>DNS lookups</li> <li>Network requests</li> </ul> <p></p>"},{"location":"nodejs/libuv-and-event-loop/#how-it-works","title":"How It Works","text":"<p>When an asynchronous task (e.g., reading a file) is initiated:</p> <ol> <li>The task is offloaded to libuv.</li> <li>Libuv interacts with the operating system (OS) to perform the task (e.g., read data from disk).</li> <li>The V8 JavaScript engine continues executing other JavaScript code without waiting.</li> <li>Once the OS completes the task and returns data to libuv, libuv places the associated callback function into the appropriate callback queue.</li> <li>The event loop picks up this callback from the queue (when the call stack is free) and pushes it onto the call stack for execution.</li> </ol> <p>This mechanism ensures Node.js remains non-blocking, even with many concurrent operations. Libuv maintains separate queues for different types of tasks (timers, I/O, <code>setImmediate</code>) to manage priority.</p>"},{"location":"nodejs/libuv-and-event-loop/#inside-the-event-loop-phases","title":"Inside the Event Loop: Phases","text":"<p>The event loop processes tasks in a specific order through several phases:</p> <p></p> <ol> <li>Timers Phase: Executes callbacks scheduled by <code>setTimeout()</code> and <code>setInterval()</code>.</li> <li>Poll Phase:<ul> <li>Retrieves new I/O events.</li> <li>Executes I/O-related callbacks (e.g., network requests, file system operations).</li> <li>If the event loop is idle and there are no scripts to execute, it will block here, waiting for new events.</li> </ul> </li> <li>Check Phase: Executes callbacks scheduled by <code>setImmediate()</code>. These run immediately after the Poll phase completes.</li> <li>Close Callbacks Phase: Executes close event callbacks (e.g., <code>socket.on('close', ...)</code>).</li> </ol> <p>Among the main phrases, the microtask queue will be called, inside it there are 2 more phrases:</p> <p>Before transitioning to each main phase, the event loop processes microtasks.</p> <ul> <li><code>process.nextTick()</code> callbacks: These have the highest priority among microtasks and are executed immediately after the current operation completes, before the event loop continues.</li> <li>Promise callbacks (e.g., <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>): These are also microtasks and are executed after <code>process.nextTick()</code> callbacks but before any other phase.</li> </ul> <p>Timer, I/O, check, close are components of libuv, microtask queue is not components of libuv.</p> <p></p>"},{"location":"nodejs/libuv-and-event-loop/#execution-sequence","title":"Execution Sequence","text":"<ol> <li> <p>Microtask Queue</p> <ul> <li>Process.nextTick Queue: Callbacks registered with <code>process.nextTick()</code> execute first</li> <li>Promise Queue: Then Promise callbacks (<code>.then()</code>, <code>.catch()</code>, etc.) execute</li> </ul> </li> <li> <p>Timer Queue</p> <ul> <li>Callbacks scheduled by <code>setTimeout()</code> and <code>setInterval()</code> execute</li> </ul> </li> <li> <p>Microtask Queue (again)</p> <ul> <li>If new microtasks were added, they execute now (nextTick, then Promises)</li> </ul> </li> <li> <p>I/O Queue</p> <ul> <li>Callbacks from I/O operations (file system, network, etc.) execute</li> </ul> </li> <li> <p>Microtask Queue (again)</p> <ul> <li>Any newly added microtasks execute</li> </ul> </li> <li> <p>Check Queue</p> <ul> <li>Callbacks registered with <code>setImmediate()</code> execute</li> </ul> </li> <li> <p>Microtask Queue (again)</p> <ul> <li>Any newly added microtasks execute</li> </ul> </li> <li> <p>Close Queue</p> <ul> <li>Close event callbacks execute (e.g., <code>socket.on('close', ...)</code>)</li> </ul> </li> <li> <p>Microtask Queue (final check)</p> <ul> <li>Any final microtasks execute</li> </ul> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#loop-continuation","title":"Loop Continuation","text":"<p>After completing all the steps above: - If there are new callbacks added to any queue, the Event Loop continues with another cycle - If there are no callbacks left to execute, the Event Loop exits</p>"},{"location":"nodejs/libuv-and-event-loop/#idle-behavior","title":"Idle Behavior","text":"<p>If the event loop is idle and there are no scripts to execute, it will block in the poll phase, waiting for new events. This is an important optimization:</p> <ul> <li>The event loop doesn't waste CPU cycles when nothing needs to be processed</li> <li>It efficiently waits for new I/O events, timers to expire, or callbacks to be scheduled</li> <li>Once new events arrive, the event loop \"wakes up\" and resumes processing</li> </ul> <p>Key Insight</p> <p>The microtask queue is checked and emptied between each phase of the Event Loop. This means microtasks have higher priority and can delay other operations if they keep adding new microtasks.</p> <p>This prioritization ensures that certain types of asynchronous operations (particularly nextTick &amp; Promises callbacks) complete as soon as possible, making the Node.js Event Loop both efficient and predictable.</p>"},{"location":"nodejs/libuv-and-event-loop/#microtask-queue-in-depth","title":"Microtask Queue In Depth","text":""},{"location":"nodejs/libuv-and-event-loop/#nexttick-queue","title":"nextTick Queue","text":"<p>The <code>process.nextTick()</code> method adds callbacks to the nextTick queue, which has priority over the Promise queue:</p> <ul> <li>Callbacks in the nextTick queue are executed until the queue is completely empty</li> <li>If new callbacks are added to the nextTick queue during execution (via <code>process.nextTick()</code>), they will be executed in the same phase in FIFO order</li> <li>The event loop will not proceed to the next phase until the nextTick queue is empty</li> </ul> <p>Consider this example:</p> <pre><code>process.nextTick(() =&gt; {\n  console.log('Next tick 1');\n  process.nextTick(() =&gt; console.log('Next tick 1.1'));\n});\n\nsetTimeout(() =&gt; console.log('Set timeout 1'));\n</code></pre> <p>The output will be: <pre><code>Next tick 1\nNext tick 1.1\nSet timeout 1\n</code></pre></p> <p>This demonstrates that even though the callback 'Next tick 1.1' was added during execution, it still runs before the setTimeout callback.</p>"},{"location":"nodejs/libuv-and-event-loop/#promise-queue","title":"\ud83e\udd1d Promise Queue","text":"<p>Promises are also part of the microtask queue but are processed after the nextTick queue:</p> <ul> <li>Callbacks from resolved Promises (using <code>.then()</code> or <code>.catch()</code>) are added to the Promise queue</li> <li>Similar to nextTick queue, if new Promise callbacks are added during execution, they will be processed in the same phase</li> </ul> <p>Here's a comprehensive example:</p> <pre><code>process.nextTick(() =&gt; console.log('nextTick: 1'));\n\nprocess.nextTick(() =&gt; {\n  console.log('nextTick: 2');\n  Promise.resolve().then(() =&gt; console.log('nextTick-Promise: 2.1'));\n  process.nextTick(() =&gt; console.log('nextTick-nextTick: 2.2'));\n});\n\nprocess.nextTick(() =&gt; console.log('nextTick: 3'));\n\nPromise.resolve().then(() =&gt; console.log('Promise: 1'));\n\nPromise.resolve().then(() =&gt; {\n  console.log('Promise: 2');\n  Promise.resolve().then(() =&gt; console.log('Promise-promise: 2.1'));\n  process.nextTick(() =&gt; console.log('Promise-nextTick: 2.2'));\n});\n\nPromise.resolve().then(() =&gt; console.log('Promise: 3'));\n\nsetTimeout(() =&gt; {\n  console.log('Timeout: 1');\n}, 0);\n\nconsole.log('Console 1');\n</code></pre> Output<pre><code>Console 1\nnextTick: 1\nnextTick: 2\nnextTick: 3\nnextTick-nextTick: 2.2\nPromise: 1\nPromise: 2\nPromise: 3\nnextTick-Promise: 2.1\nPromise-promise: 2.1\nPromise-nextTick: 2.2\nTimeout: 1\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#execution-process-explained","title":"Execution Process Explained","text":"<ol> <li>Synchronous code runs first (<code>Console 1</code>)</li> <li>Event loop begins processing async code:<ul> <li>First, all nextTick callbacks are processed:<ul> <li>Prints <code>nextTick: 1</code></li> <li>Prints <code>nextTick: 2</code> and adds new callbacks to both Promise and nextTick queues</li> <li>Prints <code>nextTick: 3</code></li> <li>Continues processing nextTick queue until empty (prints <code>nextTick-nextTick: 2.2</code>)</li> </ul> </li> <li>Then Promise callbacks are processed:<ul> <li>Prints <code>Promise: 1</code></li> <li>Prints <code>Promise: 2</code> and adds new callbacks to Promise and nextTick queues</li> <li>Prints <code>Promise: 3</code></li> <li>Continues with remaining Promise callbacks (prints <code>nextTick-Promise: 2.1</code>, <code>Promise-promise: 2.1</code>)</li> </ul> </li> <li>Returns to nextTick queue since it has a new callback (prints <code>Promise-nextTick: 2.2</code>)</li> <li>Only after both microtask queues are empty does it proceed to Timer queue</li> <li>Prints `Timeout: 1</li> </ul> </li> </ol> <p>Important Note</p> <p>If callbacks continually add new items to the nextTick or Promise queues, the event loop can get stuck in the microtask phase, preventing it from moving to other phases such as timers or I/O operations.</p> <p>Best Practice</p> <p>There are two main reasons to use <code>process.nextTick</code>:</p> <ol> <li>To allow users to handle errors, clean up unneeded resources, or retry requests before the event loop continues</li> <li>To allow a callback to run after the call stack has unwound but before the event loop continues processing</li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#io-queue-and-timer-queue-interactions","title":"I/O Queue and Timer Queue Interactions","text":"<p>Most async methods in Node.js built-in modules (like <code>fs</code>, <code>http</code>, etc.) push their callbacks into the I/O queue. According to the event loop execution order, the I/O queue has a lower priority than the Timer queue. However, there are some interesting behaviors to note:</p> <pre><code>const fs = require('fs');\n\nfs.readFile(__filename, () =&gt; console.log('Readfile 1'));\n\nsetTimeout(() =&gt; console.log('Timeout: 1'), 1000);\nsetTimeout(() =&gt; console.log('Timeout: 2'), 0);\nsetTimeout(() =&gt; console.log('Timeout: 3'), 0);\n</code></pre> Output<pre><code>&lt;!-- Round 1 --&gt;\nTimeout: 2\nTimeout: 3\nReadfile 1\nTimeout: 1\n&lt;!-- Round 2 --&gt;\nReadfile 1\nTimeout: 2\nTimeout: 3\nTimeout: 1\n&lt;!-- Round 3 --&gt;\nTimeout: 2\nTimeout: 3\nReadfile 1\nTimeout: 1\n&lt;!-- Round 4 --&gt;\nReadfile 1\nTimeout: 2\nTimeout: 3\nTimeout: 1\n</code></pre> <p>When running this code multiple times, you may notice that the execution order between <code>Timeout: 2</code>, <code>Timeout: 3</code>, and <code>Readfile 1</code> is not consistent. Why </p>"},{"location":"nodejs/libuv-and-event-loop/#important-note-on-settimeout0","title":"Important Note on setTimeout(0)","text":"<p>When using <code>setTimeout</code> with a delay of 0ms, it doesn't guarantee immediate execution. The mechanism works like this:</p> <ol> <li>The actual minimum delay for <code>setTimeout</code> is approximately 1 millisecond (implementation detail in the libuv library)</li> <li>The timer's callback is only pushed to the Timer queue after this delay has passed</li> <li>I/O operations have varying completion times</li> </ol> <p>This leads to two possible scenarios:</p> <ol> <li>Fast I/O Operation: If the I/O operation completes before the 1ms delay, and the event loop reaches the I/O phase before the Timer phase, <code>Readfile 1</code> will be printed first</li> <li>Minimum Timer Delay Passed: If by the time the event loop starts, the 1ms delay has passed, the Timer queue callbacks will execute first, then the I/O queue callbacks</li> </ol> <p>To demonstrate the guaranteed order (Timer queue before I/O queue), we can add CPU-intensive work to ensure the minimum timer delay has passed:</p> <pre><code>const fs = require('fs');\n\nfs.readFile(__filename, (err, data) =&gt; { console.log('Readfile 1') });\n\nsetTimeout(() =&gt; console.log('Timeout: 1'), 1000);\nsetTimeout(() =&gt; console.log('Timeout: 2'), 0);\nsetTimeout(() =&gt; console.log('Timeout: 3'), 0);\n\nfor (let index = 0; index &lt; 20000000; index++) {}\n</code></pre> <p>Expected Output<pre><code>Timeout: 2\nTimeout: 3\nReadfile 1\nTimeout: 1\n</code></pre> With this CPU-intensive loop, the minimum timer delay will have passed by the time the event loop starts processing, ensuring that the Timer queue callbacks execute before the I/O queue callbacks.</p> <p>This example proves that under ideal conditions (when timers have had enough time to be added to the Timer queue), the I/O queue will execute after the Timer queue as expected in the event loop order.</p>"},{"location":"nodejs/libuv-and-event-loop/#io-polling-phase","title":"I/O Polling Phase","text":"<p>Between the I/O queue and Check queue phases, there's a critical stage called I/O Polling. During this phase, Node.js (through libuv) checks whether async tasks have completed and, if so, pushes their callbacks into the I/O queue.</p> <p>Consider this example:</p> <pre><code>const fs = require('fs');\n\nsetTimeout(() =&gt; console.log('Timeout: 1'), 0);\n\nfs.readFile(__filename, () =&gt; console.log('Readfile: 1'));\n\nsetImmediate(() =&gt; console.log('Immediate: 1'));\n\nfor (let index = 0; index &lt; 20000000; index++) {}\n</code></pre> <p>Based on our understanding of the event loop flow and with the CPU-intensive loop, we might expect the output to be: <pre><code>Timeout: 1\nReadfile: 1\nImmediate: 1\n</code></pre></p> <p>However, the actual output is often different: <pre><code>Timeout: 1\nImmediate: 1\nReadfile: 1\n</code></pre></p> <p>Here's what's happening:</p> <ol> <li>When control reaches the I/O phase for the first time, there are no callbacks in the I/O queue yet</li> <li>During the I/O polling process, Node.js checks if <code>fs.readFile</code> has completed</li> <li>Even if <code>fs.readFile</code> completes during this check, its callback is pushed to the I/O queue after the current phase has already been passed</li> <li>Control then moves to the Check queue, executing the <code>setImmediate</code> callback</li> <li>In the next iteration of the event loop, the I/O phase processes the pending <code>fs.readFile</code> callback</li> </ol> <p>This explains why <code>Readfile: 1</code> is printed last, despite I/O having higher priority than the Check queue in the event loop order.</p>"},{"location":"nodejs/libuv-and-event-loop/#check-queue","title":"Check Queue","text":"<p>The Check queue handles callbacks registered with <code>setImmediate()</code>. Like other phases, during execution of Check queue callbacks, the microtask queues are processed between each callback:</p> <pre><code>const fs = require('fs');\n\nfs.readFile(__filename, (err, data) =&gt; {\n  console.log('Readfile 1');\n  setImmediate(() =&gt; {\n    console.log('Immediate 1');\n    process.nextTick(() =&gt; console.log('nextTick 1'));\n  });\n  setImmediate(() =&gt; console.log('Immediate 2'));\n});\n\nsetTimeout(() =&gt; console.log('Timeout: 1'), 0);\n\nfor (let index = 0; index &lt; 10e7; index++) {}\n</code></pre> <p>The output will be: <pre><code>Timeout: 1\nReadfile 1\nImmediate 1\nnextTick 1\nImmediate 2\n</code></pre></p> <p>This demonstrates that even though the <code>nextTick</code> callback is added after the second <code>setImmediate</code> callback, it executes first because the microtask queue is processed after each Check queue callback.</p>"},{"location":"nodejs/libuv-and-event-loop/#close-queue","title":"Close Queue","text":"<p>The Close queue is the final queue in the event loop and handles callbacks related to close events from asynchronous operations. For example:</p> <pre><code>const fs = require('fs');\n\nconst readableStream = fs.createReadStream(__filename);\nreadableStream.close();\n\nreadableStream.on('close', () =&gt; {\n  console.log('readableStream close event callback');\n});\n\nsetImmediate(() =&gt; console.log('Immediate: 1'));\n\nsetTimeout(() =&gt; console.log('Timeout: 1'), 0);\n\nfor (let index = 0; index &lt; 10e7; index++) {}\n</code></pre> <p>The output follows our expected event loop order: <pre><code>Timeout: 1\nImmediate: 1\nreadableStream close event callback\n</code></pre></p> <p>This confirms that the Close queue is processed last in the event loop cycle, after all other queues.</p>"},{"location":"nodejs/libuv-and-event-loop/#q1-event-loop-execution-order","title":"Q1: Event Loop Execution Order","text":"<pre><code>const fs = require('fs');\n\nconst a = 100;\n\nsetImmediate(() =&gt; console.log(\"setImmediate\"));\n\nfs.readFile(\"./file.txt\", \"utf8\", () =&gt; {\n  console.log(\"File reading callback\");\n});\n\nsetTimeout(() =&gt; console.log(\"Timer expired\"), 0);\n\nfunction printA() {\n  console.log(\"a=\", a);\n}\n\nprintA();\nconsole.log(\"Last line of the code\");\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#output-analysis","title":"Output Analysis:","text":"Output<pre><code>a= 100\nLast line of the code\nTimer expired\nsetImmediate\nFile reading callback\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#explanation","title":"Explanation:","text":"<ol> <li> <p>Synchronous Code Execution:</p> <ul> <li><code>printA()</code> executes immediately, logging: <code>a= 100</code></li> <li>The last <code>console.log</code> executes, logging: <code>Last line of the code</code></li> </ul> </li> <li> <p>Event Loop Begins:</p> <ul> <li>Microtask Queue: Empty in this example</li> <li>Timer Queue: <code>setTimeout</code> callback executes, logging: <code>Timer expired</code></li> <li>I/O Polling &amp; Queue: The <code>fs.readFile</code> operation is checked, but likely hasn't completed yet</li> <li>Check Queue: <code>setImmediate</code> callback executes, logging: <code>setImmediate</code></li> <li>I/O Queue (Next Iteration): When the file reading completes, its callback executes, logging: <code>File reading callback</code></li> </ul> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#q2-event-loop-with-promise-and-nexttick","title":"Q2: Event Loop with Promise and nextTick","text":"<pre><code>const fs = require('fs');\n\nconst a = 100;\n\nsetImmediate(() =&gt; console.log(\"setImmediate\"));\n\nPromise.resolve().then(() =&gt; console.log(\"Promise resolved\"));\n\nfs.readFile(\"./file.txt\", \"utf8\", () =&gt; {\n  console.log(\"File reading callback\");\n});\n\nsetTimeout(() =&gt; console.log(\"Timer expired\"), 0);\n\nprocess.nextTick(() =&gt; console.log('process.nextTick()'));\n\nfunction printA() {\n  console.log(\"a=\", a);\n}\n\nprintA();\nconsole.log(\"Last line of the code\");\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#output-analysis_1","title":"Output Analysis:","text":"Output<pre><code>a= 100\nLast line of the code\nprocess.nextTick()\nPromise resolved\nTimer expired\nsetImmediate\nFile reading callback\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#explanation_1","title":"Explanation:","text":"<ol> <li> <p>Synchronous Code Execution:</p> <ul> <li><code>printA()</code> executes immediately, logging: <code>a= 100</code></li> <li>The last <code>console.log</code> executes, logging: <code>Last line of the code</code></li> </ul> </li> <li> <p>Event Loop Begins:</p> <ul> <li>Microtask Queue:<ul> <li>First, <code>nextTick</code> callbacks execute: <code>process.nextTick()</code></li> <li>Then, Promise callbacks execute: <code>Promise resolved</code></li> </ul> </li> <li>Timer Queue: <code>setTimeout</code> callback executes, logging: <code>Timer expired</code></li> <li>I/O Polling &amp; Queue: The <code>fs.readFile</code> operation is checked, but likely hasn't completed yet</li> <li>Check Queue: <code>setImmediate</code> callback executes, logging: <code>setImmediate</code></li> <li>I/O Queue (Next Iteration): When the file reading completes, its callback executes, logging: <code>File reading callback</code></li> </ul> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#q3-complex-event-loop-with-nested-callbacks","title":"Q3: Complex Event Loop with Nested Callbacks","text":"<pre><code>const fs = require('fs');\n\nsetImmediate(() =&gt; console.log(\"setImmediate\"));\n\nsetTimeout(() =&gt; console.log(\"1st Timer expired\"), 0);\n\nPromise.resolve().then(() =&gt; console.log(\"Promise resolved\"));\n\nfs.readFile(\"./file.txt\", \"utf8\", () =&gt; {\n  setTimeout(() =&gt; console.log(\"2nd Timer expired\"), 0);\n\n  process.nextTick(() =&gt; console.log('2nd process.nextTick()'));\n\n  setImmediate(() =&gt; console.log(\"2nd setImmediate\"));\n\n  console.log(\"File reading callback\");\n});\n\nprocess.nextTick(() =&gt; console.log('process.nextTick()'));\n\nconsole.log(\"Last line of the code\");\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#output-analysis_2","title":"\ud83d\udd0d Output Analysis:","text":"Output<pre><code>Last line of the code\nprocess.nextTick()\nPromise resolved\n1st Timer expired\nsetImmediate\nFile reading callback\n2nd process.nextTick()\n2nd setImmediate\n2nd Timer expired\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#explanation_2","title":"Explanation:","text":"<p>The <code>fs.readFile</code> callback itself executes as part of the Poll phase (handling I/O events). Once that callback finishes:</p> <ol> <li> <p>Microtasks from <code>fs.readFile</code> callback: <code>2nd process.nextTick()</code> runs immediately after the \"File reading callback\" log.</p> </li> <li> <p>Event Loop Continues to Check Phase (Current Cycle): The event loop doesn't start a completely new cycle from Timers immediately. It first proceeds to the Check phase of the current event loop cycle. This is where callbacks scheduled by <code>setImmediate</code> are executed. So, the \"2nd setImmediate\" (which was scheduled inside the <code>fs.readFile</code> callback) runs here.</p> </li> <li> <p>Timers Phase (Next Cycle): Only after the current cycle's Poll phase, its microtasks, and its Check phase are complete will the event loop begin a new cycle. The \"2nd Timer expired\" (which was also scheduled inside fs.readFile) will be processed in the Timers phase of this next event loop cycle.</p> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#q4-nested-nexttick-and-promise-chain","title":"Q4: Nested nextTick and Promise Chain","text":"<pre><code>const fs = require('fs');\n\nsetImmediate(() =&gt; console.log(\"setImmediate\"));\n\nsetTimeout(() =&gt; console.log(\"Timer expired\"), 0);\n\nPromise.resolve().then(() =&gt; console.log(\"Promise resolved\"));\n\nfs.readFile(\"./file.txt\", \"utf8\", () =&gt; {\n  console.log(\"File reading callback\");\n});\n\nprocess.nextTick(() =&gt; {\n  process.nextTick(() =&gt; console.log('Inner process.nextTick()'));\n  console.log('process.nextTick()');\n});\n\nconsole.log(\"Last line of the code\");\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#output-analysis_3","title":"\ud83d\udd0d Output Analysis:","text":"Output<pre><code>Last line of the code\nprocess.nextTick()\nInner process.nextTick()\nPromise resolved\nTimer expired\nsetImmediate\nFile reading callback\n</code></pre>"},{"location":"nodejs/libuv-and-event-loop/#explanation_3","title":"Explanation:","text":"<ol> <li>Synchronous Code Execution:</li> <li> <p>The code logs: <code>Last line of the code</code></p> </li> <li> <p>Event Loop Begins:</p> <ul> <li>Microtask Queue:<ul> <li>First <code>process.nextTick()</code> callback executes, logging: <code>process.nextTick()</code></li> <li>This schedules an inner nextTick, which executes immediately since we're still in the microtask phase: <code>Inner process.nextTick()</code></li> <li>Then Promise callback executes: <code>Promise resolved</code></li> </ul> </li> <li>Timer Queue: <code>Timer expired</code> logs</li> <li>I/O Polling &amp; Queue: File reading checked but not yet complete</li> <li>Check Queue: <code>setImmediate</code> logs</li> <li>I/O Queue (Next Iteration): When the file reading completes, its callback executes, logging: <code>File reading callback</code></li> </ul> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#key-takeaways-from-these-examples","title":"Key Takeaways from These Examples","text":"<ol> <li> <p>Execution Order Priority:</p> <ul> <li>Synchronous code executes first</li> <li>Microtasks (nextTick then Promises) execute between each phase of the event loop</li> <li>Timer callbacks execute before I/O callbacks (under ideal conditions)</li> <li>setImmediate callbacks execute after I/O operations</li> </ul> </li> <li> <p>Nested Callbacks:</p> <ul> <li>When callbacks contain their own async operations, these are scheduled for future event loop phases</li> <li>The microtask queue is always checked after each callback completes, before moving to the next phase</li> </ul> </li> <li> <p>nextTick Behavior:</p> <ul> <li><code>process.nextTick()</code> callbacks can create a chain of operations that all execute before moving to the next phase</li> <li>This can potentially block the event loop if not used carefully</li> </ul> </li> </ol>"},{"location":"nodejs/libuv-and-event-loop/#further-reading","title":"Further Reading","text":"<ul> <li>Event Loop and the Big Picture</li> <li>The Node.js Event Loop</li> <li>Event loop Design Overview</li> </ul>"},{"location":"nodejs/module-export-%26-require/","title":"Module Export &amp; Require","text":"<p>Splitting code into multiple files keeps a Node.js project organized and maintainable. In this chapter, we'll explore how to share functionality between files using CommonJS (CJS) and ES Modules (ESM).</p>"},{"location":"nodejs/module-export-%26-require/#commonjs-modules-cjs","title":"CommonJS Modules (CJS)","text":""},{"location":"nodejs/module-export-%26-require/#problem","title":"Problem","text":"<p>You have two files : <code>app.js</code> and <code>xyz.js</code>\u2014 and want them to interact. How can <code>app.js</code> execute code or use functions from <code>xyz.js</code>?</p>"},{"location":"nodejs/module-export-%26-require/#solution","title":"Solution","text":"<p>Use <code>require()</code> to load one module into another and <code>module.exports</code> to expose functionality.</p>"},{"location":"nodejs/module-export-%26-require/#1-requiring-a-module","title":"1. Requiring a Module","text":"app.js<pre><code>const xyzModule = require('./xyz'); // Load xyz.js\nconsole.log(\"Running app.js\");\n</code></pre> xyz.js<pre><code>console.log(\"xyz.js module is being loaded\");\n// By default, nothing is exported here.\n</code></pre> <p>Running <code>node app.js</code> logs: <pre><code>xyz.js module is being loaded\nRunning app.js\n</code></pre></p>"},{"location":"nodejs/module-export-%26-require/#2-exporting-a-single-function","title":"2. Exporting a Single Function","text":"sum.js<pre><code>function calculateSum(a, b) {\n  return a + b;\n}\nmodule.exports = calculateSum;\n</code></pre> app.js<pre><code>const sum = require('./sum'); // Load the sum module\nconsole.log(\"Sum:\", sum(5, 3)); // Sum: 8\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#3-exporting-multiple-items","title":"3. Exporting Multiple Items","text":"sum.js<pre><code>const x = \"Exported value\";\nfunction calculateSum(a, b) { return a + b; }\nmodule.exports = { x, calculateSum };\n</code></pre> app.js<pre><code>const { x, calculateSum } = require('./sum');\nconsole.log(x);                  // Exported value\nconsole.log(calculateSum(10, 5)); // 15\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#4-destructuring-imports-common-pattern","title":"4. Destructuring Imports (Common Pattern)","text":"app.js<pre><code>const { x, calculateSum } = require('./sum');\n</code></pre> <p>This cleanly pulls out only what you need.</p>"},{"location":"nodejs/module-export-%26-require/#5-folder-modules-indexjs","title":"5. Folder Modules (index.js)","text":"<p>Structure: <pre><code>project/\n\u251c\u2500 app.js\n\u2514\u2500 utils/\n   \u251c\u2500 index.js\n   \u251c\u2500 sum.js\n   \u2514\u2500 multiply.js\n</code></pre></p> utils/sum.js<pre><code>function sum(a, b) {\n  return a + b;\n}\nmodule.exports = sum;\n</code></pre> utils/multiply.js<pre><code>module.exports = (a, b) =&gt; a * b;\n</code></pre> utils/index.js<pre><code>const sum = require('./sum');\nconst multiply = require('./multiply');\nmodule.exports = { sum, multiply };\n</code></pre> app.js<pre><code>const { sum, multiply } = require('./utils');\nconsole.log(sum(2, 3));      // 5\nconsole.log(multiply(2, 3)); // 6\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#6-requiring-json-builtin-modules","title":"6. Requiring JSON &amp; Built\u2011in Modules","text":"data.json<pre><code>{\n  \"name\": \"MyApp\",\n  \"version\": \"1.0.0\"\n}\n</code></pre> app.js<pre><code>const config = require('./data.json');\nconsole.log(config.name); // MyApp\n\nconst fs   = require('fs');\nconst path = require('path');\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#es-modules-esm","title":"ES Modules (ESM)","text":"<p>ESM is the modern JavaScript module system. To enable it in Node.js, add <code>\"type\": \"module\"</code> to your <code>package.json</code> or use the <code>.mjs</code> extension.</p> <p>ESM Module</p> <ul> <li>Newer version of Node.</li> </ul> package.json<pre><code>{\n  \"name\": \"my-app\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\"\n}\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#1-exporting","title":"1. Exporting","text":"mathUtils.js<pre><code>export const PI = 3.14159;\nexport function add(a, b) { return a + b; }\nexport default 2.718;\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#2-importing","title":"2. Importing","text":"main.js<pre><code>import E, { PI, add } from './mathUtils.js';\nconsole.log(PI);     // 3.14159\nconsole.log(add(2,3)); // 5\nconsole.log(E);      // 2.718\n</code></pre>"},{"location":"nodejs/module-export-%26-require/#key-differences-cjs-vs-esm","title":"Key Differences: CJS vs. ESM","text":"Feature CommonJS (CJS) ES Modules (ESM) Loading Synchronous: <code>require()</code> blocks until the module is loaded Asynchronous: <code>import</code> can load in parallel without blocking Strict Mode Non-strict by default Always strict\u2014enforces better parsing and error handling <p>Overall, ES Modules offer non\u2011blocking loading and built\u2011in strict mode, making your code more efficient and reliable.</p>"},{"location":"nodejs/module-export-%26-require/#additional-patterns","title":"Additional Patterns","text":"<ul> <li>Alternative CJS Exports <pre><code>module.exports.x = x;\nmodule.exports.calculateSum = calculateSum;\n</code></pre></li> <li>Import All <pre><code>import * as utils from './utils.js';\n</code></pre></li> <li>Default-only Export <pre><code>export default function() { /*\u2026*/ }\n</code></pre></li> </ul>"},{"location":"nodejs/module-export-%26-require/#recap","title":"Recap","text":"<ul> <li>CommonJS uses <code>require()</code> and <code>module.exports</code>.</li> <li>ES Modules use <code>import</code> and <code>export</code>.</li> <li>Organize with folders, <code>index.js</code>, or JSON imports.</li> <li>Choose CJS for legacy, ESM for modern codebases.</li> </ul>"},{"location":"nodejs/nodejs-repl/","title":"Node.js REPL: Read, Evaluate, Print, Loop","text":"<p>Ever needed to prototype or debug JavaScript without creating files? The Node.js REPL lets you:</p> <ul> <li>Instantly run snippets  </li> <li>Explore APIs interactively  </li> <li>Debug in real time  </li> </ul> <p>It operates in four steps:</p> <ol> <li>Read your input  </li> <li>Evaluate the code  </li> <li>Print the result  </li> <li>Loop back for more  </li> </ol> <p></p> <p>Prerequisites</p> <ul> <li>Node.js installed  </li> </ul>"},{"location":"nodejs/nodejs-repl/#getting-started","title":"Getting Started","text":""},{"location":"nodejs/nodejs-repl/#start-exit","title":"Start &amp; Exit","text":"<pre><code>$ node\n</code></pre> <p>You'll see: <pre><code>Welcome to Node.js v22.14.0.\nType \".help\" for more information.\n&gt;\n</code></pre></p> <p>Exit by:</p> <ul> <li><code>.exit</code></li> <li>Ctrl+D (once)</li> <li>Ctrl+C (twice)</li> </ul>"},{"location":"nodejs/nodejs-repl/#try-simple-expressions","title":"Try Simple Expressions","text":"<pre><code>&gt; 5 + 6\n11\n&gt; \"Hello\" + \" World\"\n'Hello World'\n&gt; 1 === \"1\"\nfalse\n</code></pre>"},{"location":"nodejs/nodejs-repl/#variables-functions","title":"Variables &amp; Functions","text":"<pre><code>&gt; let x = 10\nundefined\n&gt; x * 2\n20\n\n&gt; function sum(a, b) {\n...   return a + b;\n... }\nundefined\n&gt; sum(3, 4)\n7\n</code></pre>"},{"location":"nodejs/nodejs-repl/#special-_-variable","title":"Special \u201c_\u201d Variable","text":"<p>The underscore <code>_</code> stores the last result:</p> <pre><code>&gt; 2 + 3\n5\n&gt; _\n5\n</code></pre>"},{"location":"nodejs/nodejs-repl/#multiline-mode","title":"Multi\u2011line Mode","text":"<p>When you enter an incomplete statement, REPL switches to multi\u2011line:</p> <pre><code>&gt; if (true) {\n...   console.log('Hi');\n... }\nHi\n</code></pre> <p></p>"},{"location":"nodejs/nodejs-repl/#repl-shortcuts-commands","title":"REPL Shortcuts &amp; Commands","text":"<p>Shortcuts:</p> <ul> <li>Up/Down arrows: Browse history  </li> <li>Tab: Auto\u2011complete  </li> <li>Ctrl+C: Cancel current input  </li> <li>Ctrl+D: Exit  </li> </ul> <p>Built\u2011in commands (start with <code>.</code>):</p> Command Description .help Show help .break/.clear Abort multi\u2011line input .editor Enter editor mode .save  Save session to <code>&lt;file&gt;</code> .load  Load and run <code>&lt;file&gt;</code> .exit Exit REPL"},{"location":"nodejs/nodejs-repl/#save-load-example","title":"Save &amp; Load Example","text":"<pre><code>&gt; let a = 5, b = 10\n&gt; .save session.js\nSession saved to: session.js\n</code></pre> <p>In a new session: <pre><code>$ node\n&gt; .load session.js\n</code></pre></p>"},{"location":"nodejs/nodejs-repl/#summary","title":"Summary","text":"<ul> <li>Launch with <code>node</code>.  </li> <li>Use REPL for quick feedback.  </li> <li>Leverage <code>.help</code>, <code>.save</code>, <code>.load</code>.  </li> <li>Navigate with arrows and Tab.  </li> <li>Harness <code>_</code> for the last result.  </li> </ul>"},{"location":"nodejs/nodejs-repl/#global-objects-in-nodejs","title":"Global Objects in Node.js","text":""},{"location":"nodejs/nodejs-repl/#what-is-the-global-object","title":"What Is the Global Object?","text":"<p>In JavaScript, the global object holds values available everywhere. - Browsers: <code>window</code> - Node.js: <code>global</code> or standardized <code>globalThis</code></p>"},{"location":"nodejs/nodejs-repl/#browser-vs-nodejs","title":"Browser vs. Node.js","text":"<p>Browser: <pre><code>window === this          // true\nwindow.setTimeout === setTimeout // true\n</code></pre></p> <p>Node.js: <pre><code>global.setTimeout === setTimeout // true\nthis                              // {} (module scope)\nglobalThis === global            // true\n</code></pre></p>"},{"location":"nodejs/nodejs-repl/#common-globals-in-nodejs","title":"Common Globals in Node.js","text":"<pre><code>// Timers\nsetTimeout(fn, ms)\nsetInterval(fn, ms)\nclearTimeout(id)\n\n// Console\nconsole.log()\nconsole.error()\nconsole.time(label); console.timeEnd(label)\n\n// Buffer\nconst buf = Buffer.from('hello')\n\n// Process\nprocess.env\nprocess.argv\nprocess.cwd()\nprocess.exit(0)\n\n// Module info\n__dirname\n__filename\n</code></pre>"},{"location":"nodejs/nodejs-repl/#module-scope-vs-global-scope","title":"Module Scope vs. Global Scope","text":"<p>Each file is its own module. Top\u2011level <code>let</code>, <code>const</code>, or <code>var</code> stay local:</p> moduleA.js<pre><code>// moduleA.js\nconst local = 'module-only';\nglobal.globalVar = 'truly global';\n</code></pre> anotherFile.js<pre><code>console.log(local);       // ReferenceError\nconsole.log(globalVar);   // 'truly global'\n</code></pre> <p>To share, attach to <code>global</code> or export via <code>module.exports</code>.</p>"},{"location":"nodejs/nodejs-repl/#using-globalthis","title":"Using globalThis","text":"<p><code>globalThis</code> works uniformly across environments:</p> <pre><code>globalThis.myValue = 42;\nconsole.log(globalThis.myValue); // 42\n</code></pre>"},{"location":"nodejs/nodejs-repl/#best-practices","title":"Best Practices","text":"<ul> <li>Avoid polluting the global namespace.  </li> <li>Prefer module exports/imports over globals.  </li> <li>Use <code>process.env</code> for configuration.  </li> <li>Reserve globals for universal utilities (e.g., polyfills).</li> </ul>"},{"location":"nodejs/thread-pool-in-libuv/","title":"Thread pool in libuv","text":"<p>Many developers know Node.js as JavaScript on the server. But have you ever wondered:</p> <ul> <li>what truly powers its asynchronous nature </li> <li>Is Node.js single-threaded or multi-threaded </li> </ul> <p>You might hear conflicting answers, and surprisingly, both can be right  ! This section aims to clarify these notions, diving deep into the Node.js core to uncover how it's implemented and how it really works. About 30% of Node.js is C++, and we're going to explore what that C++ part, primarily libuv, actually does.</p>"},{"location":"nodejs/thread-pool-in-libuv/#the-core-trio-v8-libuv-and-c-apis","title":"The Core Trio: V8, Libuv, and C++ APIs","text":"<p>At its heart, Node.js combines:</p> <p></p> <ul> <li>V8 Engine: Google's high-performance JavaScript engine that executes your JS code.</li> <li>Libuv: A C library that provides the event loop, asynchronous I/O operations (like file system access, networking), and a thread pool. This is where much of the C++ magic happens.</li> <li>C++ APIs: These bridge V8 and Libuv, allowing your JavaScript code to interact with system-level operations.</li> </ul> <p>When your JavaScript code runs a synchronous method, it typically executes on the main thread where the V8 instance and the event loop reside. However, for asynchronous operations, the story gets more interesting. </p>"},{"location":"nodejs/thread-pool-in-libuv/#understanding-the-libuv-thread-pool","title":"Understanding the Libuv Thread Pool","text":"<p>Whenever there's an asynchronous task that can't be handled directly by the OS kernel's non-blocking mechanisms (like some networking operations), V8 offloads it to libuv. Libuv, in turn, often utilizes its thread pool.</p>"},{"location":"nodejs/thread-pool-in-libuv/#what-is-the-thread-pool","title":"What is the Thread Pool?","text":"<p>The thread pool is a pre-allocated set of threads managed by libuv. These threads are used to perform computationally intensive or blocking operations without blocking the main Node.js thread (and thus the event loop).</p> <p>For example, when reading a file:</p> <ol> <li>The file system (<code>fs</code>) call is assigned to a thread in the pool.</li> <li>That thread makes a request to the operating system (OS).</li> <li>While the file is being read, this specific thread in the pool is occupied.</li> <li>Once file reading is complete, the thread is freed up and becomes available for other tasks.</li> </ol>"},{"location":"nodejs/thread-pool-in-libuv/#when-does-libuv-use-the-thread-pool","title":"When Does Libuv Use the Thread Pool?","text":"<p>Libuv uses the thread pool for tasks like:</p> <ul> <li>File System (<code>fs</code>) operations (unless they are synchronous versions).</li> <li>DNS lookups (e.g., <code>dns.lookup()</code>).</li> <li>Certain cryptographic methods (like those in the <code>crypto</code> module).</li> <li>Some third-party C++ addons.</li> </ul>"},{"location":"nodejs/thread-pool-in-libuv/#thread-pool-size-and-customization","title":"Thread Pool Size and Customization","text":"<p>By default, the libuv thread pool in Node.js has 4 threads.</p> <p><pre><code>UV_THREADPOOL_SIZE=4\n</code></pre> Suppose you make 5 simultaneous file reading calls. Four calls will occupy the four threads, and the fifth call will wait until one of the threads becomes free.</p> <p>Can we change the size of the thread pool?</p> <p>Yes! You can adjust it by setting the <code>UV_THREADPOOL_SIZE</code> environment variable before starting Node.js process:</p> <p><pre><code>UV_THREADPOOL_SIZE=8 node your_script.js\n</code></pre> Or, we can set it from within your Node.js code (this must be done before the thread pool is actively used for the first time):</p> <pre><code>process.env.UV_THREADPOOL_SIZE = 8;\n</code></pre> <p>If our application involves heavy file handling or other thread pool-bound tasks, increasing this size might improve performance. However, more threads also mean more memory and CPU context switching, so benchmark to find the optimal size for your workload.</p>"},{"location":"nodejs/thread-pool-in-libuv/#nodejs-single-threaded-or-multi-threaded-revisited","title":"Node.js: Single-Threaded or Multi-Threaded Revisited","text":"<p>So, back to the big question:</p> <p>Is Node.js single-threaded or multi-threaded?</p> <ul> <li>If you're strictly talking about your JavaScript code execution context, Node.js primarily operates on a single main thread. This is where the event loop runs.</li> <li>However, when dealing with asynchronous I/O or CPU-intensive tasks that libuv offloads to its thread pool, Node.js effectively utilizes multiple threads behind the scenes.</li> </ul> <p>So, the answer truly is: It depends on what part you're looking at! Node.js gives you a single-threaded programming model for simplicity, but leverages threads internally for efficiency.</p>"},{"location":"nodejs/thread-pool-in-libuv/#the-power-of-asynchronous-operations-a-crypto-example","title":"The Power of Asynchronous Operations: A Crypto Example","text":"<p>Consider CPU-intensive operations like <code>crypto.pbkdf2()</code>. If you run multiple synchronous calls to <code>pbkdf2()</code>, they will execute one after another on the main thread. However, if you use the asynchronous version, libuv can distribute these calls across its thread pool.</p> <p>This demonstrates how Node.js can run things in parallel for you if you give it a chance by using asynchronous methods.</p> <p>Here's an example where we set the thread pool size to 2 and make four <code>pbkdf2</code> calls:</p> <pre><code>const crypto = require('crypto');\n\nprocess.env.UV_THREADPOOL_SIZE = 2;\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"1-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"2-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"3-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"4-\" + key.toString(\"hex\"));\n})\n</code></pre> <p>You'd observe that roughly two operations complete, then the next two, due to the limited thread pool size (actual behavior also depends on CPU cores and scheduling).</p> <p>If we run with the default thread pool size (or comment out the <code>UV_THREADPOOL_SIZE</code> line), more operations can be processed concurrently by libuv's threads:</p> <pre><code>const crypto = require('crypto');\n\n// process.env.UV_THREADPOOL_SIZE = 2;\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"1-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"2-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"3-\" + key.toString(\"hex\"));\n})\n\ncrypto.pbkdf2(\"password\", \"salt\", 5000000, 50, \"sha512\", (err, key) =&gt; {\n  console.log(\"4-\" + key.toString(\"hex\"));\n})\n</code></pre> <p>You'll see that all four operations can complete in parallel, demonstrating the power of asynchronous programming in Node.js.</p>"},{"location":"nodejs/thread-pool-in-libuv/#networking-in-nodejs-beyond-the-thread-pool","title":"Networking in Node.js: Beyond the Thread Pool","text":"<p>You might ask:</p> <p> If I have a server with many incoming API requests, do these network operations use the thread pool? </p> <p>Generally, no.</p> <p>Libuv handles networking tasks differently. It uses sockets for network communication. While creating a separate thread for each incoming connection (a <code>thread-per-connection</code> model) is a traditional approach, it doesn't scale well for thousands of concurrent connections.</p> Traditional (simplified) thread-per-connection concept<pre><code>int server = socket();\nbind(server, 8080);\nlisten(server);\n\nwhile(int conn = accept(server)) {\n  // Create a new thread to handle this connection\n  pthread_create(handle_connection_function, conn);\n}\n\nvoid handle_connection_function(int conn) {\n  char buf[4096];\n  while(int size = read(conn, buf, sizeof buf)) {\n    write(conn, buf, size);\n  }\n}\n</code></pre> <p>This simplified C-like pseudocode illustrates the idea. Creating a thread for every connection is resource-intensive.</p> <p>Instead, Node.js (via libuv) leverages efficient, non-blocking, event-driven mechanisms provided by the OS, such as:</p> <ul> <li><code>epoll</code> (on Linux)</li> <li><code>kqueue</code> (on macOS and other BSD systems)</li> <li>IOCP (Input/Output Completion Ports on Windows)</li> </ul> <p>These mechanisms allow a single thread (the main event loop thread) to monitor many network sockets (file descriptors) for activity (e.g., new connection, data received). The OS kernel notifies libuv of any events, and libuv then processes them. This allows Node.js to handle a large number of concurrent connections efficiently without needing a thread per connection.</p>"},{"location":"nodejs/thread-pool-in-libuv/#key-asynchronous-concepts-in-nodejs","title":"Key Asynchronous Concepts in Node.js","text":"<p>To better grasp how Node.js manages all this, let's touch upon a few core concepts:</p>"},{"location":"nodejs/thread-pool-in-libuv/#file-descriptors-fds-and-socket-descriptors","title":"File Descriptors (FDs) and Socket Descriptors","text":"<p>Integral to Unix-like systems (Linux, macOS), File Descriptors are small integers that the OS uses to identify open files, sockets, or other I/O resources. Socket descriptors are a specific type of FD for network connections. Work in Unix is often based around these descriptors. A <code>socket()</code> system call returns such a descriptor. These descriptors point to objects in the Kernel with a virtual \"interface\" (read/write/poll/close/etc.).</p> <p></p>"},{"location":"nodejs/thread-pool-in-libuv/#event-emitters","title":"Event Emitters","text":"<p>A cornerstone of Node.js for handling asynchronous events. The <code>EventEmitter</code> class (from the <code>events</code> module) allows objects to emit named events that other parts of the application can listen to and react accordingly.</p> <ul> <li>Creating: Instantiate <code>EventEmitter</code>, use <code>on()</code> to register listeners.</li> <li>Emitting: Use <code>emit()</code> to trigger events, passing data.</li> <li>Handling: Listener functions execute when their event is emitted.</li> </ul>"},{"location":"nodejs/thread-pool-in-libuv/#streams","title":"Streams","text":"<p>Objects that facilitate reading from or writing to a data source continuously. Streams are excellent for handling large data sets efficiently (e.g., reading large files, network data transfer) without loading everything into memory at once.</p>"},{"location":"nodejs/thread-pool-in-libuv/#buffers","title":"Buffers","text":"<p>Used for handling binary data. <code>Buffer</code> objects provide a way to work with raw memory allocations, essential for operations like file I/O and network communications.</p>"},{"location":"nodejs/thread-pool-in-libuv/#pipes","title":"Pipes","text":"<p>A powerful Node.js feature for managing data flow between streams. Pipes simplify connecting a readable stream to a writable stream (<code>readable.pipe(writable)</code>), enabling efficient data processing pipelines. For tasks that use the thread pool (like <code>fs</code>), if they need to signal the event loop, pipes can be used internally. A thread writes to one end of the pipe, and the other end is watched by <code>epoll</code> (or similar) in the event loop.</p>"},{"location":"nodejs/thread-pool-in-libuv/#the-event-loop-orchestrating-asynchronous-operations","title":"The Event Loop: Orchestrating Asynchronous Operations","text":"<p>What exactly is this event loop? It's the heart of Node.js's non-blocking I/O model. Essentially, the event loop is an infinite loop that:</p> <ol> <li>Checks for pending asynchronous operations (timers, I/O events, etc.).</li> <li>Executes their callbacks once the operations are complete.</li> <li>Offloads operations to the system kernel (for most network I/O) or to the libuv thread pool (for <code>fs</code>, some <code>dns</code>, <code>crypto</code>, etc.) whenever possible.</li> </ol> <p>It continuously polls the OS (using mechanisms like <code>epoll</code> or <code>kqueue</code>) for new events. When an event occurs (e.g., data received on a socket, file read completed), the event loop takes the corresponding callback and queues it to be executed. This is why Node.js is called \"event-driven.\"</p> <p>One iteration of the Node.js event loop is called a tick, and it has several distinct phases (e.g., timers, I/O callbacks, <code>setImmediate</code>, close callbacks). You can find more details in the official Node.js documentation on the Event Loop, Timers, and <code>process.nextTick()</code>.</p>"},{"location":"nodejs/thread-pool-in-libuv/#beyond-the-main-thread-worker_threads","title":"Beyond the Main Thread: <code>worker_threads</code>","text":"<p>Since Node.js v10.5.0, the <code>worker_threads</code> module allows you to use threads that execute JavaScript in parallel. To access it:</p> <p><pre><code>const { Worker } = require('worker_threads');\n</code></pre> Workers are useful for CPU-intensive JavaScript operations, not so much for I/O-intensive work where Node.js's built-in asynchronous I/O operations are generally more efficient. Unlike <code>child_process</code> or <code>cluster</code>, <code>worker_threads</code> can share memory by transferring <code>ArrayBuffer</code> instances or sharing <code>SharedArrayBuffer</code> instances. For more details, refer to the official <code>worker_threads</code> documentation.</p>"},{"location":"nodejs/thread-pool-in-libuv/#understanding-processes-and-threads","title":"Understanding Processes and Threads","text":"<p>To fully appreciate Node.js's model, it's helpful to distinguish between processes and threads:</p> <ul> <li>Process: A top-level execution container with its own dedicated memory system. Communication between processes (Inter-Process Communication or IPC) typically requires mechanisms like system sockets and data serialization (e.g., <code>JSON.stringify</code>), which can be slower.</li> <li>Thread: The smallest sequence of programmed instructions managed independently by a scheduler. Threads run within a process and share the same memory space. This makes communication between threads very fast (e.g., accessing a global variable). However, shared memory introduces complexities like race conditions, where the outcome depends on the non-deterministic order of operations between threads.</li> </ul> <p>Node.js's main JavaScript execution is single-threaded to avoid these complexities in user code, while libuv uses threads internally for performance.</p>"},{"location":"nodejs/thread-pool-in-libuv/#which-apis-use-what","title":"Which APIs Use What?","text":"<p>Here's a simplified breakdown of how different functionalities map to libuv's mechanisms:</p> <p>Primarily Handled by OS Kernel (via <code>epoll</code>, <code>kqueue</code>, IOCP, etc., managed by the Event Loop):</p> <ul> <li>TCP/UDP Servers and clients (networking)</li> <li>Pipes (for inter-process communication and internal signaling)</li> <li><code>dns.resolve()</code> (uses system facilities, often non-blocking)</li> <li>Child processes (<code>child_process</code> module: <code>exec</code>, <code>spawn</code>)</li> <li>TTY input (console interactions)</li> </ul> <p>Primarily Handled by Libuv's Thread Pool:</p> <ul> <li>File System operations (<code>fs.*</code>, unless they are synchronous)</li> <li><code>dns.lookup()</code> (can be blocking, so often uses thread pool)</li> <li>CPU-intensive <code>crypto</code> functions (like <code>crypto.pbkdf2</code> asynchronous version)</li> <li>Some third-party native addons.</li> </ul> <p>The event loop acts as a central dispatcher, routing requests to C++ APIs (which might use the thread pool or OS kernel) and sending results back to your JavaScript callbacks.</p>"},{"location":"nodejs/thread-pool-in-libuv/#conclusion","title":"Conclusion","text":"<p>Node.js is more than just JavaScript on the server. Its power comes from a sophisticated architecture involving the V8 engine, the C++ library libuv, and a clever event-driven, non-blocking I/O model. While your JavaScript code runs in a single main thread, Node.js efficiently handles concurrency by offloading operations to the OS kernel or libuv's internal thread pool. Understanding these core mechanics allows you to write more performant and scalable Node.js applications. So, next time someone asks if Node.js is single-threaded or multi-threaded, you can confidently say, \"It's complicated, but in a good way!\"</p>"},{"location":"nodejs/thread-pool-in-libuv/#further-reading","title":"Further Reading","text":"<ul> <li>Node.js Event loop architecture (Medium Article by the original author)</li> </ul>"},{"location":"php/","title":"Learn PHP","text":""},{"location":"php/#introduction","title":"Introduction","text":"<p>In this documentation, we will learn about PHP, a server-side scripting language. We will cover the basics of PHP to advanced concepts, including PHP frameworks, database integration, and more. The documentation will be divided into multiple units, each focusing on a specific topic.</p>"},{"location":"php/#prerequisites","title":"Prerequisites","text":"<p>Before starting with PHP, you should have a basic understanding of HTML, CSS, and JavaScript. You should also have PHP installed on your machine to create a PHP application.</p> <p>Official Documentation</p> <p>You can refer to the official PHP documentation for more information.</p>"},{"location":"php/#reading-list","title":"Reading List","text":"<ul> <li>Parallel Processing with PHP</li> </ul>"},{"location":"php/dependency-injection/","title":"Dependency Injection in PHP","text":"<p>Ever found yourself writing a class, and inside one of its methods, you suddenly need functionality from another class? The quick solution is often to just create an instance of that other class right there: <code>$helper = new HelperClass();</code>. While easy, this seemingly small decision can lead to headaches down the road, making your code rigid and hard to test.</p> <p>There's a better way: Dependency Injection (DI).</p>"},{"location":"php/dependency-injection/#the-problem-hidden-dependencies-tight-coupling","title":"The Problem: Hidden Dependencies &amp; Tight Coupling","text":"<p>Imagine our <code>PaymentGateWay</code> class needs a <code>ChargeBee</code> service to process payments. A naive approach without DI might look like this internally:</p> PaymentGateWay_Bad.php (Hard-coded Dependency)<pre><code>&lt;?php\n// A less flexible approach (NOT using DI effectively)\nclass ChargeBee {\n    // ... Chargebee methods ...\n    public function payNow() { echo \"Processing via Chargebee...\\n\"; }\n}\n\nclass PaymentGateWay_Bad {\n    protected $gateway;\n\n    public function __construct() {\n        // Problem: PaymentGateWay *creates* its own dependency.\n        // It's now permanently tied to ChargeBee.\n        $this-&gt;gateway = new ChargeBee(); // Hard-coded dependency!\n        echo \"Payment Gateway (Bad) initialised, forced to use Chargebee.\\n\";\n    }\n\n    public function charge() {\n        $this-&gt;gateway-&gt;payNow();\n    }\n}\n\n// Usage\n$badGateway = new PaymentGateWay_Bad();\n$badGateway-&gt;charge(); // Always uses Chargebee\n?&gt;\n</code></pre> <p>What's wrong here?</p> <ol> <li>Inflexibility: If you want <code>PaymentGateWay_Bad</code> to use Stripe instead, you must modify the <code>PaymentGateWay_Bad</code> class itself. This violates the Open/Closed Principle.</li> <li>Hidden Dependencies: Looking only at the constructor signature <code>__construct()</code>, you have no idea it secretly needs and creates a <code>ChargeBee</code> object. The class's requirements aren't explicit.</li> <li>Testing Nightmare: How do you test <code>PaymentGateWay_Bad</code> in isolation without involving a real <code>ChargeBee</code> object (which might make actual API calls)? It's very difficult because the dependency creation is hard-coded inside.</li> </ol>"},{"location":"php/dependency-injection/#the-solution-part-1-dependency-injection-di","title":"The Solution Part 1: Dependency Injection (DI)","text":"<p>Dependency Injection flips this around. Instead of a class sneakily creating its own tools (dependencies), we give (or \"inject\") those tools to the class when it's created.</p> <p>Dependency Injection (DI)</p> <p>The core idea is to provide the necessary dependencies (other objects a class needs to function) to an object from an external source, rather than having the object create them internally.</p> <p>Let's refactor our <code>PaymentGateWay</code> using DI, specifically Constructor Injection:</p> ChargeBee.php (Example Dependency)<pre><code>&lt;?php\n// Assume this class exists and provides the needed functionality\nclass ChargeBee {\n    public function payNow() { echo \"Processing via Chargebee...\\n\"; }\n}\n?&gt;\n</code></pre> PaymentGateWay_Better.php (Constructor Injection)<pre><code>&lt;?php\nclass PaymentGateWay_Better {\n    protected $gateway; // Still holds the payment service\n\n    // The FIX: We now ASK for the dependency in the constructor signature.\n    // The dependency (ChargeBee object) is \"injected\" from outside.\n    // Type hinting (ChargeBee) makes the requirement explicit.\n    public function __construct(ChargeBee $chargeBeeService) {\n        $this-&gt;gateway = $chargeBeeService; // We just store what we were GIVEN\n        echo \"Payment Gateway (Better) initialised, using the provided service.\\n\";\n    }\n\n    public function charge() {\n        $this-&gt;gateway-&gt;payNow(); // Uses the injected service\n    }\n}\n?&gt;\n</code></pre> Usage Example (Injecting the Dependency)<pre><code>&lt;?php\n// --- How we use it NOW ---\necho \"Setting up the Better Payment Gateway:\\n\";\n\n// Step 1: Create the dependency *outside* the consuming class\n$chargeBee = new ChargeBee();\n\n// Step 2: Inject the dependency when creating PaymentGateWay_Better\n$betterGateway = new PaymentGateWay_Better($chargeBee);\n\necho \"\\nProcessing a charge:\\n\";\n$betterGateway-&gt;charge(); // Still uses Chargebee, but setup is decoupled\n?&gt;\n</code></pre> <p>What did DI fix?</p> <ul> <li>Explicit Dependencies: The constructor <code>__construct(ChargeBee $chargeBeeService)</code> clearly signals \"I need a <code>ChargeBee</code> object to work!\". It's upfront about its requirements, improving code clarity and discoverability.</li> <li>Improved Testability: We can now easily provide a mock or fake <code>ChargeBee</code> object during testing. Since the <code>PaymentGateWay_Better</code> accepts any object matching the <code>ChargeBee</code> type hint (or, ideally, an interface - more on that later), we can inject a test double that simulates <code>ChargeBee</code> behavior without hitting external services.</li> <li>Increased Flexibility (Decoupling): While still dependent on the type <code>ChargeBee</code>, the <code>PaymentGateWay_Better</code> is no longer responsible for creating its dependency. This separation of concerns makes the class more focused and reusable.</li> </ul> <p>Think of it like building a car:</p> <ul> <li>Without DI: The car factory tries to build its own engine from scratch inside the car assembly line. Hard to swap engines or test the car chassis independently!</li> <li>With DI: The engine is built separately (or sourced) and delivered (injected) into the car during assembly. Much easier to use different engines (dependency implementations) or test the car with a dummy engine (mock object).</li> </ul>"},{"location":"php/dependency-injection/#next-steps-towards-true-decoupling","title":"Next Steps: Towards True Decoupling","text":"<p>Dependency Injection, especially Constructor Injection, is a huge step forward. It promotes better design, testability, and maintainability by making dependencies explicit and externalizing their creation.</p> <p>However, notice our <code>PaymentGateWay_Better</code> still demands a specific concrete class: <code>ChargeBee</code>. We've improved visibility and testability, but we still have tight coupling to that specific implementation. What if we want to seamlessly swap <code>ChargeBee</code> for <code>Stripe</code> without changing <code>PaymentGateWay_Better</code> at all?</p> <p>This is where programming to interfaces and the Inversion of Control (IoC) principle come into play. Stay tuned as we explore how to achieve truly flexible and decoupled components!</p>"},{"location":"php/inversion-of-control/","title":"Inversion of Control (IoC)","text":"<p>In our previous section, we discussed Dependency Injection (DI) \u2013 the practice of giving an object its dependencies from the outside instead of letting it create them internally. This is a great first step towards cleaner code.</p> <p>However, look at this DI example again:</p> <pre><code>&lt;?php\nclass PaymentGateWay {\n    protected $gateway;\n    // Still requires a *specific* ChargeBee object\n    public function __construct(ChargeBee $chargeBeeService) { // &lt;-- Problem: Concrete class dependency\n        $this-&gt;gateway = $chargeBeeService;\n    }\n    // ...\n}\n?&gt;\n</code></pre> <p>Even though we are injecting the <code>ChargeBee</code> object, the <code>PaymentGateWay</code> class is still tightly coupled to the specific <code>ChargeBee</code> implementation. If we want to use <code>Stripe</code> instead, we still have to change the <code>PaymentGateWay</code> constructor's type hint. We haven't achieved true plug-and-play flexibility yet.</p> <p>This is where Interfaces (contracts) and Inversion of Control (IoC) come in.</p>"},{"location":"php/inversion-of-control/#the-problem-depending-on-concrete-details","title":"The Problem: Depending on Concrete Details","text":"<p>The core issue is that <code>PaymentGateWay</code> knows too much about <code>ChargeBee</code>. It demands a specific type. We want <code>PaymentGateWay</code> to care only about the capabilities it needs (like processing a payment), not the specific brand of payment processor.</p>"},{"location":"php/inversion-of-control/#the-solution-inversion-of-control-ioc-via-interfaces","title":"The Solution: Inversion of Control (IoC) via Interfaces","text":"<p>IoC is a broader design principle.</p> <p>Inversion of Control (IoC)</p> <p>A design principle where the control over the application flow or object creation/dependency resolution is transferred (\"inverted\") from the application components themselves to an external entity (like a framework, container, or setup code).</p> <p>One of the most common ways to achieve IoC for managing dependencies is by using Interfaces combined with Dependency Injection.</p>"},{"location":"php/inversion-of-control/#step-1-define-a-contract-interface","title":"Step 1: Define a Contract (Interface)","text":"<p>An interface defines what methods a class must have, without specifying how they are implemented. It's a contract.</p> <pre><code>&lt;?php\n// The Contract: Any class implementing this MUST provide these methods\ninterface PaymentContract {\n    public function payNow();\n    public function removeSubscription();\n}\n\n// Maybe we also need a contract for internal subscription details\ninterface SubscriptionContract {\n    public function cancelSubscription();\n}\n?&gt;\n</code></pre> <p>This says: \"Anything that wants to be considered a <code>PaymentContract</code> must be able to <code>removeSubscription</code> and <code>payNow</code>.\"</p>"},{"location":"php/inversion-of-control/#step-2-depend-on-the-contract-not-the-concrete-class","title":"Step 2: Depend on the Contract, Not the Concrete Class","text":"<p>Now, modify <code>PaymentGateWay</code> to depend on the <code>PaymentContract</code> interface:</p> <pre><code>&lt;?php\nclass PaymentGateWay { // Our final, flexible version\n    protected $paymentService; // Can hold ANY object that fulfills the PaymentContract\n\n    // We ask for ANY object implementing PaymentContract\n    public function __construct(PaymentContract $anyPaymentService) { // &lt;-- Depend on the INTERFACE!\n        $this-&gt;paymentService = $anyPaymentService;\n        echo \"Payment Gateway configured and ready for any compatible service.\\n\";\n    }\n\n    public function charge() {\n        // We trust that payNow() exists because the contract guarantees it\n        $this-&gt;paymentService-&gt;payNow();\n    }\n\n    public function cancelUserSubscription() {\n        // We trust removeSubscription() exists too\n        $this-&gt;paymentService-&gt;removeSubscription();\n    }\n}\n</code></pre> <p>Now, <code>PaymentGateWay</code> is happy as long as it receives something that knows how to <code>payNow</code> and <code>removeSubscription</code>. It doesn't care about the specific implementation details.</p>"},{"location":"php/inversion-of-control/#step-3-fulfill-the-contract","title":"Step 3: Fulfill the Contract","text":"<p>Make our specific payment services (<code>ChargeBee</code>, and a new <code>Stripe</code> class) promise to fulfill the <code>PaymentContract</code>. Note they also implement the <code>SubscriptionContract</code> for their internal needs, demonstrating how interfaces can be composed.</p> <pre><code>&lt;?php\n// --- Stripe Implementation ---\nclass StripeSubscription implements SubscriptionContract {\n    public function cancelSubscription() {\n        echo \"Stripe subscription cancelled.\\n\";\n    }\n}\n\nclass Stripe implements PaymentContract { // &lt;-- Stripe promises to follow the PaymentContract\n    protected $subscriptionHandler;\n    public function __construct(SubscriptionContract $subHandler) { // &lt;-- Also uses DI + interface!\n        $this-&gt;subscriptionHandler = $subHandler;\n        echo \"Stripe service ready.\\n\";\n    }\n    public function payNow() {\n        echo \"Processing payment via Stripe...\\n\";\n    }\n    public function removeSubscription() {\n        $this-&gt;subscriptionHandler-&gt;cancelSubscription();\n    }\n}\n\n// --- ChargeBee Implementation (Updated) ---\nclass ChargeBeeSubscription implements SubscriptionContract {\n    public function cancelSubscription() {\n        echo \"Chargebee subscription cancelled.\\n\";\n    }\n}\n\nclass ChargeBee implements PaymentContract { // &lt;-- Chargebee also promises to follow the PaymentContract\n    protected $subscriptionHandler;\n    public function __construct(SubscriptionContract $subHandler) { // &lt;-- Uses DI + interface\n        $this-&gt;subscriptionHandler = $subHandler;\n        echo \"Chargebee service ready.\\n\";\n    }\n    public function payNow() {\n        echo \"Processing payment via Chargebee...\\n\";\n    }\n    public function removeSubscription() {\n        $this-&gt;subscriptionHandler-&gt;cancelSubscription();\n    }\n}\n?&gt;\n</code></pre>"},{"location":"php/inversion-of-control/#step-4-control-from-the-outside-composition-root","title":"Step 4: Control from the Outside (Composition Root)","text":"<p>The control of deciding which specific implementation (<code>ChargeBee</code> or <code>Stripe</code>) to use is now completely outside the <code>PaymentGateWay</code> class. It resides in the code that sets up the objects (often called the Composition Root).</p> <pre><code>&lt;?php\n// --- Setting up Chargebee ---\necho \"--- Using Chargebee ---\\n\";\n$chargebeeSub = new ChargeBeeSubscription();\n$chargebeeService = new ChargeBee($chargebeeSub);\n// Inject ChargeBee into PaymentGateWay - it satisfies the PaymentContract!\n$gatewayUsingChargebee = new PaymentGateWay($chargebeeService);\n\necho \"\\nProcessing with Chargebee:\\n\";\n$gatewayUsingChargebee-&gt;charge();\n$gatewayUsingChargebee-&gt;cancelUserSubscription();\n\n\necho \"\\n\\n--- Effortlessly Switching to Stripe ---\\n\";\n// Want Stripe instead? No changes needed in PaymentGateWay!\n// Just create and inject the Stripe objects:\n$stripeSub = new StripeSubscription();\n$stripeService = new Stripe($stripeSub);\n// Inject Stripe into the SAME PaymentGateWay class - it also satisfies the PaymentContract!\n$gatewayUsingStripe = new PaymentGateWay($stripeService);\n\necho \"\\nProcessing with Stripe:\\n\";\n$gatewayUsingStripe-&gt;charge();\n$gatewayUsingStripe-&gt;cancelUserSubscription();\n?&gt;\n</code></pre> <p>This Shift is Inversion of Control!</p> <p>The responsibility for deciding which <code>PaymentContract</code> implementation to use has been inverted \u2013 moved from inside <code>PaymentGateWay</code> to the outside setup code.</p> <p>Think of it like plugging in appliances:</p> <ul> <li>Without IoC (Tight Coupling): Your toaster has its power cord permanently wired into one specific outlet in your kitchen wall. Moving the toaster requires rewiring the wall.</li> <li>With IoC (Loose Coupling): Your toaster has a standard plug (the interface). Your kitchen has standard wall outlets (the external control/container). You can plug any appliance with the standard plug into any outlet. You control where things plug in from the outside.</li> </ul> <p>Dependency Injection (DI) is often the mechanism (passing dependencies based on interfaces), while Inversion of Control (IoC) is the principle or result (control is externalized).</p>"},{"location":"php/inversion-of-control/#why-embrace-this-the-amazing-benefits","title":"Why Embrace This? The Amazing Benefits","text":"<p>Using DI and IoC (often together via interfaces) brings significant advantages:</p> <ol> <li>Loose Coupling: Classes depend on abstract contracts (interfaces), not concrete implementations. This makes the system incredibly flexible.</li> <li>Easy Swapping &amp; Maintenance: Changing payment providers (or database handlers, loggers, etc.) is trivial. You only modify the setup code where objects are created and injected. The core classes like <code>PaymentGateWay</code> remain untouched!</li> <li>Massively Improved Testability: This is huge! You can easily test <code>PaymentGateWay</code> in complete isolation. Just create a simple \"MockPayment\" class that implements <code>PaymentContract</code> but doesn't do anything real (maybe just records if methods were called). Inject this mock during your tests. No real network calls, no real charges!</li> <li>Better Reusability: Components designed around interfaces are like building blocks \u2013 much easier to reuse in different parts of your application or other projects because they aren't hard-wired to specific dependencies.</li> <li>Clear Dependencies: The constructor explicitly declares the types of services (interfaces) a class needs, making its requirements obvious and the code easier to understand, directly addressing the \"Hidden Dependencies\" problem.</li> </ol>"},{"location":"php/inversion-of-control/#in-conclusion","title":"In Conclusion","text":"<p>Starting with code where classes create their own dependencies (<code>new ChargeBee()</code> inside the constructor) leads to tight coupling, hidden requirements, inflexibility, and testing nightmares.</p> <ul> <li>Dependency Injection (DI) fixes the immediate problem by making dependencies explicit and providing them from the outside.</li> <li>Combining DI with Interfaces allows us to depend on abstract contracts rather than concrete classes.</li> <li>This enables Inversion of Control (IoC), where the decision of which specific implementation to use is moved outside the class, leading to maximum flexibility.</li> </ul> <p>By embracing these principles, you move away from tangled, rigid code towards building modular, adaptable, and highly testable software systems. It's a foundational practice for writing clean, professional code that's easier and more maintainable in the long run.</p>"},{"location":"php/inversion-of-control/#how-interfaces-and-type-hinting-work-together-in-php","title":"How Interfaces and Type Hinting Work Together in PHP","text":"<p>Let's clarify how PHP connects the interface, the implementing class, and the type hint:</p> <ol> <li> <p>The Contract (<code>PaymentContract</code>):     The <code>PaymentContract</code> interface defines a contract or a blueprint. It says: \"Any class that claims to be a <code>PaymentContract</code> must provide these specific public methods (in this case, <code>payNow()</code> and <code>removeSubscription()</code>).\" It doesn't provide the implementation (the actual code inside the methods), just the required structure.</p> </li> <li> <p>The Implementation (<code>ChargeBee</code>):     The <code>ChargeBee</code> class definition includes <code>implements PaymentContract</code>:     <pre><code>class ChargeBee implements PaymentContract\n</code></pre>     This <code>implements</code> keyword is crucial. It's a promise from the <code>ChargeBee</code> class to PHP and any code that uses it. <code>ChargeBee</code> is saying: \"I officially fulfill the requirements set out by the <code>PaymentContract</code> interface. I guarantee that I have a public <code>payNow()</code> method and a public <code>removeSubscription()</code> method.\" (If it doesn't, PHP will throw an error).</p> </li> <li> <p>The Type Hint (<code>PaymentGateWay</code> Constructor):     The constructor signature is:     <pre><code>public function __construct(PaymentContract $gateway)\n</code></pre>     When PHP sees this type hint (<code>PaymentContract</code>), it doesn't only look for an object literally named <code>PaymentContract</code> (which you can't instantiate directly because it's an interface). Instead, PHP checks: \"Is the object being passed an instance of a class that implements the <code>PaymentContract</code> interface?\"</p> </li> <li> <p>Putting It Together:</p> <ul> <li>You create <code>$chargebeeService = new ChargeBee($chargebeeSubscription);</code>. This <code>$chargebeeService</code> object is an instance of the <code>ChargeBee</code> class.</li> <li>The <code>ChargeBee</code> class implements <code>PaymentContract</code>.</li> <li>You call <code>$gatewayUsingChargebee = new PaymentGateWay($chargebeeService);</code>.</li> <li>PHP checks the type hint in the <code>PaymentGateWay</code> constructor (<code>PaymentContract</code>).</li> <li>It sees that <code>$chargebeeService</code> is an instance of <code>ChargeBee</code>, and <code>ChargeBee</code> implements <code>PaymentContract</code>.</li> <li>Therefore, <code>$chargebeeService</code> satisfies the requirement of the type hint. The object is-a valid <code>PaymentContract</code> in terms of its capabilities, even though its specific class is <code>ChargeBee</code>.</li> </ul> </li> </ol> <p>In simpler terms:</p> <p>Think of <code>PaymentContract</code> as a job description:</p> <ul> <li>\"Must be able to process payments (<code>payNow</code>).\"</li> <li>\"Must be able to handle subscription removal (<code>removeSubscription</code>).\"</li> </ul> <p><code>ChargeBee</code> applies for the job:</p> <ul> <li>\"I am <code>ChargeBee</code>, and I can do both those things (<code>implements PaymentContract</code>).\"</li> </ul> <p>The <code>PaymentGateWay</code> constructor is the hiring manager:</p> <ul> <li>\"I need someone who meets the job description (<code>PaymentContract</code>).\"</li> </ul> <p>When you pass the <code>ChargeBee</code> object (<code>$chargebeeService</code>), the hiring manager sees that <code>ChargeBee</code> meets the requirements (because it implements the interface), so it accepts it. It doesn't care that the worker's specific name is <code>ChargeBee</code>, only that it fulfills the <code>PaymentContract</code> role.</p> <p>This is the power of programming to interfaces \u2013 it allows for polymorphism (treating objects of different classes in a uniform way based on the interface) and loose coupling, enabling you to swap implementations easily.</p>"},{"location":"react/","title":"Learn React","text":""},{"location":"react/#introduction","title":"Introduction","text":"<p>In this documentation, we will learn about React, a JavaScript library for building user interfaces. We will cover the basics of React to advanced concepts, including React hooks, context API, and more. The documentation will be divided into multiple units, each focusing on a specific topic.</p>"},{"location":"react/#prerequisites","title":"Prerequisites","text":"<p>Before starting with React, you should have a basic understanding of HTML, CSS, and JavaScript. You should also have Node.js installed on your machine to create a React application.</p> <p>Official Documentation</p> <p>You can refer to the official React documentation for more information.</p>"},{"location":"react/data-is-the-new-oil/","title":"11 - Data is the New Oil","text":""},{"location":"react/data-is-the-new-oil/#higher-order-components-hoc","title":"\ud83d\udee0\ufe0f Higher-Order Components (HOC) \ud83d\udee0\ufe0f","text":"<p>A higher-order component (HOC) is a function that takes a component and returns a new component. <pre><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);\n</code></pre></p> <p>While a component transforms props into UI, a HOC transforms a component into another component.</p> <p>It takes a component as input, enhances it by adding features, and returns the enhanced component.</p> <p>\ud83c\udf1f Key Points: - HOCs are pure functions because they don\u2019t change the existing behavior of the input component.</p>"},{"location":"react/data-is-the-new-oil/#example-of-hoc","title":"\ud83d\udca1 Example of HOC:","text":"<pre><code>// This is our higher component\nfunction withLoadingSpinner(WrappedComponent) {\n  return function EnhancedComponent({ isLoading, ...props }) {\n    if (isLoading) {\n      return &lt;div&gt;Loading... \u23f3&lt;/div&gt;;\n    }\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n}\n\n// This is a simple component that we will enhance with out HOC\nconst MyComponent = ({ data }) =&gt; &lt;div&gt;{data}&lt;/div&gt;;\n\n// Usage: Create a new component by applying HOC\nconst EnhancedComponent = withLoadingSpinner(MyComponent);\n\n// Render\n&lt;EnhancedComponent isLoading={true} data=\"Hello, World!\" /&gt;;\n</code></pre> <p>In this example, the <code>withLoadingSpinner</code> HOC adds a loading spinner feature to any component.</p>"},{"location":"react/data-is-the-new-oil/#sharing-state-between-components","title":"\ud83d\udd04 Sharing State Between Components","text":"<p>Sometimes, you want two components to share and update the same state. To achieve this, remove the state from both components, move it to their closest common parent, and pass it down via props. This process is called lifting state up and is common in React development.</p>"},{"location":"react/data-is-the-new-oil/#you-will-learn","title":"\ud83d\udcda You Will Learn","text":"<ul> <li>How to share state between components by lifting it up</li> <li>What are controlled and uncontrolled components</li> </ul>"},{"location":"react/data-is-the-new-oil/#lifting-state-up-by-example","title":"\ud83d\udee0\ufe0f Lifting State Up by Example","text":"<p>Consider a parent <code>Accordion</code> component that renders two <code>Panel</code> components:</p> <ul> <li>Accordion</li> <li>Panel</li> <li>Panel</li> </ul> <p>Each <code>Panel</code> has an <code>isActive</code> state to determine if its content is visible.</p>"},{"location":"react/data-is-the-new-oil/#original-implementation","title":"Original Implementation","text":"<p>Each <code>Panel</code> manages its own <code>isActive</code> state independently.</p> <pre><code>import { useState } from 'react';\n\nfunction Panel({ title, children }) {\n  const [isActive, setIsActive] = useState(false);\n  return (\n    &lt;section className=\"panel\"&gt;\n      &lt;h3&gt;{title}&lt;/h3&gt;\n      {isActive ? (\n        &lt;p&gt;{children}&lt;/p&gt;\n      ) : (\n        &lt;button onClick={() =&gt; setIsActive(true)}&gt;Show&lt;/button&gt;\n      )}\n    &lt;/section&gt;\n  );\n}\n\nexport default function Accordion() {\n  return (\n    &lt;&gt;\n      &lt;h2&gt;My Cars&lt;/h2&gt;\n      &lt;Panel title=\"Toyota\"&gt;\n        Toyota is a reliable car brand known for its durability and efficiency.\n      &lt;/Panel&gt;\n      &lt;Panel title=\"Honda\"&gt;\n        Honda offers a range of vehicles that are both stylish and economical.\n      &lt;/Panel&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre> <p></p> <p>Behavior: Clicking \"Show\" on one panel doesn't affect the other; they operate independently.</p>"},{"location":"react/data-is-the-new-oil/#to-coordinate-these-two-panels-you-need-to-lift-their-state-up-to-a-parent-component","title":"\ud83d\udcc8 To coordinate these two panels, you need to \u201clift their state up\u201d to a parent component","text":"<p>To ensure only one panel is open at a time, follow these steps:</p>"},{"location":"react/data-is-the-new-oil/#1-remove-state-from-child-components","title":"1. Remove State from Child Components","text":"<p>Move the <code>isActive</code> state to the <code>Accordion</code> parent component.</p>"},{"location":"react/data-is-the-new-oil/#2-pass-props-from-the-common-parent","title":"2. Pass Props from the Common Parent","text":"<p>Let <code>Accordion</code> control the <code>isActive</code> state for each <code>Panel</code>.</p>"},{"location":"react/data-is-the-new-oil/#3-add-state-to-the-parent","title":"3. Add State to the Parent","text":"<p>Manage which panel is active in <code>Accordion</code> and pass handlers to <code>Panel</code>.</p> <pre><code>import { useState } from 'react';\n\nexport default function Accordion() {\n  const [activeIndex, setActiveIndex] = useState(0);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;My Cars&lt;/h2&gt;\n      &lt;Panel\n        title=\"Toyota\"\n        isActive={activeIndex === 0}\n        onShow={() =&gt; setActiveIndex(0)}\n      &gt;\n        Toyota is a reliable car brand known for its durability and efficiency.\n      &lt;/Panel&gt;\n      &lt;Panel\n        title=\"Honda\"\n        isActive={activeIndex === 1}\n        onShow={() =&gt; setActiveIndex(1)}\n      &gt;\n        Honda offers a range of vehicles that are both stylish and economical.\n      &lt;/Panel&gt;\n    &lt;/&gt;\n  );\n}\n\nfunction Panel({ title, children, isActive, onShow }) {\n  return (\n    &lt;section className=\"panel\"&gt;\n      &lt;h3&gt;{title}&lt;/h3&gt;\n      {isActive ? (\n        &lt;p&gt;{children}&lt;/p&gt;\n      ) : (\n        &lt;button onClick={onShow}&gt;Show&lt;/button&gt;\n      )}\n    &lt;/section&gt;\n  );\n}\n</code></pre> <p>Result: Only one panel can be active at a time. Clicking \"Show\" on one panel closes the other.</p>"},{"location":"react/data-is-the-new-oil/#deep-dive","title":"\ud83d\udd0d Deep Dive","text":""},{"location":"react/data-is-the-new-oil/#controlled-vs-uncontrolled-components","title":"\ud83c\udf9b\ufe0f Controlled vs. Uncontrolled Components","text":"<ul> <li> <p>Uncontrolled Components: Manage their own state internally. Example: Original <code>Panel</code> with local <code>isActive</code> state.</p> </li> <li> <p>Controlled Components: Receive state via props and rely on parent components for state management. Example: Final <code>Panel</code> controlled by <code>Accordion</code>.</p> </li> </ul> <p>Pros: - Uncontrolled: Easier to use with less setup. - Controlled: More flexibility and coordination between components.</p>"},{"location":"react/data-is-the-new-oil/#single-source-of-truth","title":"\ud83c\udfdb\ufe0f Single Source of Truth","text":"<p>In React, each piece of state should be owned by a single component. This component is the single source of truth. Instead of duplicating state across components, lift it up to a common parent and pass it down as needed.</p> <p>Benefits: - Consistent and predictable state management. - Easier to debug and maintain.</p>"},{"location":"react/data-is-the-new-oil/#recap","title":"\ud83d\udcdd Recap","text":"<ul> <li>When you want to coordinate two components, move their state to their common parent.</li> <li>Then pass the information down through props from their common parent.</li> <li>Finally, pass the event handlers down so that the children can change the parent\u2019s state.</li> <li>Controlled vs. Uncontrolled: Decide which state is managed internally and which is controlled by parents.</li> <li>Single Source of Truth: Ensure each state piece is owned by one component.</li> </ul> <p>Info</p> <p>By lifting state up, you create more manageable and predictable React applications. Learn more on React Docs</p>"},{"location":"react/data-is-the-new-oil/#passing-data-deeply-with-context","title":"Passing Data Deeply with Context \ud83c\udf10","text":"<p>In React, props are the primary way to pass data from a parent component to a child component. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information. React's Context API solves this problem by allowing you to share data across the component tree without explicitly passing props at every level.</p>"},{"location":"react/data-is-the-new-oil/#the-problem-with-passing-props","title":"The Problem with Passing Props \ud83d\udcdc","text":"<p>While passing props is a straightforward way to transfer data, it becomes verbose and inconvenient when:</p> <ul> <li>Data needs to be passed deeply through many components.</li> <li>Multiple components require the same piece of data.</li> </ul> <p>This leads to prop drilling, where intermediary components pass props they don't use, cluttering the code and making maintenance difficult.</p>"},{"location":"react/data-is-the-new-oil/#what-is-prop-drilling","title":"What is Prop Drilling? \ud83d\udd73\ufe0f","text":"<p>Prop drilling refers to passing props through several levels of nested components to reach a deeply nested child. Here's a simple example:</p> <pre><code>// Top-level component\nfunction App() {\n  const data = \"Hello, prop drilling!\";\n  return (\n    &lt;div&gt;\n      &lt;ParentComponent data={data} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Intermediate component\nfunction ParentComponent({ data }) {\n  return (\n    &lt;div&gt;\n      &lt;ChildComponent data={data} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Deeply nested component\nfunction ChildComponent({ data }) {\n  return &lt;div&gt;{data}&lt;/div&gt;;\n}\n</code></pre> <p>In this example, <code>data</code> is passed from <code>App</code> to <code>ChildComponent</code> through <code>ParentComponent</code>, even though <code>ParentComponent</code> doesn't use <code>data</code> itself.</p>"},{"location":"react/data-is-the-new-oil/#solution-reacts-context-api","title":"Solution: React's Context API \ud83c\udf1f","text":"<p>React's Context API provides a way to share data between components without having to explicitly pass props through every level of the tree.</p>"},{"location":"react/data-is-the-new-oil/#example-scenario-a-user-authentication-system","title":"Example Scenario: A User Authentication System","text":"<p>Imagine you\u2019re building an app where you need to display the authenticated user\u2019s information (like their name and email) in multiple components. Without context, you\u2019d have to pass the user data through every component, even if some of them don\u2019t use it. With context, you can make the user data available to any component in the tree, no matter how deeply nested.</p>"},{"location":"react/data-is-the-new-oil/#step-by-step-implementation","title":"Step-by-Step Implementation","text":""},{"location":"react/data-is-the-new-oil/#1-create-a-context","title":"1. Create a Context","text":"<p>First, you need to create a context to hold the user data. Think of this as a \"box\" where you can store the data and make it accessible to any component.</p> <pre><code>import { createContext } from 'react';\n\n// Create a context for the user data\nexport const UserContext = createContext(null);\n</code></pre> <ul> <li><code>UserContext</code> is the \"box\" where the user data will be stored.</li> <li><code>createContext(null)</code> initializes the context with a default value of <code>null</code>.</li> </ul>"},{"location":"react/data-is-the-new-oil/#2-provide-the-context","title":"2. Provide the Context","text":"<p>Next, you need to \"provide\" the context to the component tree. This is done using the <code>Provider</code> component. Any component inside the <code>Provider</code> can access the context.</p> <pre><code>import { UserContext } from './UserContext';\n\nexport default function App() {\n  // Simulate user data (e.g., fetched from an API)\n  const user = { name: 'John Doe', email: 'john.doe@example.com' };\n\n  return (\n    // Wrap the component tree with the UserContext.Provider\n    &lt;UserContext.Provider value={user}&gt;\n      &lt;Dashboard /&gt;\n    &lt;/UserContext.Provider&gt;\n  );\n}\n</code></pre> <ul> <li><code>UserContext.Provider</code> makes the <code>user</code> data available to all components inside it.</li> <li>The <code>value</code> prop is where you pass the data you want to share (in this case, the <code>user</code> object).</li> </ul>"},{"location":"react/data-is-the-new-oil/#3-consume-the-context","title":"3. Consume the Context","text":"<p>Now, any component inside the <code>Provider</code> can access the <code>user</code> data using the <code>useContext</code> hook.</p> <pre><code>import { useContext } from 'react';\nimport { UserContext } from './UserContext';\n\nfunction Profile() {\n  // Access the user data from the context\n  const user = useContext(UserContext);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;\n      &lt;p&gt;Email: {user.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction Dashboard() {\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Dashboard&lt;/h2&gt;\n      &lt;Profile /&gt;\n      {/* Other components can also access the context */}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <ul> <li><code>useContext(UserContext)</code> retrieves the <code>user</code> data from the context.</li> <li>The <code>Profile</code> component can now display the user\u2019s name and email without needing to receive it as a prop.</li> </ul>"},{"location":"react/data-is-the-new-oil/#how-it-works","title":"How It Works","text":"<ol> <li>Create Context: A \"box\" (<code>UserContext</code>) is created to hold the user data.</li> <li>Provide Context: The <code>App</code> component wraps its children with <code>UserContext.Provider</code> and passes the <code>user</code> data as the <code>value</code>.</li> <li>Consume Context: The <code>Profile</code> component accesses the <code>user</code> data using <code>useContext(UserContext)</code> and displays it.</li> </ol>"},{"location":"react/data-is-the-new-oil/#how-context-api-solves-prop-drilling","title":"How Context API Solves Prop Drilling \ud83d\udee0\ufe0f","text":"<ol> <li>Create a Context: Define a context with a default value.</li> <li>Provide Context: Use a Context Provider to pass the current value to the tree below.</li> <li>Consume Context: Any component within the tree can access the context value directly.</li> </ol>"},{"location":"react/data-is-the-new-oil/#benefits-of-using-context","title":"Benefits of Using Context","text":"<ul> <li>Avoids Prop Drilling: You don\u2019t need to pass the <code>user</code> data through every intermediate component.</li> <li>Cleaner Code: Components only receive the data they need, making the code easier to read and maintain.</li> <li>Flexibility: Context can be used for various purposes, such as theming, authentication, or localization.</li> </ul>"},{"location":"react/data-is-the-new-oil/#when-to-use-context","title":"When to Use Context","text":"<ul> <li>Global Data: Use context for data that needs to be accessed by many components (e.g., user authentication, theme preferences).</li> <li>Avoid Overuse: Don\u2019t use context for data that only a few components need. In such cases, passing props or lifting state up might be a better option.</li> </ul>"},{"location":"react/data-is-the-new-oil/#alternatives-to-context","title":"Alternatives to Context \ud83d\udd04","text":"<p>Before using Context, consider:</p> <ol> <li>Passing Props: Clear and straightforward for small data needs.</li> <li>Component Composition: Break down components and pass only necessary data.</li> <li>State Management Libraries: Tools like Redux or zustand for complex state needs.</li> </ol>"},{"location":"react/data-is-the-new-oil/#recap_1","title":"Recap \ud83d\udcdd","text":"<ul> <li>Context lets a component provide some information to the entire tree below it.</li> <li>To pass context:</li> <li>Create and export it with <code>export const MyContext = createContext(defaultValue)</code>.</li> <li>Pass it to the <code>useContext(MyContext)</code> Hook to read it in any child component, no matter how deep.</li> <li>Wrap children into <code>&lt;MyContext.Provider value={...}&gt;</code> to provide it from a parent.</li> <li>Context passes through any components in the middle.</li> <li>Context lets you write components that \u201cadapt to their surroundings\u201d.</li> <li>Before you use context, try passing props or passing JSX as <code>children</code>.</li> </ul>"},{"location":"react/data-is-the-new-oil/#what-are-context-provider-and-context-consumer","title":"\u2753 What are Context Provider and Context Consumer?","text":"<p>In React, the Context API allows you to pass data through the component tree without manually passing props at every level. The two main components of the Context API are the Context Provider and Context Consumer.</p>"},{"location":"react/data-is-the-new-oil/#context-provider","title":"\ud83d\ude80 Context Provider","text":"<p>The Context Provider is a component that lets its children subscribe to context changes. It accepts a <code>value</code> prop, which is the data shared with descendant components. You create a Provider using <code>React.createContext()</code> and include it in your component tree to provide data to its descendants.</p> <p>Example:</p> <pre><code>// Creating a context\nconst MyContext = React.createContext();\n\n// Parent component serving as the provider\nclass MyProvider extends React.Component {\n  state = {\n    data: \"Hello from Context!\",\n  };\n\n  render() {\n    return (\n      &lt;MyContext.Provider value={this.state.data}&gt;\n        {this.props.children}\n      &lt;/MyContext.Provider&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"react/data-is-the-new-oil/#context-consumer","title":"\ud83d\udc65 Context Consumer","text":"<p>The Context Consumer subscribes to context changes from the nearest Provider ancestor. It allows components to access context data without prop drilling. The Consumer uses a function as its child, receiving the current context value as an argument.</p> <p>Example:</p> <pre><code>// Child component consuming the context\nclass MyConsumerComponent extends React.Component {\n  render() {\n    return (\n      &lt;MyContext.Consumer&gt;\n        {(contextData) =&gt; &lt;p&gt;{contextData}&lt;/p&gt;}\n      &lt;/MyContext.Consumer&gt;\n    );\n  }\n}\n</code></pre> <p>By using the Context Provider and Consumer, you can avoid prop drilling and easily share global state across different parts of your React application. This is especially useful for passing data to deeply nested components without explicitly passing props through each intermediate component.</p>"},{"location":"react/data-is-the-new-oil/#if-we-dont-pass-a-value-to-the-provider-does-it-take-the-default-value","title":"\u2753 If we don't pass a value to the provider, does it take the default value?","text":"<p>Yes. If you don't pass a <code>value</code> to the Provider in React's Context API, it uses the default value specified when creating the context with <code>React.createContext(defaultValue)</code>.</p> <p>Example:</p> <pre><code>// Creating a context with a default value\nconst MyContext = React.createContext(\"Default Value\");\n\n// Parent component serving as the provider without providing a value\nclass MyProvider extends React.Component {\n  render() {\n    return (\n      &lt;MyContext.Provider&gt;\n        {this.props.children}\n      &lt;/MyContext.Provider&gt;\n    );\n  }\n}\n</code></pre> <p>In this example, if no <code>value</code> is provided to <code>MyContext.Provider</code>, it will use the default value <code>\"Default Value\"</code>. Any component that consumes this context using <code>MyContext.Consumer</code> will receive the default value if there is no Provider higher up in the tree supplying a different value.</p>"},{"location":"react/exploring-the-world/","title":"06 - Exploring the World","text":""},{"location":"react/exploring-the-world/#q1-what-are-monolithic-and-microservices-architectures","title":"Q1: What Are Monolithic and Microservices Architectures?","text":"<p>Understanding Monolithic and Microservices architectures is essential in software development. Let's break them down:</p>"},{"location":"react/exploring-the-world/#monolithic-architecture","title":"Monolithic Architecture","text":"<p>Traditionally, applications were built as a single large project where all components\u2014APIs, user interface, database connections, authentication, and notification services\u2014resided in one codebase.</p> <p></p> <p>Drawbacks:</p> <ul> <li>Size and Complexity: Becomes too large and hard to manage.</li> <li>Slow Startup: Large size can slow down startup time.</li> <li>Full Deployment: Every update requires redeploying the entire application.</li> <li>Limited Change Understanding: Changes can have wide impacts, requiring extensive testing.</li> <li>Deployment Challenges: Difficult to implement continuous deployment.</li> <li>Scaling Issues: Conflicting resource needs make scaling hard.</li> <li>Reliability: A bug in one module can crash the entire application.</li> <li>Technology Adoption: Changing frameworks or languages is costly and time-consuming.</li> </ul>"},{"location":"react/exploring-the-world/#microservices-architecture","title":"Microservices Architecture","text":"<p>Instead of a single application, Microservices split the system into smaller, interconnected services. Each service handles a specific task, such as user accounts or payments, with its own business logic and tools. Services communicate via REST, messaging, or other methods and can have their own interfaces.</p> <p></p> <p>Benefits:</p> <ul> <li>Simpler Development: Breaks down complex applications into manageable services.</li> <li>Independent Teams: Teams can develop services independently.</li> <li>Technology Flexibility: Choose the best technology for each service.</li> <li>Continuous Deployment: Allows independent deployment of services.</li> <li>Scalability: Scale each service independently for efficient resource use.</li> <li>Separation of Concerns: Keeps architecture organized and manageable.</li> <li>Single Responsibility: Each service has a specific job, ensuring focused development.</li> </ul>"},{"location":"react/exploring-the-world/#q2-why-microservices","title":"Q2: Why Microservices?","text":"<p>Breaking down applications into microservices allows for faster and smarter work. Services can be updated or replaced independently without causing disruptions, much like a well-oiled machine where each part functions perfectly.</p>"},{"location":"react/exploring-the-world/#fetching-data-from-an-api","title":"Fetching Data from an API","text":"<p>There are two approaches to fetching data from an API:</p>"},{"location":"react/exploring-the-world/#1-load-and-render","title":"1. Load and Render","text":"<ol> <li>As soon as the page loads, initiate an API call.</li> <li>Once the API response is received, populate the data and render the UI.</li> </ol>"},{"location":"react/exploring-the-world/#2-render-first-fetch-later","title":"2. Render First, Fetch Later","text":"<ol> <li>As soon as the page loads, display the UI skeleton.</li> <li>Make an API call.</li> <li>Once the API response is received, populate the data and update the UI.</li> </ol> <p>Note: In React, we always follow the second approach.</p>"},{"location":"react/exploring-the-world/#shimmer-ui","title":"Shimmer UI","text":"<p>Shimmer UI displays placeholder content (i.e skeleton UI) while data is loading, improving user experience by reducing perceived wait times. Instead of a generic \"loading\" message, a <code>&lt;Shimmer /&gt;</code> component provides visual feedback during data fetching. This concept is known as conditional rendering. This technique complements the Render First, Fetch Later approach.</p>"},{"location":"react/exploring-the-world/#integrating-shimmer-ui-with-render-first-fetch-later","title":"Integrating Shimmer UI with Render First, Fetch Later","text":"<p>With Render First, Fetch Later, the UI skeleton is rendered immediately as soon as page loads, and data is loaded afterward. Shimmer UI enhances this by showing a polished placeholder.</p> <p>Steps:</p> <ol> <li>Page Loads: Render the UI skeleton using <code>&lt;Shimmer /&gt;</code>.</li> <li>Fetch Data: Make an API call to retrieve data.</li> <li>Update UI: Replace shimmer placeholders with the actual data once fetched.</li> </ol>"},{"location":"react/exploring-the-world/#example-in-react","title":"Example in React","text":"<pre><code>import React, { useState, useEffect } from 'react';\nimport Shimmer from './Shimmer';\nimport RestaurantList from './RestaurantList';\n\nconst App = () =&gt; {\n  const [restaurants, setRestaurants] = useState([]);\n\n  useEffect(() =&gt; {\n    fetch('/api/restaurants')\n      .then(res =&gt; res.json())\n      .then(data =&gt; setRestaurants(data));\n  }, []);\n\n  if (restaurants.length === 0) {\n    return &lt;Shimmer /&gt;;\n  }\n\n  return &lt;RestaurantList restaurants={restaurants} /&gt;;\n};\n\nexport default App;\n</code></pre>"},{"location":"react/exploring-the-world/#useeffect-hook","title":"useEffect() Hook","text":"<p>The <code>useEffect()</code> Hook is a function provided by React that allows you to manage side effects in your components. It helps in handling tasks like data fetching, subscriptions, and manually changing the DOM in React components.</p>"},{"location":"react/exploring-the-world/#importing-useeffect","title":"Importing useEffect","text":"<p>To use <code>useEffect()</code>, first import it from React:</p> <pre><code>import { useEffect } from \"react\";\n</code></pre>"},{"location":"react/exploring-the-world/#syntax-of-useeffect","title":"Syntax of useEffect","text":"<p><code>useEffect()</code> accepts two arguments:</p> <ol> <li>Callback Function: The function that contains the side-effect logic.</li> <li>Dependency Array: An array of dependencies that determine when the effect should run.</li> </ol> <pre><code>useEffect(() =&gt; {\n  // Side-effect logic here\n}, []);\n</code></pre>"},{"location":"react/exploring-the-world/#when-does-the-callback-function-get-called","title":"When Does the Callback Function Get Called?","text":"<p>The callback function inside <code>useEffect()</code> is executed after the entire component has rendered. For example, if you use <code>useEffect()</code> inside a <code>Body</code> component, the callback will run once the <code>Body</code> component has completed its render cycle. This is ideal for performing actions that need to occur after the component is displayed, such as fetching data.</p>"},{"location":"react/exploring-the-world/#where-to-fetch-data","title":"Where to Fetch Data?","text":"<p>Data fetching should be done inside the <code>useEffect()</code> Hook using a function like <code>fetchData()</code>. This ensures that the data is fetched after the component has rendered, aligning with the Render First, Fetch Later approach.</p> <p>Example:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport Shimmer from './Shimmer';\nimport RestaurantList from './RestaurantList';\n\nconst Body = () =&gt; {\n  const [restaurants, setRestaurants] = useState([]);\n\n  useEffect(() =&gt; {\n    // Function to fetch data\n    const fetchData = async () =&gt; {\n      const response = await fetch('/api/restaurants');\n      const data = await response.json();\n      setRestaurants(data);\n    };\n\n    fetchData();\n  }, []); // Empty dependency array ensures this runs once after initial render\n\n  if (restaurants.length === 0) {\n    return &lt;Shimmer /&gt;;\n  }\n\n  return &lt;RestaurantList restaurants={restaurants} /&gt;;\n};\n\nexport default Body;\n</code></pre> <p>Explanation:</p> <ol> <li>As soon as Page loads, the <code>Body</code> component renders, and <code>restaurants</code> is an empty array.</li> <li>After the render, <code>useEffect()</code> runs the <code>fetchData()</code> function to fetch restaurant data.</li> <li>Once data is fetched, <code>setRestaurants(data)</code> updates the state, triggering a re-render.</li> <li>Conditional Rendering: If <code>restaurants</code> is empty, the <code>&lt;Shimmer /&gt;</code> component is displayed. After data is loaded, <code>&lt;RestaurantList /&gt;</code> is rendered with the fetched data.</li> </ol>"},{"location":"react/exploring-the-world/#react-using-usestate-for-dynamic-buttons","title":"React: Using useState() for Dynamic Buttons","text":""},{"location":"react/exploring-the-world/#problem-regular-javascript-fails-to-trigger-ui-updates","title":"Problem: Regular JavaScript Fails to Trigger UI Updates","text":"<pre><code>const btnName = \"Login\";\n\nreturn (\n  &lt;button\n    onClick={() =&gt; {\n      btnName = \"Logout\";\n    }}\n  &gt;\n    {btnName}\n  &lt;/button&gt;\n);\n</code></pre>"},{"location":"react/exploring-the-world/#issue","title":"\u2022   Issue:","text":"<p>Updating btnName doesn\u2019t update the UI because React doesn\u2019t detect changes in regular variables and won\u2019t re-render the component.</p>"},{"location":"react/exploring-the-world/#solution-use-usestate","title":"Solution: Use useState()","text":"<pre><code>import React, { useState } from 'react';\n\nconst Header = () =&gt; {\n  const [btnLabel, setBtnLabel] = useState(\"Login\");\n\n  return (\n    &lt;button\n      onClick={() =&gt;\n        setBtnLabel(btnLabel === \"Login\" ? \"Logout\" : \"Login\")\n      }\n    &gt;\n      {btnLabel}\n    &lt;/button&gt;\n  );\n};\n</code></pre>"},{"location":"react/exploring-the-world/#how-it-works","title":"How It Works:","text":"<ol> <li>State Declaration:  <code>useState(\"Login\")</code> initializes <code>btnLabel</code> and provides <code>setBtnLabel</code> for updates.</li> <li>UI Sync: Updating btnLabel with setBtnLabel triggers a re-render, reflecting changes in the UI.</li> </ol>"},{"location":"react/exploring-the-world/#what-is-optional-chaining","title":"What is Optional Chaining?","text":"<p>It is a feature that simplifies accessing properties and methods of nested objects or arrays when intermediate properties may be <code>null</code> or <code>undefined</code>.</p>"},{"location":"react/exploring-the-world/#example-of-optional-chaining","title":"Example of Optional Chaining","text":"<p>Let's look at a JavaScript example to understand how optional chaining works:</p> <pre><code>const user = {\n  name: 'Alice',\n  profile: {\n    email: 'alice@example.com',\n    address: {\n      city: 'Wonderland'\n    }\n  }\n};\n\n// Accessing nested properties without optional chaining\nconst city = user.profile &amp;&amp; user.profile.address &amp;&amp; user.profile.address.city;\nconsole.log(city); // Outputs: Wonderland\n\n// Accessing nested properties with optional chaining\nconst cityWithOptional = user.profile?.address?.city;\nconsole.log(cityWithOptional); // Outputs: Wonderland\n\n// Attempting to access a property that doesn't exist\nconst phone = user.contact?.phone;\nconsole.log(phone); // Outputs: undefined\n</code></pre> <p>Explanation:</p> <ol> <li> <p>Without Optional Chaining:</p> <ul> <li>To safely access <code>user.profile.address.city</code>, you need to check each property exists to avoid errors.</li> <li>This results in a longer and more cumbersome code: <code>user.profile &amp;&amp; user.profile.address &amp;&amp; user.profile.address.city</code>.</li> </ul> </li> <li> <p>With Optional Chaining (<code>?.</code>):</p> <ul> <li>The <code>?.</code> operator simplifies the syntax by automatically checking if the preceding property exists.</li> <li><code>user.profile?.address?.city</code> will return <code>'Wonderland'</code> if all properties exist.</li> <li>If any property in the chain is <code>null</code> or <code>undefined</code>, the entire expression short-circuits and returns <code>undefined</code> without throwing an error.</li> </ul> </li> <li> <p>Accessing a Non-Existent Property:</p> <ul> <li><code>user.contact?.phone</code> attempts to access the <code>phone</code> property inside <code>contact</code>.</li> <li>Since <code>contact</code> doesn't exist on <code>user</code>, the expression returns <code>undefined</code> instead of causing a runtime error.</li> </ul> </li> </ol> <p>Benefits of Using Optional Chaining:</p> <ul> <li>Reduces the need for repetitive checks (<code>&amp;&amp;</code>) when accessing nested properties.</li> <li>Avoids runtime errors when attempting to access properties on <code>null</code> or <code>undefined</code>.</li> <li>Makes the code easier to read and maintain.</li> </ul> <p>Optional chaining is especially useful when dealing with complex data structures or responses from APIs where certain properties might be missing.</p>"},{"location":"react/finding-the-path/","title":"07 - Finding the Path","text":""},{"location":"react/finding-the-path/#useeffect","title":"useEffect:","text":"<ul> <li>If there is no dependency array, the effect will run after every render. <pre><code>useEffect(() =&gt; {\n  console.log('This will run after every render');\n});\n</code></pre></li> <li>If there is an empty dependency array, the effect will only run after the first render. <pre><code>useEffect(() =&gt; {\n  console.log('This will only run after the first render');\n}, []);\n</code></pre></li> <li>If there is a dependency array, the effect will only run when the dependencies change. <pre><code>useEffect(() =&gt; {\n  console.log('This will only run when the dependencies change');\n}, [dependency1, dependency2]);\n</code></pre></li> </ul>"},{"location":"react/finding-the-path/#usestate","title":"useState:","text":"<ul> <li>Never call useState inside a loop, condition, or nested function or outside of a React component.</li> </ul>"},{"location":"react/finding-the-path/#what-is-spa","title":"What is SPA?","text":"<p>SPA (Single Page Application) is a web application that interacts with users by dynamically rewriting the current web page instead of loading entire new pages from the server. It loads a single HTML page initially and updates content dynamically as users interact with the application.</p>"},{"location":"react/finding-the-path/#key-characteristics-of-spas","title":"Key characteristics of SPAs:","text":"<ol> <li> <p>Dynamic Updates</p> <ul> <li>Content updates without full page reloads using JavaScript and client-side routing </li> </ul> </li> <li> <p>Smooth User Experience</p> <ul> <li>More responsive as only parts of the page update without full refreshes</li> </ul> </li> <li> <p>Initial Load</p> <ul> <li>May take longer initially but provides faster subsequent interactions</li> </ul> </li> <li> <p>Client-Side Routing</p> <ul> <li>Uses libraries like React Router to simulate traditional navigation</li> </ul> </li> <li> <p>API-Centric</p> <ul> <li>Communicates with backend APIs to fetch and send data, typically in JSON format</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Often uses libraries like Redux or Vuex to manage application state</li> </ul> </li> </ol> <p>Common frameworks for building SPAs include React, Angular, and Vue.js, which provide tools for creating efficient and maintainable applications.</p>"},{"location":"react/finding-the-path/#client-side-routing-vs-server-side-routing","title":"Client-Side Routing vs Server-Side Routing","text":""},{"location":"react/finding-the-path/#client-side-routing","title":"Client-Side Routing","text":""},{"location":"react/finding-the-path/#key-features","title":"Key Features:","text":"<ol> <li> <p>Browser-Side Handling</p> <ul> <li>Routes managed in the browser</li> <li>Uses frameworks like React Router or Vue Router</li> <li>No server requests for page changes</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Faster page transitions</li> <li>No full page reloads</li> <li>Dynamic DOM updates</li> </ul> </li> <li> <p>Architecture</p> <ul> <li>Typical in Single Page Applications (SPAs)</li> <li>Initial HTML load followed by dynamic content updates</li> <li>JavaScript-dependent</li> </ul> </li> <li> <p>Limitations</p> <ul> <li>SEO challenges</li> <li>Requires additional setup for search engine optimization</li> <li>May need server-side rendering (SSR) solutions</li> </ul> </li> </ol>"},{"location":"react/finding-the-path/#server-side-routing","title":"Server-Side Routing","text":""},{"location":"react/finding-the-path/#key-features_1","title":"Key Features:","text":"<ol> <li> <p>Server-Side Handling</p> <ul> <li>Routes managed on server</li> <li>Server generates new HTML for each route</li> <li>Traditional web architecture</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Slower page transitions</li> <li>Full page reloads required</li> <li>Higher server load</li> </ul> </li> <li> <p>Architecture</p> <ul> <li>Used in traditional multi-page websites</li> <li>Each route serves a complete HTML page</li> <li>Less JavaScript dependency</li> </ul> </li> <li> <p>Advantages</p> <ul> <li>Better SEO by default</li> <li>Simpler implementation</li> <li>Better for content-focused websites</li> </ul> </li> </ol>"},{"location":"react/finding-the-path/#best-use-cases","title":"Best Use Cases","text":"<ul> <li> <p>Choose Client-Side Routing for:</p> <ul> <li>Interactive applications</li> <li>Dynamic content</li> <li>Fast user experience requirements</li> </ul> </li> <li> <p>Choose Server-Side Routing for:</p> <ul> <li>Content-heavy websites</li> <li>SEO priority</li> <li>Traditional web applications</li> </ul> </li> </ul> <p>Some applications use a hybrid approach, combining both methods to leverage their respective advantages.</p>"},{"location":"react/finding-the-path/#react-routing-guide","title":"React Routing Guide","text":""},{"location":"react/finding-the-path/#why-react-router-dom","title":"Why react-router-dom?","text":"<ul> <li><code>react-router-dom</code> is specifically designed for web applications, while <code>react-router</code> is the core package</li> <li><code>react-router-dom</code> includes all the features of <code>react-router</code> plus additional DOM-specific components</li> <li>It provides web-specific components like <code>&lt;BrowserRouter&gt;</code>, <code>&lt;Link&gt;</code>, and <code>&lt;NavLink&gt;</code></li> <li>Always use <code>react-router-dom</code> for web applications unless you're building a React Native app</li> </ul>"},{"location":"react/finding-the-path/#basic-routing-setup","title":"Basic Routing Setup","text":""},{"location":"react/finding-the-path/#1-creating-router-configuration","title":"1. Creating Router Configuration","text":"<p><pre><code>import { createBrowserRouter, RouterProvider, Outlet } from \"react-router-dom\";\n\nconst appRouter = createBrowserRouter([\n  {\n    path: \"/\",\n    element: &lt;AppLayout /&gt;,\n    errorElement: &lt;ErrorPage /&gt;,\n    children: [\n      {\n        path: \"/\",\n        element: &lt;Body /&gt;\n      },\n      {\n        path: \"/about\",\n        element: &lt;About /&gt;\n      }\n    ]\n  }\n]);\n</code></pre> Note:</p> <ul> <li><code>createBrowserRouter</code> creates the routing configuration</li> <li>Configuration defines what happens on specific routes</li> <li><code>errorElement</code> handles undefined routes</li> <li><code>children</code> defines nested routes</li> </ul>"},{"location":"react/finding-the-path/#2-implementing-router","title":"2. Implementing Router","text":"<p><pre><code>root.render(&lt;RouterProvider router={appRouter} /&gt;);\n</code></pre> Note:</p> <ul> <li><code>RouterProvider</code> is necessary to provide routing configuration to the app</li> <li>Without <code>RouterProvider</code>, routes won't work</li> </ul>"},{"location":"react/finding-the-path/#key-components","title":"Key Components","text":""},{"location":"react/finding-the-path/#1-applayout-component","title":"1. AppLayout Component","text":"<p><pre><code>const AppLayout = () =&gt; {\n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;Header /&gt;\n      &lt;Outlet /&gt;  {/* Children components render here */}\n    &lt;/div&gt;\n  );\n};\n</code></pre> Note:</p> <ul> <li><code>Outlet</code> is a placeholder where child routes are rendered</li> <li>It automatically updates when route changes</li> <li>Essential for nested routing</li> </ul>"},{"location":"react/finding-the-path/#2-error-handling","title":"2. Error Handling","text":"<p><pre><code>const ErrorPage = () =&gt; {\n  const error = useRouteError();\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Oops! Something went wrong&lt;/h1&gt;\n      &lt;p&gt;{error.message}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> Note:</p> <ul> <li><code>useRouteError</code> hook provides detailed error information</li> <li>Useful for custom error pages</li> <li>Helps in debugging routing issues</li> </ul>"},{"location":"react/finding-the-path/#dynamic-routing","title":"Dynamic Routing","text":""},{"location":"react/finding-the-path/#1-route-configuration","title":"1. Route Configuration","text":"<p><pre><code>{\n  path: \"/restaurant/:resId\",\n  element: &lt;RestaurantMenu /&gt;\n}\n</code></pre> Note:</p> <ul> <li><code>:resId</code> is a URL parameter</li> <li>Can have multiple dynamic parameters</li> <li>Makes routes flexible and reusable</li> </ul>"},{"location":"react/finding-the-path/#2-accessing-parameters","title":"2. Accessing Parameters","text":"<p><pre><code>const RestaurantMenu = () =&gt; {\n  const { resId } = useParams();\n  // Use resId as needed\n};\n</code></pre> Note:</p> <ul> <li><code>useParams</code> hook extracts URL parameters</li> <li>Parameters are accessible as object properties</li> <li>Useful for fetching specific data based on URL</li> </ul>"},{"location":"react/finding-the-path/#navigation-best-practices","title":"Navigation Best Practices","text":""},{"location":"react/finding-the-path/#1-internal-links","title":"1. Internal Links","text":"<p><pre><code>// Correct way\n&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;\n\n// Avoid\n&lt;a href=\"/about\"&gt;About&lt;/a&gt;\n</code></pre> Note:</p> <ul> <li>Always use <code>Link</code> from react-router-dom for internal navigation</li> <li><code>&lt;a&gt;</code> tags cause full page reloads, breaking SPA behavior</li> <li><code>Link</code> maintains the single-page application experience</li> </ul>"},{"location":"react/finding-the-path/#2-benefits","title":"2. Benefits","text":"<ul> <li>Preserves React application state</li> <li>Faster navigation</li> <li>Better user experience</li> <li>No unnecessary server requests</li> </ul>"},{"location":"react/finding-the-path/#3-advanced-features","title":"3. Advanced Features","text":"<ul> <li>Can use <code>NavLink</code> for styled active links</li> <li>Supports programmatic navigation with <code>useNavigate</code> hook</li> <li>Enables route protection and guards</li> <li>Allows for route-specific data loading</li> </ul>"},{"location":"react/ignition/","title":"02 - Igniting our app","text":""},{"location":"react/ignition/#difference-between-npm-and-npx","title":"Difference between NPM and NPX","text":"NPM NPX NPM is a package manager used to install, delete, and update JavaScript packages on your machine. NPX is a package executor that allows you to run JavaScript packages directly without installing them. NPM installs packages globally, which means your machine may accumulate packages that are no longer needed. NPX does not install packages, so package pollution on the machine is not a concern. To use <code>create-react-app</code> with NPM, you must first install it globally and then run it, which can be redundant. The most common use of NPX is the <code>create-react-app</code> command. Since it is only needed once to initialize the project, it does not require installation."},{"location":"react/ignition/#what-is-a-bundler","title":"What is a Bundler?","text":"<ul> <li>A JavaScript bundler is a tool that combines your code and all its dependencies into one JavaScript file.</li> <li>It is a development tool that merges many JavaScript files into a single, production-ready file that can be loaded in the browser.</li> <li>The top 5 bundlers in JavaScript are:</li> <li>Browserify</li> <li>ESbuild</li> <li>Parcel</li> <li>Rollup</li> <li>Webpack</li> </ul> <p><code>package.json</code> is a configuration file for npm. Create React App uses the Webpack bundler behind the scenes.</p>"},{"location":"react/ignition/#types-of-dependencies","title":"Types of Dependencies","text":"<p>There are two types of dependencies in the packages we install:</p> <ol> <li> <p>Dev dependencies: These are the packages required only during the development phase. They are not needed in the production environment. Examples include testing frameworks, build tools, and transpilers. In <code>package.json</code>, they are listed under the <code>devDependencies</code> section.</p> </li> <li> <p>Normal dependencies: These are the packages required for the application to run in both development and production environments. They are essential for the application to function correctly. In <code>package.json</code>, they are listed under the <code>dependencies</code> section.</p> </li> </ol>"},{"location":"react/ignition/#caret-and-tilde-in-packagejson","title":"Caret (^) and Tilde (~) in <code>package.json</code>","text":""},{"location":"react/ignition/#what-is-the-role-of-the-package-lockjson-file","title":"What is the role of the package-lock.json file?","text":"<ul> <li>The package-lock.json file in npm serves as a lockfile that captures the exact versions of packages and their dependencies.</li> <li>It ensures that the same version of packages is used across different installations or environments.</li> <li>This consistency prevents unexpected package versions and helps avoid compatibility issues.</li> <li>When you install or update packages using npm, it checks the <code>package-lock.json</code> file to ensure the specified versions are installed.</li> <li>This lockfile is especially important when collaborating on projects as it guarantees that all contributors use consistent package versions.</li> </ul>"},{"location":"react/ignition/#transitive-dependencies","title":"Transitive Dependencies","text":"<ul> <li>When a dependency has its own dependencies, and those dependencies have their own dependencies, it is known as transitive dependencies.</li> <li>In a React project, inside the node_modules folder, every dependency folder has its own <code>package.json</code> file which contains the dependencies and the description of that dependency.</li> </ul>"},{"location":"react/ignition/#why-should-we-not-push-the-node_modules-to-git-or-production","title":"Why should we not push the node_modules to git or production?","text":"<ul> <li>Node_modules are huge in size.</li> <li>If we have <code>package.json</code> and <code>package-lock.json</code>, we can recreate the <code>node_modules</code> anytime.</li> <li>This is why it is not recommended to push the <code>node_modules</code>.</li> </ul>"},{"location":"react/ignition/#build-our-app-using-parcel","title":"Build Our App Using Parcel","text":"<p>To build our app using Parcel, run the following command:</p> <pre><code>npx parcel index.html\n</code></pre> <ul> <li>Parcel is a web application bundler known for its developer-friendly experience.</li> <li> <p>When you run <code>npx parcel index.html</code>, Parcel performs the following actions:</p> </li> <li> <p>Development mode (default)</p> <ul> <li>It starts a development server.</li> <li>It serves the <code>index.html</code> file and watches for changes in your files.</li> <li>It automatically reloads the browser when it detects changes.</li> </ul> </li> <li> <p>Build mode (with additional options)</p> <ul> <li>If you specify a build option (e.g., <code>npx parcel build index.html</code>), Parcel will create an optimized, production-ready bundle.</li> <li>It minifies the code and optimizes assets for better performance.</li> </ul> </li> </ul>"},{"location":"react/ignition/#why-should-cdn-links-not-be-used-to-bring-react-and-react-dom-into-the-project","title":"Why Should CDN Links Not Be Used to Bring React and React-DOM into the Project?","text":"<ul> <li>Network Dependency: Using CDN links requires a network call to bring React into the project.</li> <li>Version Management: Currently, we use React version 18, which is specified in the CDN link. If React version 19 is released in the future, we will need to update the CDN links.</li> <li>Local Installation: Installing React using <code>npm install react</code> stores React in <code>node_modules</code>, avoiding dependency issues.</li> <li>Internet Requirement: To get React from a CDN link, an internet connection is necessary.</li> </ul>"},{"location":"react/ignition/#browser-scripts-cannot-have-importsexports","title":"Browser Scripts Cannot Have Imports/Exports","text":"<ul> <li>Error on Removal of CDN Links: When React is installed and CDN links are removed, an error <code>Uncaught ReferenceError: React is not defined</code> occurs.</li> <li>Importing React: This happens because React is installed but not imported into the JavaScript file. <pre><code>import React from 'react';\n</code></pre></li> <li>Import/Export Error: Importing React this way results in an error <code>Browser scripts cannot have imports or exports</code>.</li> <li>Script Tag Modification: Since <code>app.js</code> is imported in <code>index.html</code> using a <code>&lt;script&gt;</code> tag, the browser treats it as a normal JavaScript file. To indicate that it is a module, add an extra attribute to the <code>&lt;script&gt;</code> tag: <pre><code>&lt;script type=\"module\" src=\"./app.js\"&gt;&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/ignition/#hmr-hot-module-replacement","title":"HMR (Hot Module Replacement)","text":"<ul> <li>Functionality: HMR exchanges, adds, or removes modules while an application is running without a full reload.</li> <li>Development Speed: This speeds up development by:</li> <li>Retaining the application state, which is lost during a full reload.</li> <li>Saving development time by only updating what has changed.</li> <li>Instantly updating the browser when modifications are made to CSS/JS files, similar to changing styles directly in the browser's dev tools.</li> <li>How It Works:</li> <li>The application asks the HMR runtime to check for updates.</li> <li>The runtime asynchronously downloads the updates and notifies the application.</li> <li>The application asks the runtime to apply the updates.</li> <li>The runtime synchronously applies the updates.</li> </ul>"},{"location":"react/ignition/#how-does-parcel-know-there-are-changes-in-the-filecode","title":"How Does Parcel Know There Are Changes in the File/Code?","text":"<ul> <li>File Watching Algorithm: Parcel uses a file-watching algorithm developed in C++.</li> <li>Tracking Changes: This algorithm keeps track of every file and every change made to a file.</li> </ul>"},{"location":"react/ignition/#how-does-parcel-perform-builds-so-quickly","title":"How Does Parcel Perform Builds So Quickly?","text":"<ul> <li>Caching: When the server is started using Parcel for the first time, it creates a folder named <code>.parcel-cache</code> in the project.</li> <li>Cache Updates: Parcel uses caching and updates the cache after every subsequent build.</li> </ul>"},{"location":"react/ignition/#what-other-things-does-parcel-do","title":"What Other Things Does Parcel Do?","text":"<ul> <li>Zero Configuration: Automatically detects the entry point and handles configuration.</li> <li>Code Splitting: Supports dynamic imports for optimized loading.</li> <li>Asset Management: Inlines small assets and handles URL references.</li> <li>Development Server: Includes a built-in server with live reloading and HMR.</li> <li>Tree Shaking: Removes unused code to reduce bundle size.</li> <li>Source Maps: Generates source maps for easier debugging.</li> <li>Environment Variables: Supports configuration for different environments.</li> <li>Minification: Automatically minifies CSS and JS in production.</li> <li>TypeScript Support: Built-in support for TypeScript.</li> <li>Plugin System: Allows custom plugins for extended functionality.</li> <li>Modern JavaScript: Integrates with Babel for latest ECMAScript features.</li> <li>PWA Support: Generates service workers and manifest files.</li> <li>Multi-Target Builds: Supports building for browsers, Node.js, and Electron.</li> <li>Dependency Management: Automatically resolves and installs dependencies.</li> </ul>"},{"location":"react/ignition/#removing-main-from-packagejson","title":"Removing \"main\" from package.json","text":"<ul> <li>The <code>main</code> field in <code>package.json</code> specifies the entry point (e.g., <code>App.js</code>)</li> <li>Since Parcel handles the entry point through commands, the <code>main</code> field is not needed</li> <li>Having <code>main</code> can cause errors when running <code>npx parcel build index.html</code></li> <li>Solution: Simply delete the <code>main</code> field from <code>package.json</code></li> </ul>"},{"location":"react/ignition/#making-our-app-compatible-with-olderspecific-browsers","title":"Making Our App Compatible with Older/Specific Browsers","text":"<ul> <li>To make the app compatible with older/specific browsers, use <code>browserslist</code>.</li> <li>Add <code>browserslist</code> configuration in <code>package.json</code></li> <li>Example: <pre><code>{\n\"browserslist\": [\n    \"last 2 versions\",\n    \"&gt; 1%\"\n]\n}\n</code></pre></li> <li>Parcel uses <code>browserslist</code> from <code>node_modules</code> to ensure compatibility.</li> <li>Reference: Refer to browserslist.dev</li> </ul>"},{"location":"react/inception/","title":"01 - React Inception","text":""},{"location":"react/inception/#what-is-a-cdn","title":"What is a CDN ?","text":"<ul> <li>A Content Delivery Network or Content Distribution Network (CDN) is a geographically distributed network of proxy servers and their data centers.</li> <li>The goal is to provide high availability and performance by distributing the service spatially relative to end users.</li> <li>CDNs have grown to serve a large portion of the internet content today, including web objects (text, graphics &amp; scripts), downloadable objects (media files, software, documents), applications (e-commerce, portals), live streaming media, on-demand streaming media, and social media sites.</li> <li>CDNs are a layer in the internet ecosystem. Content owners such as media companies and ecommerce vendors pay CDN operators to pay their content to their end users.</li> <li>We can add React into our project by injecting CDN links in it (in an .html file).</li> </ul> <pre><code>&lt;script crossorigin src=\"https://unpkg.com/react@18/umd/react.development.js\"&gt;&lt;/script&gt;\n&lt;script crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"react/inception/#why-do-we-use-cdn","title":"Why do we use CDN ?","text":"<ul> <li>Improved scalability and connectivity.</li> <li>In addition to facilitating end-users with faster load times, which translates into greater user -experience, a content delivery network also rewards web publishers with increased traffic, higher page views, etc.</li> <li>Decreased bandwidth consumption.</li> <li>Lower latency.</li> <li>Latency is the lag between request and response.</li> <li>Effective traffic spike management.</li> <li>Enhanced cyber security.</li> <li>A CDN employs automation and data analytics tools that help identify firewall issues, Man in the middle threat, Distributed Denial of Service attacks.</li> </ul>"},{"location":"react/inception/#what-is-crossorigin-and-why-do-we-use-it-in-react-cdn","title":"What is crossorigin and why do we use it in React CDN ?","text":"<ul> <li>CORS or cross-origin resource sharing is a mechanism that allows memory resources (e.g., fonts, JavaScript, etc) on a webpage to be requested from another domain outside the domain from which the resource originated.</li> </ul>"},{"location":"react/inception/#difference-between-react-and-react-dom","title":"Difference between React and React-DOM","text":"React React-DOM A JavaScript library for building user interfaces A package that connects React to the browser's DOM Contains core functionality and component logic Handles rendering React components in web browsers <p>Tip</p> <p>React defines what to render, while React-DOM handles how to render it in the browser.</p>"},{"location":"react/inception/#first-program-in-react","title":"First program in React","text":"<pre><code>const heading = React.createElement('div', { id: \"parent\" }, \"Hello from React\");\n\nconst root= React.createRoot(document.getElementById('root'));\nroot.render(heading)\n</code></pre> <ul> <li>The costliest operation for a browser is when the browser needs to manipulate the DOM.</li> <li>Any React element is nothing but a JavaScript object.</li> <li>This object contains a key known as props which stores the children and other attributes of the React element in a key-value pair.</li> <li>The <code>render()</code> function is responsible for taking the JavaScript object (React element) as an argument, converting it into an HTML tag and putting it in the DOM.</li> </ul>"},{"location":"react/inception/#create-nested-elements-with-sibling-elements","title":"Create nested elements (with sibling elements)","text":"<pre><code>const heading = React.createElement('div', { id: \"parent\" },\n    React.createElement(\"div\", { id: \"child\" },\n        [\n            React.createElement(\"h1\", {}, \"Hello from React\"),\n            React.createElement(\"h2\", {}, \"This is h2 title\")\n        ]\n    )\n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(heading);\n</code></pre>"},{"location":"react/inception/#what-if-there-is-already-an-html-element-inside-the-div-which-is-rendered-by-react-using-render-function","title":"What if there is already an HTML element inside the <code>&lt;div&gt;</code> which is rendered by React using <code>render()</code> function?","text":"<pre><code>&lt;!-- index.html --&gt;\n&lt;div id=\"root\"&gt;\n    &lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p><pre><code>// App.js\nconst rootElement = ReactDOM.createRoot(document.getElementById('root'));\nrootElement.render(&lt;App /&gt;);\n</code></pre> - When we have both HTML inside <code>&lt;div&gt;</code> and React trying to render into that same <code>&lt;div&gt;</code>. First, the HTML content loads and appears on the page. - Then, when React loads, this javascript code tells React \"replace whatever is in that div with our React app (<code>&lt;App /&gt;</code>).\"</p> <p>So while your React code is loading, users see the HTML content. Once React is ready, it swaps out the HTML content with your React app.</p> <p>It's like having a \"Loading...\" message that gets replaced by your actual app once it's ready!</p>"},{"location":"react/inception/#what-is-the-difference-between-a-framework-and-a-library","title":"What is the difference between a framework and a library?","text":"<p>1. Library   - A library provides a set of helper functions/objects/modules which your application code calls for specific functionality.   - Libraries typically focus on a narrow scope (e.g., strings, IO, sockets), so their APIs tend to be smaller and require fewer dependencies.</p> <p>2. Framework   - A framework, on the other hand, has defined open or unimplemented functions or objects which the user writes to create custom applications.   - Because a framework is itself an application, it has a wider scope and includes almost everything necessary to make a user application according to specific needs.</p> <p>Key Differences: - When you use a library, you are in control of the application's flow. - When you use a framework, the framework controls the application's flow. - The framework dictates the architecture and how the application is structured, and you fill in the details within that structure. - For example, a web framework will often handle routing, middleware, and request processing, and you define the specific actions for your application within that structure. - In a library, you decide when and where to call library functions. - For example, you might use a library to perform specific tasks like handling HTTP requests, manipulating data, or creating UI components.</p>"},{"location":"react/inception/#why-is-react-named-react","title":"Why is React named \"React\"?","text":"<p>React got its name because of its core feature: it reacts to changes in data.</p> <p>Key points that justify its name: - It reacts to state changes automatically - It reacts to user interactions promptly - It reacts and updates only the necessary components in the DOM</p> <p>As stated by Jordan Walke (React's creator):</p> <p>\"The name 'React' was chosen because the library was built to help developers build user interfaces that can quickly react to changes in data.\"</p> <p>This reactive nature makes it efficient because: 1. It updates quickly when data changes 2. It only re-renders components that need to change 3. It responds immediately to user actions</p>"},{"location":"react/inception/#real-dom-vs-virtual-dom","title":"Real DOM vs Virtual DOM","text":""},{"location":"react/inception/#real-dom","title":"Real DOM","text":"<ul> <li>The actual HTML structure of a webpage</li> <li>Direct representation of the web page in the browser</li> <li>Changes are immediately reflected on the webpage</li> <li>Updating is slower as it refreshes the entire DOM</li> </ul>"},{"location":"react/inception/#virtual-dom","title":"Virtual DOM","text":"<ul> <li>A lightweight copy of the Real DOM in memory</li> <li>Acts as a blueprint of the actual webpage</li> <li>Changes happen in two steps:</li> <li>First updates the Virtual DOM</li> <li>Then syncs changes with Real DOM</li> <li>More efficient because:</li> <li>Only updates what's necessary</li> <li>Reduces unnecessary re-rendering</li> <li>Batches multiple changes together</li> </ul>"},{"location":"react/inception/#key-benefit","title":"Key Benefit","text":"<p>The Virtual DOM improves performance by minimizing direct manipulation of the Real DOM, making React applications faster and more efficient.</p>"},{"location":"react/inception/#when-does-react-sync-virtual-dom-with-real-dom","title":"When does React sync Virtual DOM with Real DOM?","text":"<p>React follows a process called reconciliation to sync changes, which happens in the following steps:</p> <ol> <li> <p>Trigger: When state or props change</p> </li> <li> <p>Process:</p> </li> <li>Creates new Virtual DOM</li> <li>Compares with previous Virtual DOM (Diffing)</li> <li> <p>Identifies necessary changes</p> </li> <li> <p>Batch Updates:</p> </li> <li>Collects multiple changes</li> <li>Groups them together</li> <li> <p>Updates Real DOM efficiently</p> </li> <li> <p>Timing:</p> </li> <li>After user interactions (clicks, typing)</li> <li>When state updates complete</li> <li>During asynchronous operations</li> </ol> <p>This process ensures efficient updates by minimizing direct manipulation of the Real DOM.</p>"},{"location":"react/laying-the-foundation/","title":"03 - Laying the foundation","text":""},{"location":"react/laying-the-foundation/#react-element-creation-two-approaches","title":"React Element Creation: Two Approaches","text":"<p>A comparison of creating React elements using the traditional <code>React.createElement</code> method versus JSX syntax.</p>"},{"location":"react/laying-the-foundation/#reactcreateelement-approach","title":"React.createElement approach:","text":"<ol> <li>React.createElement call</li> <li>Creates ReactElement (JS object)</li> <li>Converts to HTML Element</li> <li>Places in DOM</li> </ol> <pre><code>const heading = React.createElement('h1', {id: 'heading'}, 'My First React Element!');\n</code></pre>"},{"location":"react/laying-the-foundation/#jsx-approach","title":"JSX approach:","text":"<ol> <li>Write JSX</li> <li>Babel transpiles to React.createElement</li> <li>Creates ReactElement (JS object)</li> <li>Converts to HTML Element</li> <li>Places in DOM</li> </ol> <pre><code>const heading = &lt;h1 id=\"heading\"&gt;My First React Element!&lt;/h1&gt;;\n</code></pre> <p>For multi-line jsx: <pre><code>const heading = (\n  &lt;h1 id=\"heading\" className=\"title\"&gt;\n    My First React Element!\n  &lt;/h1&gt;\n);\n</code></pre></p>"},{"location":"react/laying-the-foundation/#jsx","title":"JSX","text":"<ul> <li>JSX is a syntax extension for JavaScript that allows you to write HTML-like markup inside JavaScript files.</li> <li>It uses preprocessors (like Babel) to transform HTML-like syntax into standard JavaScript objects that can be parsed by JavaScript engines.</li> </ul>"},{"location":"react/laying-the-foundation/#react-components","title":"React Components","text":"<p>There are two ways to create React components:</p> <ol> <li>Class-based Components (older approach)</li> <li>Functional Components (modern approach, recommended)</li> </ol> <p>Note: React component names must start with a capital letter to avoid errors.</p>"},{"location":"react/laying-the-foundation/#functional-component-example","title":"Functional Component Example:","text":"<pre><code>const MyComponent = () =&gt; {\n  return &lt;div&gt;Hello World&lt;/div&gt;;\n};\n</code></pre> <p>Definition: A functional component is a normal JavaScript function that: - Accepts props (optional) - Returns JSX code/React element - Uses modern React features like Hooks</p> <p>This is the preferred way of creating components in modern React applications.</p>"},{"location":"react/laying-the-foundation/#using-javascript-in-jsx","title":"Using JavaScript in JSX","text":"<p>Inside functional components, we can execute JavaScript expressions using curly braces <code>{ }</code>.</p> <pre><code>const MyComponent = () =&gt; {\n  const name = \"John\";\n  const getGreeting = () =&gt; \"Hello\";\n\n  return (\n    &lt;div&gt;\n      {getGreeting()} {name}!\n      {2 + 2}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"react/laying-the-foundation/#nesting-elements-and-components","title":"Nesting Elements and Components","text":""},{"location":"react/laying-the-foundation/#react-element-inside-component","title":"React Element inside Component","text":"<pre><code>const heading = &lt;h1&gt;Hello World&lt;/h1&gt;;\n\nconst MyComponent = () =&gt; {\n  return (\n    &lt;div&gt;\n      {heading}\n    &lt;/div&gt;\n  );\n};\n</code></pre>"},{"location":"react/laying-the-foundation/#react-element-inside-another-element","title":"React Element inside Another Element","text":"<pre><code>const title = &lt;h2&gt;Title&lt;/h2&gt;;\nconst container = &lt;div&gt;{title}&lt;/div&gt;;\n</code></pre> <p>When we use a functional component into another functional component, then it is known as component composition.</p>"},{"location":"react/laying-the-foundation/#security-note","title":"Security Note","text":"<p>The curly braces <code>{ }</code> in JSX provide automatic protection against XSS (Cross-Site Scripting): - Any content within <code>{ }</code> is automatically escaped - Helps prevent malicious code injection - Makes React applications more secure by default</p> <p>Note: JSX makes the code readable and maintainable, while React handles the underlying processing and security.</p>"},{"location":"react/laying-the-foundation/#rendering-react-elements-vs-react-components","title":"Rendering React Elements vs React Components","text":"<pre><code>// Rendering a React Element\nroot.render(heading)\n\n// Rendering a React Component\nroot.render(&lt;Heading /&gt;)\n</code></pre> <p>Key Differences: - React Elements are rendered using just the variable name: <code>heading</code> - React Components are rendered using JSX tags: <code>&lt;Heading /&gt;</code> - Component names must start with a capital letter - Components are wrapped in angle brackets like HTML tags</p> <p>Note: When rendering components, they can be self-closing (<code>&lt;Heading /&gt;</code>) or have a closing tag (<code>&lt;Heading&gt;&lt;/Heading&gt;</code>).</p>"},{"location":"react/laying-the-foundation/#different-ways-to-use-components-in-jsx","title":"Different Ways to Use Components in JSX","text":""},{"location":"react/laying-the-foundation/#1-title","title":"1. <code>{ Title }</code>","text":"<ul> <li>Represents a JavaScript expression or variable</li> <li>Used when <code>Title</code> is a variable reference</li> <li>Not rendering a component directly</li> </ul> <pre><code>const Title = \"Hello\";\nconst Component = () =&gt; {\n  return &lt;div&gt;{Title}&lt;/div&gt;; // Outputs: Hello\n};\n</code></pre>"},{"location":"react/laying-the-foundation/#2-title","title":"2. <code>{ &lt;Title /&gt; }</code>","text":"<ul> <li>Represents a self-closing component</li> <li>Returns JSX</li> <li>Used for components without children</li> </ul> <pre><code>const Title = () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;;\nconst Component = () =&gt; {\n  return &lt;div&gt;{&lt;Title /&gt;}&lt;/div&gt;;\n};\n</code></pre>"},{"location":"react/laying-the-foundation/#3-titletitle","title":"3. <code>{ &lt;Title&gt;&lt;/Title&gt; }</code>","text":"<ul> <li>Same as <code>&lt;Title /&gt;</code> when there are no children</li> <li>Used when component might have children</li> <li>More explicit syntax</li> </ul> <pre><code>const Title = ({children}) =&gt; &lt;h1&gt;{children}&lt;/h1&gt;;\nconst Component = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Title&gt;Hello World&lt;/Title&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Note: <code>&lt;Title /&gt;</code> and <code>&lt;Title&gt;&lt;/Title&gt;</code> are equivalent only when the component doesn't have any children elements.</p>"},{"location":"react/laying-the-foundation/#script-tag-type-attribute","title":"Script Tag Type Attribute","text":"<p>The <code>type</code> attribute in the <code>&lt;script&gt;</code> tag: - Specifies the type of script - Identifies the content between <code>&lt;script&gt;</code> tags - Has a default value of <code>text/javascript</code></p>"},{"location":"react/laying-the-foundation/#available-type-options","title":"Available Type Options","text":""},{"location":"react/laying-the-foundation/#1-textjavascript","title":"1. <code>text/javascript</code>","text":"<ul> <li>Basic standard for JavaScript code</li> <li>Default value if type is not specified <pre><code>&lt;script type=\"text/javascript\"&gt;\n    // JavaScript code here\n&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/laying-the-foundation/#2-textecmascript","title":"2. <code>text/ecmascript</code>","text":"<ul> <li>Indicates script follows ECMAScript standards <pre><code>&lt;script type=\"text/ecmascript\"&gt;\n    // ECMAScript code here\n&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/laying-the-foundation/#3-module","title":"3. <code>module</code>","text":"<ul> <li>Indicates script is a module</li> <li>Allows import/export functionality <pre><code>&lt;script type=\"module\"&gt;\n    import { function } from './module.js';\n&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/laying-the-foundation/#4-textbabel","title":"4. <code>text/babel</code>","text":"<ul> <li>Indicates Babel transpilation is required</li> <li>Used with React/JSX <pre><code>&lt;script type=\"text/babel\"&gt;\n    // React/JSX code here\n&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/laying-the-foundation/#5-texttypescript","title":"5. <code>text/typescript</code>","text":"<ul> <li>Indicates TypeScript code <pre><code>&lt;script type=\"text/typescript\"&gt;\n    // TypeScript code here\n&lt;/script&gt;\n</code></pre></li> </ul>"},{"location":"react/lets-build-our-store/","title":"12 - Let's Build Our Store","text":""},{"location":"react/lets-build-our-store/#what-is-redux","title":"\ud83d\udca1 What is Redux?","text":"<p>Redux is a JavaScript library for managing and centralizing an application's state. The state represents the data that determines how a user interface (UI) looks and behaves at any given time. Centralizing the state means storing all of the application's state in a single location, typically called the Store, which makes it easier to manage, debug, and maintain. By using Redux, developers can ensure that the state remains consistent and predictable across the entire application, even as it grows in complexity.</p> <p></p> <p>Key Concepts</p> <ul> <li>State: Data that controls how the UI looks and behaves.</li> <li>Centralized Store: A single source of truth for the entire app\u2019s state.</li> <li>Predictable Updates: Ensures that state updates follow strict rules, making debugging easier.</li> </ul>"},{"location":"react/lets-build-our-store/#why-use-redux","title":"\ud83c\udfaf Why Use Redux?","text":"<p>Redux offers several benefits that make it a popular choice for state management:</p> <ul> <li>\u2705 Predictability: State changes in a structured and traceable way.</li> <li>\u2705 Centralized State: Keeps all application data in one place, avoiding prop drilling.</li> <li>\u2705 Scalability: Ideal for large apps that require structured state management.</li> <li>\u2705 Debugging Tools: Integrates well with Redux DevTools for debugging.</li> </ul>"},{"location":"react/lets-build-our-store/#example-redux-in-a-foodie-app","title":"\ud83c\udf54 Example: Redux in a Foodie App","text":"<p>To understand Redux in action, let's consider a food ordering application.</p>"},{"location":"react/lets-build-our-store/#scenario","title":"\ud83d\udccc Scenario","text":"<ul> <li>Add Items: Users can add items to the cart by clicking the \"Add +\" button.</li> <li>Dynamic Cart Count: The cart count in the top right corner updates dynamically.</li> <li>State Management: The Redux store manages the state and updates the UI when changes occur.</li> </ul>"},{"location":"react/lets-build-our-store/#diagram-representation","title":"\ud83d\uddbc Diagram Representation","text":""},{"location":"react/lets-build-our-store/#step-by-step-breakdown","title":"\ud83d\udd04 Step-by-Step Breakdown","text":"<ol> <li>Action Dispatch: Clicking the \"ADD\" button dispatches an action.</li> <li>Reducer Function: The action calls the reducer function associated with the cart slice.</li> <li>State Modification: The reducer modifies the cart slice's state in the Redux store.</li> <li>State Update: The cart component, subscribed to the store via a selector, updates its cart count dynamically.</li> <li>UI Re-render: The component re-renders to reflect the updated state.</li> </ol>"},{"location":"react/lets-build-our-store/#redux-flow-in-the-foodie-app","title":"\ud83d\udee0 Redux Flow in the Foodie App","text":"<ul> <li><code>useDispatch()</code> sends the action (<code>addItem</code>) when the button is clicked.</li> <li><code>useSelector()</code> fetches the cart count and updates the UI.</li> <li>The Redux store manages the state centrally and efficiently.</li> </ul>"},{"location":"react/lets-build-our-store/#redux-terminology","title":"\ud83d\udccc Redux Terminology","text":"<p>Before diving deeper, let's understand some essential Redux concepts:</p>"},{"location":"react/lets-build-our-store/#1-store","title":"1\ufe0f\u20e3 Store","text":"<ul> <li>\ud83d\uddc4\ufe0f Definition: The centralized location where the entire app\u2019s state is stored.</li> <li>\ud83d\udca1 Think of it as: A global database for your application.</li> </ul>"},{"location":"react/lets-build-our-store/#2-action","title":"2\ufe0f\u20e3 Action","text":"<ul> <li>\ud83d\udce9 Definition: A plain JavaScript object describing a change in the state.</li> </ul> <pre><code>{\n  type: \"addItem\",\n  payload: \"Pizza\"\n}\n</code></pre> <ul> <li>\ud83d\udca1 Think of it as: A request to update the store.</li> </ul>"},{"location":"react/lets-build-our-store/#3-reducer","title":"3\ufe0f\u20e3 Reducer","text":"<ul> <li>\ud83d\udd04 Definition: A pure function that takes the current state and an action and returns a new state.</li> <li>\ud83d\udca1 Think of it as: A function that tells Redux how to update the state.</li> </ul>"},{"location":"react/lets-build-our-store/#4-dispatch","title":"4\ufe0f\u20e3 Dispatch","text":"<ul> <li>\ud83d\ude80 Definition: A method used to send an action to the reducer.</li> <li>\ud83d\udca1 Think of it as: Clicking a button to tell Redux \u201cDo this!\u201d</li> </ul>"},{"location":"react/lets-build-our-store/#5-selector","title":"5\ufe0f\u20e3 Selector","text":"<ul> <li>\ud83c\udfaf Definition: A function used to retrieve data from the Redux store.</li> <li>\ud83d\udca1 Think of it as: A filter that selects the required data from the store.</li> </ul>"},{"location":"react/lets-build-our-store/#setting-up-redux-in-a-react-application","title":"\ud83d\ude80 Setting Up Redux in a React Application","text":""},{"location":"react/lets-build-our-store/#libraries-required","title":"\ud83d\udce6 Libraries Required","text":"<ul> <li> <p>React-Redux: Connects Redux with React components, allowing components to read from the Redux store and dispatch actions. It provides the <code>Provider</code> component to make the Redux store available to all components, and hooks like <code>useSelector</code> and <code>useDispatch</code>.</p> </li> <li> <p>Redux Toolkit: A set of tools for efficient Redux development, offering a simplified approach to setting up and working with Redux. It addresses major issues associated with Redux:</p> </li> <li> <p>Complex Store Configuration: Simplifies setting up a Redux store.</p> </li> <li>Excessive Packages: Reduces the need for multiple additional packages.</li> <li>Boilerplate Code: Minimizes repetitive code needed for effective Redux usage.</li> </ul>"},{"location":"react/lets-build-our-store/#installation","title":"\ud83d\udee0\ufe0f Installation","text":"<p>Redux Toolkit is available as a package on NPM for use with a module bundler.</p> <pre><code>npm install @reduxjs/toolkit\nnpm install react-redux\n</code></pre>"},{"location":"react/lets-build-our-store/#create-redux-store","title":"\ud83c\udfd7\ufe0f Create Redux Store","text":"<p>Use <code>configureStore</code> from Redux Toolkit to set up the Redux store. This function automatically includes Redux DevTools integration.</p> <pre><code>import { configureStore } from '@reduxjs/toolkit';\n\nconst appStore = configureStore({\n  // Add slices here\n});\n\nexport default appStore;\n</code></pre>"},{"location":"react/lets-build-our-store/#wrap-your-application-with-provider","title":"\ud83d\udd17 Wrap Your Application with Provider","text":"<p>To make the Redux store accessible to your React components, wrap your root component with the <code>Provider</code> component from <code>react-redux</code>. Pass the store as a prop to the provider.</p> <p>Example:</p> <pre><code>import { Provider } from 'react-redux';\nimport appStore from '../utils/appStore.js';\n\n&lt;Provider store={appStore}&gt;\n  &lt;App /&gt;\n&lt;/Provider&gt;\n</code></pre> <p>Why is <code>configureStore</code> imported from Redux Toolkit and <code>Provider</code> from React-Redux?</p> <p>Reason</p> <p><code>configureStore</code> is imported from Redux Toolkit because it is used to build the Redux store. On the other hand, <code>Provider</code> is imported from React-Redux because it supplies the store to the React application, effectively connecting Redux and React.</p>"},{"location":"react/lets-build-our-store/#create-a-redux-slice","title":"\ud83c\udf70 Create a Redux Slice","text":"<p>Use <code>createSlice</code> from Redux Toolkit to define a slice of the state along with its actions and reducers.</p> <ul> <li>Actions: Payloads of information that send data from your application to the Redux store.</li> <li>Reducers: Pure functions that specify how the application's state changes in response to actions.</li> </ul> <p>If you don\u2019t understand these concepts right now, don\u2019t worry; you\u2019ll explore them in depth soon.</p> <pre><code>import { createSlice } from \"@reduxjs/toolkit\";\n\nconst cartSlice = createSlice({\n  name: 'cart',\n  initialState: {\n    items: []\n  },\n  reducers: {\n    addItem: (state, action) =&gt; {\n      state.items.push(action.payload);\n    },\n  }\n});\n\nexport const { addItem } = cartSlice.actions;\nexport default cartSlice.reducer;\n</code></pre>"},{"location":"react/lets-build-our-store/#explanation","title":"\ud83d\udcc4 Explanation","text":"<p>The <code>createSlice</code> function from <code>@reduxjs/toolkit</code> creates a slice of the Redux state with a specific configuration:</p> <ul> <li>name: <code>'cart'</code> \u2013 This names the slice, useful for debugging and action types.</li> <li>initialState: <code>{ items: [] }</code> \u2013 Sets the initial state with an empty <code>items</code> array.</li> <li>reducers: Contains all the reducer functions for this slice.</li> </ul> <p>Reducers:</p> <ul> <li>addItem: <code>(state, action)</code> \u2013 Defines how to add an item to the cart. It takes the current state and an action as parameters and adds the new item (from <code>action.payload</code>) to the <code>items</code> array.</li> </ul> <p>Exporting:</p> <ul> <li><code>export const { addItem } = cartSlice.actions;</code> \u2013 Exports the <code>addItem</code> action creator so other parts of the application can dispatch this action.</li> <li><code>export default cartSlice.reducer;</code> \u2013 Exports the reducer function to be used in the Redux store configuration.</li> </ul> <p>Now your slice is ready to be added to the store.</p> <p>To add your slice to the store, configure the store with the <code>configureStore</code> function, which combines the slice reducers into the main root reducer.</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport cartReducer from './cartSlice'; // Adjust the path as needed\n\nconst appStore = configureStore({\n  reducer: {\n    cart: cartReducer, // Adding cart slice reducer to the store\n  },\n});\n\nexport default appStore;\n</code></pre>"},{"location":"react/lets-build-our-store/#redux-core-concepts","title":"\ud83d\udd04 Redux Core Concepts","text":""},{"location":"react/lets-build-our-store/#step-1-understanding-dispatch-in-redux","title":"\ud83d\udd04 Step 1: Understanding Dispatch in Redux","text":"<p>Dispatch is a function provided by Redux that allows you to send actions to the Redux store. These actions are plain JavaScript objects that describe what happened in your application, and the store uses them to update the state via reducer functions.</p>"},{"location":"react/lets-build-our-store/#how-to-import-and-use-dispatch","title":"\ud83d\udd27 How to Import and Use Dispatch","text":"<p>To use <code>dispatch</code> in a component, first import <code>useDispatch</code> from the <code>react-redux</code> library. Then, within your component, call <code>useDispatch</code> to get the <code>dispatch</code> function and use it to send actions to the Redux store.</p> <pre><code>import { useDispatch } from 'react-redux';\nimport { addItem } from './cartSlice';\n\nconst FoodieComponent = () =&gt; {\n  const dispatch = useDispatch();\n\n  const handleAddItem = () =&gt; {\n    dispatch(addItem(\"pizza\"));\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleAddItem}&gt;ADD | +&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FoodieComponent;\n</code></pre>"},{"location":"react/lets-build-our-store/#step-2-what-is-a-reducer","title":"\ud83d\udd04 Step 2: What is a Reducer?","text":"<p>A reducer is a pure function in Redux that takes the current state and an action as arguments and returns a new state. It determines how your application's state changes in response to actions dispatched to the store. Each reducer typically manages a specific slice of the application state.</p>"},{"location":"react/lets-build-our-store/#how-to-import-and-use-a-reducer","title":"\ud83d\udd27 How to Import and Use a Reducer","text":"<p>This is already covered above when creating a slice and defining reducers within the slice, along with an example.</p>"},{"location":"react/lets-build-our-store/#step-3-what-is-a-selector","title":"\ud83d\udd0d Step 3: What is a Selector","text":"<p>A selector in Redux is a function that extracts specific pieces of data from the Redux store. Selectors are used to read and retrieve state from the store so that components can use this data.</p>"},{"location":"react/lets-build-our-store/#how-to-import","title":"\ud83d\udd27 How to Import","text":"<p>Selectors are used with the <code>useSelector</code> hook from the <code>react-redux</code> library.</p> <pre><code>import { useSelector } from 'react-redux';\n\nconst CartComponent = () =&gt; {\n  const cartItemsCount = useSelector((state) =&gt; state.cart.items.length);\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Cart Items: {cartItemsCount}&lt;/h2&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CartComponent;\n</code></pre>"},{"location":"react/lets-build-our-store/#explanation_1","title":"\ud83d\udcc4 Explanation","text":"<ul> <li>useSelector: This hook is imported from <code>react-redux</code> and is used to access the Redux store\u2019s state.</li> <li>state.cart.items.length: The selector function retrieves the length of the <code>items</code> array from the <code>cart</code> slice, representing the number of items in the cart. This value is displayed in the <code>CartComponent</code>.</li> </ul> <p>This approach allows the <code>CartComponent</code> to dynamically update whenever the number of items in the cart changes.</p>"},{"location":"react/lets-build-our-store/#further-reading","title":"\ud83d\udcda Further Reading","text":"<ul> <li>Redux Official Documentation: For an in-depth look at Redux, including advanced concepts and best practices.</li> <li>React Redux Guide: Learn how to integrate Redux with React.</li> <li>Redux Toolkit: Explore the Redux Toolkit, the official, recommended way to write Redux logic, which simplifies store setup and reduces boilerplate.</li> <li>Redux Saga and Middleware: For managing complex asynchronous logic in Redux, consider looking into Redux Saga and other middleware options.</li> <li>Scaling Redux Applications: Learn best practices for scaling Redux to keep your codebase clean and manageable as your applications grow.</li> <li>From Setup to Mastery: Dive into Efficient State Management with Redux Toolkit in React</li> </ul>"},{"location":"react/lets-build-our-store/#understanding-onclick-handler-syntax-in-react","title":"\ud83d\udd18 Understanding <code>onClick</code> Handler Syntax in React","text":"<p>When handling click events in React, you have several ways to define the <code>onClick</code> handler. Here's a breakdown of the different approaches:</p>"},{"location":"react/lets-build-our-store/#1-onclickhandleadditem","title":"1. <code>onClick={handleAddItem}</code>","text":"<ul> <li>Direct Assignment: This syntax assigns the <code>handleAddItem</code> function directly to the <code>onClick</code> event.</li> <li>No Arguments: When the button is clicked, <code>handleAddItem</code> is called without any arguments.</li> </ul>"},{"location":"react/lets-build-our-store/#2-onclick-handleadditemitem","title":"2. <code>onClick={() =&gt; handleAddItem(item)}</code>","text":"<ul> <li>Arrow Function: Uses an arrow function to call <code>handleAddItem</code> with the <code>item</code> argument.</li> <li>Passing Arguments: Useful when you need to pass specific arguments to the <code>handleAddItem</code> function upon clicking.</li> <li>Scope Requirement: Ensure that <code>item</code> is defined or in scope when the button is rendered.</li> <li>Contextual Variable: If <code>item</code> is a variable available in the component\u2019s context, it will be passed to <code>handleAddItem</code> when clicked.</li> </ul>"},{"location":"react/lets-build-our-store/#3-onclickhandleadditemitem","title":"3. <code>onClick={handleAddItem(item)}</code>","text":"<ul> <li>Incorrect Usage: This syntax is incorrect and won't work as expected.</li> <li>Immediate Invocation: <code>handleAddItem(item)</code> is invoked immediately when the component renders, instead of waiting for the click event.</li> <li>Undefined Assignment: The return value of <code>handleAddItem(item)</code> (typically <code>undefined</code> unless it returns another function) is assigned to <code>onClick</code>.</li> <li>Proper Usage: To call <code>handleAddItem</code> with an argument when the button is clicked, wrap it in an anonymous function as shown in the second example.</li> </ul>"},{"location":"react/lets-build-our-store/#modern-redux-state-management","title":"\ud83d\udd04 Modern Redux State Management","text":"<p>Managing state in Redux has evolved over time. Here's how it has changed:</p>"},{"location":"react/lets-build-our-store/#older-redux-vanilla-redux","title":"Older Redux (Vanilla Redux)","text":"<ul> <li>Immutable State: Direct mutation of the state was not allowed.</li> <li>State Copying: Developers had to create a copy of the state and then modify it.</li> <li>Returning New State: After modifications, the new state had to be returned explicitly.</li> </ul>"},{"location":"react/lets-build-our-store/#new-redux-with-immer","title":"New Redux with Immer","text":"<ul> <li>Simplified Mutations: Redux now allows direct mutation of the state in reducers.</li> <li>Immer Integration: Redux uses the Immer library under the hood to handle immutable updates.</li> <li>No Need to Return State: It's no longer mandatory to return the state explicitly, as Immer manages it automatically.</li> <li>Developer Convenience: This change streamlines the state management process, reducing boilerplate code and potential errors.</li> </ul>"},{"location":"react/lets-build-our-store/#usecontext-vs-redux","title":"\ud83d\udd04 useContext vs Redux","text":"<p><code>useContext</code> and <code>Redux</code> are both tools used for state management in React applications, but they serve different purposes and have different use cases.</p>"},{"location":"react/lets-build-our-store/#usecontext","title":"\ud83c\udfaf useContext","text":"<ul> <li>Scope: Part of React core, used for managing state within the component tree. Provides direct access to context values within components and their descendants.</li> <li>Complexity: Simpler and lightweight, with no additional concepts or boilerplate code.</li> <li>Component Coupling: State is local to components where context is provided.</li> <li>Integration: Seamlessly integrates with React and component lifecycle.</li> </ul>"},{"location":"react/lets-build-our-store/#redux","title":"\ud83d\udd27 Redux","text":"<ul> <li>Scope: Global state management library providing centralized state container.</li> <li>Complexity: Introduces concepts like actions, reducers, and store. More complex but valuable for larger applications.</li> <li>Component Coupling: Global state accessible by any component.</li> <li>Integration: Requires separate integration with actions, reducers, and store setup.</li> </ul>"},{"location":"react/lets-build-our-store/#when-to-use","title":"\ud83e\udd14 When to Use?","text":"<p>useContext: - Small-scale state management needs - Lightweight solutions needed - Limited state sharing across components</p> <p>Redux: - Complex applications with large state - Predictable state management needed - Extensive state sharing required - Middleware for async actions needed</p>"},{"location":"react/lets-build-our-store/#advantages-of-redux-toolkit-over-redux","title":"\ud83d\udca1 Advantages of Redux Toolkit over Redux","text":"<ol> <li>Less Boilerplate: Reduces repetitive code</li> <li>Easier Async Operations: Simplified handling with <code>createAsyncThunk</code></li> <li>Simple Store Setup: Easy configuration with <code>configureStore</code></li> <li>Built-in DevTools Support: Seamless debugging integration</li> <li>Best Practices: Follows Redux development standards</li> <li>Automatic Immutability: Uses Immer for data handling</li> <li>Backward Compatibility: Works with existing Redux code</li> <li>Faster Development: Reduced setup time</li> </ol> <p>Redux Toolkit streamlines Redux development by providing essential tools and simplifying common tasks, making it an excellent choice for both new projects and existing applications.</p>"},{"location":"react/lets-get-classy/","title":"08: Let's Get Classy","text":""},{"location":"react/lets-get-classy/#creating-class-based-components","title":"Creating Class-Based Components","text":"<pre><code>import React from 'react';\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default User;\n</code></pre>"},{"location":"react/lets-get-classy/#why-do-we-need-superprops","title":"Why do we need super(props)?","text":"<ul> <li><code>super(props)</code> allows access to <code>this.props</code> in a constructor function.</li> <li>The <code>super()</code> function calls the constructor of the parent class.</li> <li>When we call <code>super(props)</code>, we're calling the constructor of <code>React.Component</code>.</li> <li><code>super()</code> is a reference to the parent class constructor (<code>React.Component</code>).</li> <li>If we want to use <code>this.props</code> or <code>this</code> keyword inside the constructor, we need to pass props to <code>super()</code>.</li> </ul> <p>Note</p> <ul> <li>Loading a functional component means invoking/mounting that function.</li> <li>Loading a class-based component means creating an instance of the class.</li> </ul>"},{"location":"react/lets-get-classy/#creating-state-variables-in-class-based-components","title":"Creating State Variables in Class-Based Components","text":"<pre><code>import React from 'react';\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'John',\n      age: 25\n    };\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, {this.state.name}&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default User;\n</code></pre>"},{"location":"react/lets-get-classy/#using-destructuring","title":"Using Destructuring","text":"<pre><code>import React from 'react';\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'John',\n      age: 25\n    };\n  }\n\n  render() {\n    const { name, age } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, {name}&lt;/h1&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default User;\n</code></pre>"},{"location":"react/lets-get-classy/#updating-state-variables","title":"Updating State Variables","text":"<pre><code>import React from 'react';\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'John',\n      age: 25\n    };\n  }\n\n  updateName = () =&gt; {\n    this.setState({ name: 'Doe' });\n  };\n\n  render() {\n    const { name, age } = this.state;\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, {name}&lt;/h1&gt;\n        &lt;button onClick={this.updateName}&gt;Update Name&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nexport default User;\n</code></pre> <p>Important Notes</p> <ul> <li>When updating state, React will only modify the specified state variables and preserve others.</li> <li>Loading a component means mounting it on a web page.</li> <li>When a class-based component loads, the constructor is called first, followed by the render() method.</li> </ul>"},{"location":"react/lets-get-classy/#react-lifecycle-methods","title":"React Lifecycle Methods","text":""},{"location":"react/lets-get-classy/#basic-component-structure","title":"Basic Component Structure","text":"<pre><code>import React from 'react';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log('Parent constructor called');\n  }\n\n  componentDidMount() {\n    console.log('Parent Component did mount');\n  }\n\n  render() {\n    console.log('Parent Component rendered');\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;Hello, World!&lt;/h1&gt;\n        &lt;Child /&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"react/lets-get-classy/#lifecycle-phases","title":"Lifecycle Phases","text":""},{"location":"react/lets-get-classy/#1-mounting-phase-birth-of-component","title":"1. Mounting Phase (Birth of Component)","text":"<p>Components go through these methods in order:</p> <ol> <li> <p>constructor()</p> <ul> <li>Called first when component initializes</li> <li>Used to set initial state and bind methods</li> <li>Called only once</li> </ul> </li> <li> <p>render()</p> <ul> <li>Required method</li> <li>Returns JSX to display</li> <li>Pure function - should not modify state</li> </ul> </li> <li> <p>componentDidMount()</p> <ul> <li>Called after component is mounted to DOM</li> <li>Perfect for API calls, subscriptions, or DOM manipulations</li> <li>Called only once after first render</li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#2-updating-phase-growth-of-component","title":"2. Updating Phase (Growth of Component)","text":"<p>Occurs when props or state changes:</p> <ol> <li> <p>render()</p> <ul> <li>Called whenever there's an update</li> <li>Re-renders component with new changes</li> </ul> </li> <li> <p>componentDidUpdate(prevProps, prevState)</p> <ul> <li>Called after component updates</li> <li>Good for side effects after state/prop changes</li> <li>Can compare previous and current props/state</li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#3-unmounting-phase-death-of-component","title":"3. Unmounting Phase (Death of Component)","text":"<ol> <li>componentWillUnmount()<ul> <li>Called right before component is removed from DOM</li> <li>Used for cleanup (removing event listeners, cancelling API calls)</li> <li>Last lifecycle method to be called</li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#execution-order","title":"Execution Order","text":""},{"location":"react/lets-get-classy/#single-child-component-flow","title":"Single Child Component Flow","text":"<pre><code>Constructor (Parent)\n  \u2192 render (Parent)\n    \u2192 Constructor (Child)\n      \u2192 render (Child)\n        \u2192 componentDidMount (Child)\n          \u2192 componentDidMount (Parent)\n</code></pre>"},{"location":"react/lets-get-classy/#multiple-children-components-flow","title":"Multiple Children Components Flow","text":"<pre><code>1. Constructor (Parent)\n2. Render (Parent)\n3. Constructor (Child 1)\n4. Render (Child 1)\n5. Constructor (Child 2)\n6. Render (Child 2)\n7. componentDidMount (Child 1)\n8. componentDidMount (Child 2)\n9. componentDidMount (Parent)\n</code></pre>"},{"location":"react/lets-get-classy/#react-lifecycle-phases","title":"React Lifecycle Phases","text":""},{"location":"react/lets-get-classy/#1-render-phase","title":"1. Render Phase","text":"<ul> <li>Includes constructor() and render()</li> <li>Can be interrupted</li> <li>Pure and has no side effects</li> <li>May be executed multiple times</li> </ul>"},{"location":"react/lets-get-classy/#2-commit-phase","title":"2. Commit Phase","text":"<ul> <li>Includes componentDidMount()</li> <li>Updates the DOM</li> <li>Can work with side effects</li> <li>Runs only once per update</li> </ul>"},{"location":"react/lets-get-classy/#example-with-console-output","title":"Example with Console Output","text":"<pre><code>class Child extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'John'\n    };\n    console.log('Child constructor called');\n  }\n\n  componentDidMount() {\n    console.log('Child Component did mount');\n  }\n\n  componentDidUpdate() {\n    console.log('Child Component did update');\n  }\n\n  componentWillUnmount() {\n    console.log('Child Component will unmount');\n  }\n\n  render() {\n    console.log('Child Component rendered');\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;Hello, Child!&lt;/h2&gt;\n        &lt;p&gt;{this.state.name}&lt;/p&gt;\n        &lt;button onClick={() =&gt; this.setState({ name: 'Doe' })}&gt;Update Name&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre> <p>Console output: <pre><code>Parent constructor called\nParent Component rendered\nChild constructor called\nChild Component rendered\nChild Component did mount\nParent Component did mount\n</code></pre></p> <p>When the button is clicked to change the name: <pre><code>Child Component rendered\nChild Component did update\n</code></pre></p> <p>When the component is about to be removed: <pre><code>Child Component will unmount\n</code></pre></p>"},{"location":"react/lets-get-classy/#performance-notes","title":"Performance Notes","text":"<ul> <li>React batches the constructor and render methods of children components</li> <li>DOM updates are expensive, so they're batched in the commit phase</li> <li>React batches all constructor methods and render methods of children components and only performs the commit phase once there are no more child components to process</li> <li>This batching optimization helps in better performance, especially with multiple children</li> </ul>"},{"location":"react/lets-get-classy/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use componentDidMount for:</p> <ul> <li>API calls</li> <li>Subscriptions</li> <li>DOM manipulations</li> </ul> </li> <li> <p>Use componentWillUnmount for:</p> <ul> <li>Clearing timers</li> <li>Cancelling API calls</li> <li>Removing event listeners</li> </ul> <pre><code>// Example of proper cleanup\ncomponentDidMount() {\n  this.timer = setInterval(() =&gt; {}, 1000);\n}\n\ncomponentWillUnmount() {\n  clearInterval(this.timer);\n}\n</code></pre> </li> <li> <p>Use componentDidUpdate for:</p> <ul> <li>Network requests based on prop changes</li> <li>DOM manipulations after update</li> </ul> </li> </ol> <p>Note: Modern React encourages the use of functional components with Hooks, which provide a more straightforward way to handle lifecycle events through useEffect.</p> <p>Info</p> <p>Find React lifecycle methods diagram here.</p>"},{"location":"react/lets-get-classy/#questions-and-answers","title":"Questions and Answers","text":""},{"location":"react/lets-get-classy/#q1-what-is-the-order-of-lifecycle-method-calls-in-class-based-components","title":"Q1. What is the order of lifecycle method calls in Class-Based Components?","text":"<ol> <li> <p>Constructor    The constructor is the first method called when a component is created. It initializes the component's state and binds event handlers.</p> </li> <li> <p>Render    The render method generates the component's UI. It must return a React element (usually JSX) representing the component's structure.</p> </li> <li> <p>componentDidMount    This method is invoked immediately after the component is added to the DOM. It is commonly used for making AJAX requests, setting up subscriptions, or performing other initializations.</p> </li> <li> <p>componentDidUpdate    Called after the component updates (re-renders) due to changes in state or props. It's often used for side effects, such as updating the DOM in response to state or prop changes.</p> </li> <li> <p>componentWillUnmount    This method is called just before the component is removed from the DOM. It's used to clean up resources, such as removing event listeners or canceling network requests.</p> </li> </ol> <p>For more information, refer to React Lifecycle Methods.</p>"},{"location":"react/lets-get-classy/#q2-why-do-we-use-componentdidmount","title":"Q2. Why do we use <code>componentDidMount</code>?","text":"<p>The <code>componentDidMount</code> lifecycle method in React class-based components is used for tasks that need to occur after the component is inserted into the DOM. This is crucial for:</p> <ul> <li> <p>Fetching Data   Making asynchronous requests to APIs or external sources to retrieve dynamic content.</p> </li> <li> <p>DOM Manipulation   Interacting directly with the DOM, such as selecting elements, setting attributes, or integrating third-party libraries that require DOM elements to be present.</p> </li> </ul>"},{"location":"react/lets-get-classy/#example","title":"Example:","text":"<pre><code>class MyComponent extends React.Component {\n  componentDidMount() {\n    // Fetch data from an API\n    fetch('https://api.example.com/data')\n      .then(response =&gt; response.json())\n      .then(data =&gt; {\n        // Update the component's state with the fetched data\n        this.setState({ data });\n      })\n      .catch(error =&gt; {\n        // Handle any errors\n        console.error(error);\n      });\n  }\n\n  render() {\n    // Render component based on state\n    return (\n      &lt;div&gt;{/* Display data from this.state.data */}&lt;/div&gt;\n    );\n  }\n}\n</code></pre> <p>By using <code>componentDidMount</code>, data fetching or other side effects occur after the initial render, ensuring proper interaction with the DOM or external data sources.</p>"},{"location":"react/lets-get-classy/#q3-why-do-we-use-componentwillunmount-show-with-an-example","title":"Q3. Why do we use <code>componentWillUnmount</code>? Show with an example.","text":"<p>The <code>componentWillUnmount</code> lifecycle method in React class-based components is used to perform cleanup tasks just before a component is removed from the DOM. This helps prevent memory leaks and ensures that resources are properly released.</p> <p>Uses of <code>componentWillUnmount</code>:</p> <ol> <li> <p>Cleanup Resources    Release any resources the component has allocated, such as event listeners, subscriptions, or timers.</p> </li> <li> <p>Cancel Pending Requests    Abort any ongoing asynchronous operations like AJAX calls or timers to avoid unexpected behavior after the component is unmounted.</p> </li> </ol>"},{"location":"react/lets-get-classy/#example_1","title":"Example:","text":"<pre><code>class MyComponent extends React.Component {\n  constructor() {\n    super();\n    this.handleResize = this.handleResize.bind(this);\n  }\n\n  componentDidMount() {\n    // Add a window resize event listener when the component mounts\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    // Remove the window resize event listener when the component unmounts\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleResize(event) {\n    // Handle the resize event\n    console.log('Window resized:', event);\n  }\n\n  render() {\n    return &lt;div&gt;My Component&lt;/div&gt;;\n  }\n}\n</code></pre> <p>In this example, the component adds a resize event listener when it mounts and removes it just before unmounting, ensuring no memory leaks occur.</p>"},{"location":"react/lets-get-classy/#q4-why-cant-we-have-the-callback-function-of-useeffect-async","title":"Q4. Why can't we have the callback function of <code>useEffect</code> async?","text":"<p>In React, the <code>useEffect</code> hook manages side effects in functional components. However, its callback function cannot be asynchronous (i.e., it cannot return a Promise) for the following reasons:</p> <ol> <li> <p>Return Value Expectation    The <code>useEffect</code> callback should return either nothing or a cleanup function. An async function returns a Promise, which doesn't align with what React expects.</p> </li> <li> <p>Execution Order and Timing    Async functions can complicate the control over the execution order of side effects and cleanup. React relies on the cleanup function to manage resources when components unmount or dependencies change. Returning a Promise disrupts this mechanism.</p> </li> </ol>"},{"location":"react/lets-get-classy/#proper-pattern-for-using-async-operations-in-useeffect","title":"Proper Pattern for Using Async Operations in <code>useEffect</code>:","text":"<pre><code>import React, { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    // Define the async function inside useEffect\n    const fetchData = async () =&gt; {\n      try {\n        // Perform asynchronous operations\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        // Update the state with the fetched data\n        setData(result);\n      } catch (error) {\n        // Handle errors\n        console.error(error);\n      }\n    };\n\n    fetchData(); // Call the async function\n\n    return () =&gt; {\n      // Cleanup code, if necessary\n      // This function runs when the component unmounts or dependencies change\n    };\n  }, []); // Dependency array\n\n  return (\n    &lt;div&gt;\n      {/* Render your data here */}\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>In this pattern:</p> <ul> <li>An async function <code>fetchData</code> is defined within the <code>useEffect</code> callback.</li> <li>The async function is invoked immediately.</li> <li>A cleanup function is optionally returned to handle any necessary cleanup when the component unmounts or dependencies change.</li> </ul> <p>This approach allows you to manage asynchronous operations effectively while adhering to React's expectations for the <code>useEffect</code> callback's return value.</p>"},{"location":"react/lets-get-classy/#what-are-lifecycle-hooks-or-lifecycle-methods-in-react","title":"\ud83d\udd04 What Are Lifecycle Hooks or Lifecycle Methods in React?","text":"<p>These are methods that allow you to run code at specific stages in a component's lifecycle, such as when it is created, updated, or destroyed. With the introduction of React Hooks in version 16.8, functional components gained the ability to manage side effects and lifecycle events using hooks like <code>useEffect</code>.</p>"},{"location":"react/lets-get-classy/#lifecycle-methods-in-class-components","title":"Lifecycle Methods in Class Components","text":"<p>In class components, React provides specific methods to handle lifecycle events:</p> <ol> <li> <p>Mounting Phase:</p> <ul> <li><code>constructor()</code>: Called when the component is initialized.</li> <li><code>render()</code>: Renders the component's UI.</li> <li><code>componentDidMount()</code>: Called after the component is mounted to the DOM.</li> </ul> </li> <li> <p>Updating Phase:</p> <ul> <li><code>shouldComponentUpdate()</code>: Determines if the component should re-render.</li> <li><code>render()</code>: Re-renders the component's UI.</li> <li><code>componentDidUpdate()</code>: Called after the component is updated.</li> </ul> </li> <li> <p>Unmounting Phase:</p> <ul> <li><code>componentWillUnmount()</code>: Called before the component is removed from the DOM.</li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#lifecycle-hooks-in-functional-components","title":"Lifecycle Hooks in Functional Components","text":"<p>In functional components, React Hooks (like <code>useEffect</code>) replace lifecycle methods:</p> <ol> <li> <p>Mounting Phase:</p> <ul> <li>Use <code>useEffect</code> with an empty dependency array (<code>[]</code>) to mimic <code>componentDidMount</code>. <pre><code>useEffect(() =&gt; {\n  console.log(\"Component mounted\");\n}, []);\n</code></pre></li> </ul> </li> <li> <p>Updating Phase:</p> <ul> <li>Use <code>useEffect</code> with dependencies to mimic <code>componentDidUpdate</code>. <pre><code>useEffect(() =&gt; {\n  console.log(\"Component updated\");\n}, [someDependency]); // Runs when `someDependency` changes\n</code></pre></li> </ul> </li> <li> <p>Unmounting Phase:</p> <ul> <li>Return a cleanup function in <code>useEffect</code> to mimic <code>componentWillUnmount</code>. <pre><code>useEffect(() =&gt; {\n  return () =&gt; {\n    console.log(\"Component will unmount\");\n  };\n}, []);\n</code></pre></li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#key-differences","title":"Key Differences","text":"<ul> <li>Class Components: Lifecycle methods are explicit and tied to the class structure.</li> <li>Functional Components: Hooks like <code>useEffect</code> provide a more flexible and concise way to handle lifecycle events.</li> </ul>"},{"location":"react/lets-get-classy/#example-lifecycle-in-functional-components","title":"Example: Lifecycle in Functional Components","text":"<pre><code>import React, { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  // Mounting\n  useEffect(() =&gt; {\n    console.log(\"Component mounted\");\n\n    // Unmounting\n    return () =&gt; {\n      console.log(\"Component will unmount\");\n    };\n  }, []);\n\n  // Updating\n  useEffect(() =&gt; {\n    console.log(\"Count updated:\", count);\n  }, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default MyComponent;\n</code></pre>"},{"location":"react/lets-get-classy/#summary","title":"Summary","text":"<ul> <li>Lifecycle hooks in React refer to methods or hooks that allow you to manage a component's lifecycle.</li> <li>In class components, lifecycle methods like <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> are used.</li> <li>In functional components, the <code>useEffect</code> hook replaces these lifecycle methods, providing a more modern and flexible approach.</li> </ul>"},{"location":"react/lets-get-classy/#why-usestate-is-not-a-lifecycle-hook","title":"\ud83d\udeab Why <code>useState</code> is Not a Lifecycle Hook","text":"<ol> <li> <p>Purpose:</p> <ul> <li><code>useState</code> manages state, not lifecycle events like mounting, updating, or unmounting.</li> <li>Lifecycle hooks are specifically tied to a component's lifecycle (e.g., creation, update, destruction).</li> </ul> </li> <li> <p>Behavior:</p> <ul> <li><code>useState</code> initializes state when the component first renders and preserves it across re-renders.</li> <li>It doesn't run code during component lifecycle events like mount or unmount.</li> </ul> </li> <li> <p>Lifecycle Hooks vs. State Hooks:</p> <ul> <li>Lifecycle hooks (e.g., <code>useEffect</code>) perform side effects at specific points in the component's lifecycle.</li> <li><code>useState</code> is solely for managing and updating state within the component.</li> </ul> </li> </ol>"},{"location":"react/lets-get-classy/#how-usestate-relates-to-lifecycle","title":"\ud83d\udd04 How <code>useState</code> Relates to Lifecycle","text":"<p>While <code>useState</code> itself isn't a lifecycle hook, it interacts with lifecycle events indirectly:</p> <ul> <li>Mounting: <code>useState</code> initializes the state when the component mounts.</li> <li>Updating: Updating the state with the setter function (e.g., <code>setCount</code>) triggers a re-render, which is part of the component's update lifecycle.</li> <li>However, <code>useState</code> doesn\u2019t directly handle lifecycle events like mounting or unmounting.</li> </ul>"},{"location":"react/lets-get-classy/#example-usestate-and-lifecycle","title":"\ud83d\udca1 Example: <code>useState</code> and Lifecycle","text":"<p>Here\u2019s how <code>useState</code> and <code>useEffect</code> (a lifecycle hook) work together:</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  // Lifecycle hook: runs on mount and when `count` changes\n  useEffect(() =&gt; {\n    console.log(\"Count updated:\", count);\n  }, [count]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default MyComponent;\n</code></pre> <ul> <li><code>useState</code> manages the <code>count</code> state.</li> <li><code>useEffect</code> listens for changes to <code>count</code> and logs updates, demonstrating lifecycle behavior.</li> </ul>"},{"location":"react/lets-get-classy/#summary_1","title":"\ud83d\udcdd Summary","text":"<ul> <li><code>useState</code> is a state management hook, not a lifecycle hook.</li> <li>It is used to declare and update state in functional components.</li> <li>Lifecycle hooks like <code>useEffect</code> handle side effects and lifecycle events.</li> <li>While <code>useState</code> interacts with the component's lifecycle indirectly (e.g., triggering re-renders), its primary role is state management, not lifecycle control.</li> </ul>"},{"location":"react/lets-get-classy/#how-react-detects-successful-component-rendering","title":"\ud83d\udd0d How React Detects Successful Component Rendering?","text":"<p>You're absolutely right! React relies on the browser's rendering engine to determine when a component has been successfully rendered and mounted into the DOM. This process involves a combination of React's internal mechanisms and the browser's rendering pipeline. Let\u2019s explore how React and the browser work together to determine when a component is mounted and when to trigger lifecycle methods like <code>componentDidMount</code> or the equivalent <code>useEffect</code> hook.</p>"},{"location":"react/lets-get-classy/#how-react-and-the-browser-work-together","title":"\ud83e\udd1d How React and the Browser Work Together","text":""},{"location":"react/lets-get-classy/#1-reacts-rendering-process","title":"1. React's Rendering Process","text":"<ul> <li>React uses a virtual DOM to represent the UI. When a component is rendered, React creates a virtual DOM tree and compares it with the previous one to determine the minimal set of changes needed (a process called reconciliation).</li> <li>Once React identifies the changes, it schedules them to be applied to the actual DOM.</li> </ul>"},{"location":"react/lets-get-classy/#2-browsers-rendering-pipeline","title":"2. Browser's Rendering Pipeline","text":"<ul> <li>The browser follows its own rendering pipeline, which includes:<ol> <li>Layout/Reflow: Calculating the size and position of elements.</li> <li>Paint: Rendering pixels on the screen.</li> <li>Composite: Combining layers to display the final result.</li> </ol> </li> <li>React interacts with the browser's DOM API (e.g., <code>document.createElement</code>, <code>appendChild</code>) to apply changes to the actual DOM.</li> </ul>"},{"location":"react/lets-get-classy/#3-mounting-and-lifecycle-events","title":"3. Mounting and Lifecycle Events","text":"<ul> <li>When React updates the DOM, it ensures the browser completes its rendering process (layout, paint, composite).</li> <li>Once the browser has rendered the component's elements into the DOM, React considers the component \"mounted.\"</li> </ul>"},{"location":"react/lets-get-classy/#how-react-triggers-componentdidmount-or-useeffect","title":"\ud83d\ude80 How React Triggers <code>componentDidMount</code> or <code>useEffect</code>","text":""},{"location":"react/lets-get-classy/#1-reacts-fiber-architecture","title":"1. React's Fiber Architecture","text":"<ul> <li>React uses a fiber tree to manage component lifecycles. Each component is a fiber node with metadata about its lifecycle state.</li> <li>React's scheduler monitors the progress of rendering and mounting components.</li> </ul>"},{"location":"react/lets-get-classy/#2-commit-phase_1","title":"2. Commit Phase","text":"<ul> <li>React's rendering process has two phases:<ol> <li>Render Phase: React generates the virtual DOM and determines necessary changes.</li> <li>Commit Phase: React applies these changes to the actual DOM.</li> </ol> </li> <li>During the commit phase, React updates the DOM and schedules lifecycle methods (like <code>componentDidMount</code>) or hooks (like <code>useEffect</code>) to run after the DOM update.</li> </ul>"},{"location":"react/lets-get-classy/#3-browsers-feedback-to-react","title":"3. Browser's Feedback to React","text":"<ul> <li>React doesn't directly wait for the browser to finish rendering. Instead, it assumes that once DOM updates are applied (e.g., using <code>appendChild</code>), the component is mounted.</li> <li>The browser processes these updates asynchronously, but React only needs to ensure the DOM nodes have been inserted.</li> </ul>"},{"location":"react/lets-get-classy/#4-lifecycle-method-execution","title":"4. Lifecycle Method Execution","text":"<ul> <li>After committing changes to the DOM, React schedules the <code>componentDidMount</code> method (for class components) or the <code>useEffect</code> hook (for functional components) to run.</li> <li>These methods/hooks execute after the component's elements are in the DOM, ensuring the component is fully mounted.</li> </ul>"},{"location":"react/lets-get-classy/#example-react-and-browser-interaction","title":"\ud83d\udee0\ufe0f Example: React and Browser Interaction","text":""},{"location":"react/lets-get-classy/#class-component-componentdidmount","title":"Class Component (<code>componentDidMount</code>)","text":"<pre><code>class MyComponent extends React.Component {\n  componentDidMount() {\n    console.log(\"Component is mounted!\");\n  }\n\n  render() {\n    return &lt;div&gt;Hello, World!&lt;/div&gt;;\n  }\n}\n</code></pre> <ol> <li>React creates the virtual DOM for <code>MyComponent</code>.</li> <li>React updates the actual DOM using the browser's DOM API.</li> <li>Once the DOM is updated, React calls <code>componentDidMount</code>.</li> </ol>"},{"location":"react/lets-get-classy/#functional-component-useeffect","title":"Functional Component (<code>useEffect</code>)","text":"<pre><code>import React, { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() =&gt; {\n    console.log(\"Component is mounted!\");\n  }, []); // Runs only once after mount\n\n  return &lt;div&gt;Hello, World!&lt;/div&gt;;\n}\n</code></pre> <ol> <li>React creates the virtual DOM for <code>MyComponent</code>.</li> <li>React updates the actual DOM using the browser's DOM API.</li> <li>Once the DOM is updated, React schedules the <code>useEffect</code> callback to run.</li> </ol>"},{"location":"react/lets-get-classy/#key-points","title":"\ud83d\udccc Key Points","text":"<ul> <li>React uses the browser's DOM API to insert, update, or remove elements.</li> <li>React considers a component mounted once DOM updates are applied.</li> <li>React's fiber architecture and scheduler manage component lifecycles, ensuring lifecycle methods or hooks execute at the right time.</li> <li>The browser handles the actual rendering (layout, paint, composite), but React doesn't wait for these steps to complete before firing lifecycle methods.</li> </ul>"},{"location":"react/lets-get-classy/#summary_2","title":"\ud83d\udcdd Summary","text":"<p>React determines that a component is mounted by successfully applying changes to the DOM using the browser's DOM API. Once the DOM is updated, React schedules lifecycle methods like <code>componentDidMount</code> or hooks like <code>useEffect</code> to run. The browser's rendering engine handles the actual rendering process, but React only ensures that the DOM nodes have been inserted without waiting for the rendering to finish. This collaboration between React's internal mechanisms and the browser's rendering pipeline ensures that lifecycle methods are triggered at the appropriate time.</p>"},{"location":"react/lets-get-hooked/","title":"05 - Let's Get Hooked","text":""},{"location":"react/lets-get-hooked/#why-use-react","title":"Why Use React?","text":"<p>You might wonder why we don't just stick to HTML, CSS, and JavaScript for everything. While it's entirely possible to build applications using these technologies alone, we choose React because it enhances the developer experience, making development more seamless and efficient.</p> <p>Info</p> <p>Learn more about the React folder structure.</p>"},{"location":"react/lets-get-hooked/#export-and-import-in-react","title":"Export and Import in React","text":""},{"location":"react/lets-get-hooked/#1-named-exportimport","title":"1. Named Export/Import","text":"<ul> <li>Export: <pre><code>export const name = 'John';\n</code></pre></li> <li>Import: <pre><code>import { name } from './file.js';\n</code></pre></li> <li>You can have multiple named exports in a single file.</li> </ul>"},{"location":"react/lets-get-hooked/#2-default-exportimport","title":"2. Default Export/Import","text":"<ul> <li>Export: <pre><code>export default name;\n</code></pre></li> <li>Import: <pre><code>import name from './file.js';\n</code></pre></li> <li>Only one default export is allowed per file.</li> </ul>"},{"location":"react/lets-get-hooked/#can-you-use-default-export-with-named-exports","title":"Can You Use Default Export with Named Exports?","text":"<p>Yes, you can combine default exports with named exports in the same file.</p>"},{"location":"react/lets-get-hooked/#react-hooks","title":"React Hooks","text":"<p>Hooks are regular JavaScript functions provided by React that add powerful features to your components. When you install React via npm, you gain access to these hooks.</p>"},{"location":"react/lets-get-hooked/#common-hooks","title":"Common Hooks","text":""},{"location":"react/lets-get-hooked/#usestate","title":"<code>useState()</code>","text":"<ul> <li>Usage: <pre><code>const [list, setList] = useState([]);\n</code></pre></li> <li>Description:</li> <li>Returns a state variable and a function to update it.</li> <li>When the state updates, React re-renders the component.</li> </ul>"},{"location":"react/lets-get-hooked/#useeffect","title":"<code>useEffect()</code>","text":"<ul> <li>Used to perform side effects in functional components, such as data fetching or subscribing to events.</li> </ul>"},{"location":"react/lets-get-hooked/#important-notes-on-state","title":"Important Notes on State","text":"<ul> <li>Updating a state variable triggers React's reconciliation cycle, which determines what changes need to be made to the UI.</li> <li>React keeps the data layer in sync with the UI layer using a reconciliation algorithm, ensuring efficient updates.</li> </ul>"},{"location":"react/lets-get-hooked/#reconciliation-and-rendering","title":"Reconciliation and Rendering","text":"<p>Understanding the distinction between reconciliation and rendering is crucial for grasping how React optimizes updates.</p>"},{"location":"react/lets-get-hooked/#what-is-reconciliation","title":"What is Reconciliation?","text":"<p>Reconciliation is the process React uses to determine what has changed in the virtual DOM compared to the previous version. Here's a breakdown:</p> <ol> <li>Virtual DOM Creation: When you render a React application, React creates a virtual DOM tree that represents the UI.</li> <li>Update Trigger: When there's a change in state or props, React generates a new virtual DOM tree.</li> <li>Diffing (Reconciliation): React compares the new virtual DOM with the previous virtual DOM to identify what has changed.</li> <li>Calculating Minimum Updates: Based on the differences, React calculates the minimal set of changes needed to update the real DOM.</li> </ol> <p>Key Points: - Efficiency: Reconciliation ensures that only the necessary parts of the DOM are updated, enhancing performance. - Stability with Keys: When dealing with lists, using stable and unique keys helps React efficiently manage and update elements.</p>"},{"location":"react/lets-get-hooked/#what-is-rendering","title":"What is Rendering?","text":"<p>Rendering is the phase where React updates the real DOM based on the results of the reconciliation process.</p> <ol> <li>Applying Changes: After reconciliation, React applies the calculated changes to the real DOM.</li> <li>Updating the UI: This ensures the user interface reflects the current state of the application.</li> </ol> <p>Key Points: - Separation of Concerns: Reconciliation handles the \"what\" needs to change, while rendering handles the \"how\" to make those changes happen in the UI. - Performance Optimization: By separating these phases, React can optimize rendering performance, ensuring smooth and efficient updates.</p>"},{"location":"react/lets-get-hooked/#the-diff-algorithm","title":"The Diff Algorithm","text":"<p>The diff algorithm is a crucial part of the reconciliation process. It identifies the differences between the updated virtual DOM and the previous virtual DOM, allowing React to update only what has changed.</p> <p>Benefits:</p> <ul> <li>Optimized Rendering: By updating only the necessary parts of the DOM, React minimizes performance overhead.</li> <li>Predictable Updates: The diffing process ensures that changes are applied consistently and accurately.</li> </ul>"},{"location":"react/lets-get-hooked/#why-is-react-fast","title":"Why is React Fast?","text":"<p>React's speed is largely attributed to React Fiber, a reimplementation of React's core algorithm. Fiber introduces several enhancements that optimize React's performance and responsiveness. It's released as part of React 16.</p>"},{"location":"react/lets-get-hooked/#key-features-of-react-fiber","title":"Key Features of React Fiber","text":"<ul> <li>Incremental Rendering: Splits rendering work into smaller chunks that can be spread over multiple frames. This ensures that high-priority updates, like user interactions, are handled promptly without being blocked by less critical tasks.</li> <li>Optimized for Animation, Layout, and Gestures: Enhances performance in dynamic interfaces by efficiently managing complex updates.</li> <li>Concurrency Primitives: Introduces new tools that allow React to handle multiple tasks simultaneously, improving the overall user experience.</li> </ul>"},{"location":"react/lets-get-hooked/#how-react-fiber-enhances-performance","title":"How React Fiber Enhances Performance","text":"<ol> <li>Scheduling Work: Fiber allows React to prioritize work based on its importance, ensuring that critical updates are processed first.</li> <li>Pausing and Resuming: Fiber can pause ongoing work to handle higher priority tasks and then resume the paused work later.</li> <li>Resource Management: By breaking down tasks, Fiber ensures that the application remains responsive, even under heavy load.</li> </ol>"},{"location":"react/lets-get-hooked/#integrating-with-other-libraries","title":"Integrating with Other Libraries","text":"<p>React works well with libraries like GSAP (GreenSock Animation Platform) and Three.js for creating animations and 3D designs. These integrations leverage React's efficient rendering and state management to produce smooth and interactive user experiences.</p>"},{"location":"react/lets-get-hooked/#how-it-works-behind-the-scenes","title":"How It Works Behind the Scenes","text":"<p>To understand React's efficiency, it's essential to grasp the interplay between the virtual DOM, reconciliation, rendering, and React Fiber.</p> <ol> <li>Virtual DOM: React creates virtual DOM objects that replicate real DOM elements. This lightweight representation allows React to manage UI updates efficiently.</li> <li>Reconciliation: When changes occur, React uses the diff algorithm to compare the new virtual DOM with the previous one, determining the minimal set of changes required.</li> <li>Rendering: Based on the reconciliation results, React updates only the necessary parts of the real DOM, ensuring optimal performance.</li> <li>React Fiber: Fiber enhances this entire process by introducing incremental rendering and improved scheduling, ensuring that updates are handled smoothly without compromising the application's responsiveness.</li> </ol> <p>Flow Summary:</p> <ul> <li>State Change: Triggers an update in the virtual DOM.</li> <li>Reconciliation: Compares new and old virtual DOMs to find differences.</li> <li>Rendering: Updates the real DOM based on these differences.</li> <li>Fiber's Role: Manages the scheduling and execution of these tasks to optimize performance.</li> </ul> <p>Info</p> <p>Learn more about the React Fiber Architecture.</p>"},{"location":"react/optimizing-our-app/","title":"09 - Optimizing our app","text":""},{"location":"react/optimizing-our-app/#what-is-the-single-responsibility-principle","title":"What is the Single Responsibility Principle?","text":"<ul> <li>A function, class, or any single entity in an app should have only one responsibility.</li> <li>For example, the <code>&lt;Header&gt;</code> component should solely display the application's header.</li> <li>If a component performs multiple tasks, it should be divided into smaller components, each with a single responsibility.</li> <li>Breaking down the code into small modules promotes modularity.</li> </ul>"},{"location":"react/optimizing-our-app/#benefits-of-the-single-responsibility-principle","title":"Benefits of the Single Responsibility Principle","text":"<ul> <li>Reusability: Components with single responsibilities can be reused in different parts of the application.</li> <li>Maintainability: It's easier to maintain and update code when each component has a clear and distinct purpose.</li> <li>Testability: Components with single responsibilities are easier to test and debug.</li> </ul>"},{"location":"react/optimizing-our-app/#what-is-a-custom-hook","title":"\ud83e\udd14 What is a Custom Hook?","text":"<ul> <li>A hook is nothing more than a utility function.</li> <li>Hooks are reusable functions.</li> <li>When you have component logic that needs to be used by multiple components, you can extract that logic to a custom hook.</li> <li>A custom hook in React is a JavaScript function that allows you to extract and reuse logic involving stateful behavior and side effects from function components.</li> <li>Custom hooks enable you to encapsulate common logic in a way that can be shared across multiple components, promoting code reuse and better organization.</li> </ul>"},{"location":"react/optimizing-our-app/#why-use-custom-hooks","title":"\ud83c\udf1f Why Use Custom Hooks?","text":""},{"location":"react/optimizing-our-app/#a-code-reusability","title":"a. \ud83d\udee0\ufe0f Code Reusability","text":"<p>Custom hooks allow you to reuse stateful logic across different components without duplicating code.</p>"},{"location":"react/optimizing-our-app/#b-cleaner-components","title":"b. \ud83e\uddf9 Cleaner Components","text":"<p>By extracting complex logic into custom hooks, you can keep your components smaller and more focused on rendering.</p>"},{"location":"react/optimizing-our-app/#c-separation-of-concerns","title":"c. \ud83d\udd04 Separation of Concerns","text":"<p>Custom hooks help separate the logic from the UI, making your code easier to manage and understand.</p>"},{"location":"react/optimizing-our-app/#file-naming-convention","title":"\ud83d\udcc1 File Naming Convention","text":"<p>When creating custom hooks, it is a good practice to prefix the file name with <code>use</code>. For example, <code>useFetch.js</code>, <code>useLocalStorage.js</code>, etc.</p>"},{"location":"react/optimizing-our-app/#component-example-fetch-data-from-api-and-display-it","title":"\ud83d\udce6 Component Example: Fetch Data from API and Display It","text":"<pre><code>import React, { useState, useEffect } from 'react';\n\nconst Home = () =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetch('https://api.example.com/data')\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n      });\n  }, []);\n\n  if (data === null) {\n    return &lt;p&gt;Loading...&lt;/p&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{data.title}&lt;/h1&gt;\n      &lt;p&gt;{data.body}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\n</code></pre>"},{"location":"react/optimizing-our-app/#explanation","title":"Explanation","text":"<p>The above component performs two tasks: 1. Fetch data from the API 2. Display data on the webpage</p> <p>We can modify this component to focus solely on displaying the data and create a custom hook to handle data fetching.</p>"},{"location":"react/optimizing-our-app/#our-custom-hook","title":"\ud83d\udd27 Our Custom Hook","text":"<pre><code>import { useState, useEffect } from 'react';\n\nconst useFetch = () =&gt; {\n  const [data, setData] = useState(null);\n\n  useEffect(() =&gt; {\n    fetchData();\n  }, []);\n\n  const fetchData = async () =&gt; {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    setData(data);\n  };\n\n  return data;\n};\n\nexport default useFetch;\n</code></pre>"},{"location":"react/optimizing-our-app/#using-the-custom-hook-in-a-component","title":"\ud83d\udd04 Using the Custom Hook in a Component","text":"<pre><code>import React from 'react';\nimport useFetch from './useFetch';\n\nconst Home = () =&gt; {\n  const data = useFetch();\n\n  if (data === null) {\n    return &lt;p&gt;Loading...&lt;/p&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{data.title}&lt;/h1&gt;\n      &lt;p&gt;{data.body}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\n</code></pre>"},{"location":"react/optimizing-our-app/#benefits","title":"Benefits","text":"<ul> <li>Separation of Logic: The logic for fetching data is moved into the <code>useFetch</code> hook.</li> <li>Clean Component: The <code>Home</code> component is now solely responsible for displaying data.</li> <li>Reusability: The <code>useFetch</code> hook can be reused in other components as needed.</li> </ul>"},{"location":"react/optimizing-our-app/#create-a-custom-hook-to-check-online-status","title":"\ud83c\udf10 Create a Custom Hook to Check Online Status","text":"<pre><code>import { useEffect, useState } from \"react\";\n\nconst useOnlineStatus = () =&gt; {\n    const [isOnline, setIsOnline] = useState(true);\n\n    useEffect(() =&gt; {\n        const offline = () =&gt; setOnlineStatus(false);\n        const online = () =&gt; setOnlineStatus(true);\n\n        window.addEventListener('offline', offline);\n        window.addEventListener('online', online);\n\n        return () =&gt; {\n            window.removeEventListener('offline', offline);\n            window.removeEventListener('online', online);\n        }\n    }, [])\n    return isOnline;\n}\n\nexport default useOnlineStatus;\n</code></pre>"},{"location":"react/optimizing-our-app/#using-the-useonlinestatus-hook-in-a-component","title":"Using the <code>useOnlineStatus</code> Hook in a Component","text":"<pre><code>import React from 'react';\nimport useOnlineStatus from './useOnlineStatus';\n\nconst OnlineStatus = () =&gt; {\n  const isOnline = useOnlineStatus();\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;User is {isOnline ? 'Online' : 'Offline'}&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default OnlineStatus;\n</code></pre>"},{"location":"react/optimizing-our-app/#why-name-hooks-with-use-prefix","title":"Why Name Hooks with <code>use</code> Prefix?","text":"<ul> <li>Consistency: It is a naming convention for custom hooks followed by most companies.</li> <li>Linting Compatibility: Many linters throw an error if custom hooks are not prefixed with <code>use</code>.</li> <li>Clarity: Using the <code>use</code> prefix indicates that the function is a React hook, not a regular function.</li> <li>Readability: It helps other developers understand that the function follows the rules of React hooks.</li> </ul>"},{"location":"react/optimizing-our-app/#building-large-scale-applications","title":"\ud83c\udfd7\ufe0f Building Large-Scale Applications","text":"<p>When building a large-scale application, it's important to break it down into different components (bundles). Having a single bundle can slow down your app since it contains all the code, resulting in longer load times.</p> <p>Solution: Split your app into smaller chunks (bundles). This process is known as:</p> <ol> <li>Chunking</li> <li>Code Splitting</li> <li>Dynamic Bundling</li> <li>Lazy Loading</li> <li>On-Demand Loading</li> </ol> <p>Example: For an e-commerce application, you can create a separate bundle for the Cart component. This bundle will load only when the user visits the cart page. This approach results in two bundles: - Main Bundle: Contains all app code except the Cart component, loaded when the user visits the app. - Cart Bundle: Contains the Cart component code, loaded only when the user navigates to the shopping cart.</p> <p>This process is also known as on-demand loading.</p>"},{"location":"react/optimizing-our-app/#what-and-why-lazy-loading","title":"\ud83d\udca4 What and Why Lazy Loading?","text":"<p>Lazy Loading is a design pattern that allows you to load parts of your application on demand, reducing the initial load time.</p> <ul> <li> <p>How It Works:   Initially, load components related to essential features like user login and registration. Load other components based on user navigation.</p> </li> <li> <p>Impact:   While lazy loading may not show much difference in small applications, it significantly improves the performance of large-scale applications by reducing initial load time, enhancing user experience, and boosting application performance.</p> </li> </ul>"},{"location":"react/optimizing-our-app/#advantages-of-lazy-loading","title":"\u2705 Advantages of Lazy Loading","text":"<ol> <li>Reduces Initial Load Time: Smaller bundle sizes.</li> <li>Decreases Browser Workload.</li> <li>Enhances Performance in Low-Bandwidth Situations.</li> <li>Improves User Experience During Initial Loading.</li> <li>Optimizes Resource Usage.</li> </ol>"},{"location":"react/optimizing-our-app/#disadvantages-of-lazy-loading","title":"\u274c Disadvantages of Lazy Loading","text":"<ol> <li>Not Suitable for Small-Scale Applications.</li> <li>Placeholders Can Slow Down Quick Scrolling.</li> <li>Requires Additional Server Communication to Fetch Resources.</li> <li>Can Affect SEO and Ranking.</li> </ol>"},{"location":"react/optimizing-our-app/#example-of-lazy-loading-in-react","title":"\ud83d\udce6 Example of Lazy Loading in React","text":"<pre><code>import React, { lazy, Suspense } from 'react';\n\nconst Cart = lazy(() =&gt; import('./Cart'));\n</code></pre> <ul> <li>Lazy: Defers loading the component's code until it's rendered for the first time.</li> <li>Potential Issue: If a lazy-loaded component fetches API data, React might throw an error: \"A component suspended while responding to synchronous input.\"</li> </ul>"},{"location":"react/optimizing-our-app/#handling-errors-with-suspense","title":"\ud83d\uded1 Handling Errors with Suspense","text":"<p>Suspense is a built-in React component that allows you to display a fallback UI while the component is loading.</p> <ul> <li> <p>Usage:   Wrap the lazy-loaded component inside the <code>&lt;Suspense&gt;</code> component.</p> </li> <li> <p>Fallback UI:   Can be a simple loading indicator or a shimmer effect.</p> </li> </ul> <p>Example:</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nconst Cart = lazy(() =&gt; import('./Cart'));\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n        &lt;Cart /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/optimizing-our-app/#when-and-why-use-suspense","title":"\u2753 When and Why Use Suspense?","text":"<ul> <li>Best Use Cases:   Display a fallback while waiting for something to load, such as:</li> <li>Fetching data from an API after the initial page load.</li> <li>Lazy loading other React components.</li> </ul>"},{"location":"react/optimizing-our-app/#best-practices","title":"\u26a0\ufe0f Best Practices","text":"<p>Avoid: Declaring lazy components inside other components, as it can cause all state to reset on re-renders.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\nfunction App() {\n  // \ud83d\udd34 Bad: This will cause all state to be reset on re-renders\n  const Cart = lazy(() =&gt; import('./Cart'));\n  // ...\n}\n</code></pre> <p>Use Instead: Declare the lazy component at the module level to ensure it's loaded only once.</p> <pre><code>import React, { lazy, Suspense } from 'react';\n\n// \u2705 Good: Declare lazy components outside of your components\nconst Cart = lazy(() =&gt; import('./Cart'));\n\nfunction App() {\n  // ...\n}\n</code></pre> <p>Key Takeaways</p> <ul> <li>Single Responsibility Principle: Each component should have a single responsibility.</li> <li>Custom Hooks: Reusable functions that encapsulate logic.</li> <li>Lazy Loading: Loading parts of your application on demand.</li> <li>Suspense: Displaying a fallback UI while components are loading.</li> </ul>"},{"location":"react/show-it-to-the-world/","title":"10 - Jo Dikhta Hai, Vo Bikta Hai","text":""},{"location":"react/show-it-to-the-world/#exploring-ways-to-style-react-components-with-css","title":"Exploring Ways to Style React Components with CSS","text":""},{"location":"react/show-it-to-the-world/#1-inline-css","title":"1. Inline CSS","text":"<p>Apply styles directly to elements using the <code>style</code> attribute.</p> <pre><code>function Button() {\n  return (\n    &lt;button style={{ backgroundColor: 'blue', color: 'white' }}&gt;\n      Click Me\n    &lt;/button&gt;\n  );\n}\n</code></pre> <p>Pros</p> <ul> <li>Quick and easy for simple styles</li> <li>Scoped to the specific element</li> </ul> <p>Cons</p> <ul> <li>Limited CSS features</li> <li>Harder to maintain for larger projects</li> </ul>"},{"location":"react/show-it-to-the-world/#2-importing-external-stylesheet","title":"2. Importing External Stylesheet","text":"<p>Use separate <code>.css</code> files and import them into your React components.</p> <pre><code>/* styles.css */\n.button {\n  background-color: blue;\n  color: white;\n}\n</code></pre> <pre><code>import './styles.css';\n\nfunction Button() {\n  return &lt;button className=\"button\"&gt;Click Me&lt;/button&gt;;\n}\n</code></pre> <p>Pros</p> <ul> <li>Cleaner separation of concerns</li> <li>Full access to CSS features</li> </ul> <p>Cons</p> <ul> <li>Global scope can lead to naming conflicts</li> </ul>"},{"location":"react/show-it-to-the-world/#3-css-modules","title":"3. CSS Modules","text":"<p>Scope CSS to specific components by using modular CSS files.</p> <pre><code>/* Button.module.css */\n.button {\n  background-color: blue;\n  color: white;\n}\n</code></pre> <pre><code>import styles from './Button.module.css';\n\nfunction Button() {\n  return &lt;button className={styles.button}&gt;Click Me&lt;/button&gt;;\n}\n</code></pre> <p>Pros</p> <ul> <li>Avoids naming conflicts</li> <li>Maintains scope within components</li> </ul> <p>Cons</p> <ul> <li>Requires configuration in the build process</li> </ul>"},{"location":"react/show-it-to-the-world/#4-styled-components","title":"4. Styled Components","text":"<p>Use a CSS-in-JS library to style components with tagged template literals.</p> <pre><code>import styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: blue;\n  color: white;\n`;\n\nfunction App() {\n  return &lt;Button&gt;Click Me&lt;/Button&gt;;\n}\n</code></pre> <p>Pros</p> <ul> <li>Scoped styles with dynamic props</li> <li>Enhanced styling capabilities</li> </ul> <p>Cons</p> <ul> <li>Adds extra library dependency</li> <li>May increase bundle size</li> </ul>"},{"location":"react/show-it-to-the-world/#conditional-styling-in-react","title":"Conditional Styling in React","text":"<p>Apply styles based on component state or props.</p>"},{"location":"react/show-it-to-the-world/#using-inline-styles","title":"Using Inline Styles","text":"<pre><code>function Button({ primary }) {\n  const style = {\n    backgroundColor: primary ? 'blue' : 'gray',\n    color: 'white',\n  };\n\n  return &lt;button style={style}&gt;Click Me&lt;/button&gt;;\n}\n</code></pre>"},{"location":"react/show-it-to-the-world/#using-class-names","title":"Using Class Names","text":"<pre><code>import './Button.css';\n\nfunction Button({ primary }) {\n  return (\n    &lt;button className={primary ? 'button-primary' : 'button-secondary'}&gt;\n      Click Me\n    &lt;/button&gt;\n  );\n}\n</code></pre>"},{"location":"react/show-it-to-the-world/#using-styled-components","title":"Using Styled Components","text":"<pre><code>import styled from 'styled-components';\n\nconst Button = styled.button`\n  background-color: ${(props) =&gt; (props.primary ? 'blue' : 'gray')};\n  color: white;\n`;\n\nfunction App() {\n  return &lt;Button primary&gt;Click Me&lt;/Button&gt;;\n}\n</code></pre> <p>Tip</p> <ul> <li>Choose the method that best fits your project size and complexity.</li> <li>For larger projects, CSS Modules or Styled Components can help maintain organized and scalable styles.</li> <li>Conditional styling enhances interactivity and user experience by dynamically changing styles based on state or props.</li> </ul>"},{"location":"react/talk-is-cheap-show-me-the-code/","title":"04 - Talk is cheap, show me the code","text":""},{"location":"react/talk-is-cheap-show-me-the-code/#props-in-react","title":"Props in React","text":"<ul> <li>Props (short for Properties) are a way to pass data from parent to child components in React</li> <li>Props are read-only and cannot be modified by a child component</li> <li>They help make components reusable and dynamic</li> </ul> <p>Passing a prop to a function is like passing an argument to a function.</p>"},{"location":"react/talk-is-cheap-show-me-the-code/#key-features-of-props","title":"Key Features of Props","text":"<ul> <li>Props flow in one direction (parent to child)</li> <li>Props can carry any type of data:</li> <li>Strings</li> <li>Numbers</li> <li>Objects</li> <li>Arrays</li> <li>Functions</li> <li>JSX elements</li> </ul>"},{"location":"react/talk-is-cheap-show-me-the-code/#example-of-props-usage","title":"Example of Props Usage","text":"<pre><code>// Parent Component\nfunction ParentComponent() {\n  return (\n    &lt;ChildComponent\n      text=\"Hello World\"\n      number={42}\n      isActive={true}\n    /&gt;\n  );\n}\n\n// Child Component\nfunction ChildComponent(props) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{props.text}&lt;/p&gt;\n      &lt;p&gt;{props.number}&lt;/p&gt;\n      &lt;p&gt;{props.isActive ? 'Active' : 'Inactive'}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/talk-is-cheap-show-me-the-code/#props-destructuring","title":"Props Destructuring","text":"<pre><code>// Instead of using props.propertyName, you can destructure:\nfunction ChildComponent({ text, number, isActive }) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{text}&lt;/p&gt;\n      &lt;p&gt;{number}&lt;/p&gt;\n      &lt;p&gt;{isActive ? 'Active' : 'Inactive'}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"react/talk-is-cheap-show-me-the-code/#default-props","title":"Default Props","text":"<ul> <li>You can set default values for props in case they're not provided: <pre><code>function ChildComponent({ text = \"Default Text\" }) {\n  return &lt;p&gt;{text}&lt;/p&gt;;\n}\n</code></pre></li> </ul>"},{"location":"react/talk-is-cheap-show-me-the-code/#config-driven-ui","title":"Config Driven UI","text":"<ul> <li>Config driven UI is a technique that allows you to create user interfaces based on a configuration file (such as JSON or TypeScript) that defines the layout and content of UI components.</li> <li>This can be useful for creating dynamic and customizable UIs without hard coding them.</li> </ul>"},{"location":"react/talk-is-cheap-show-me-the-code/#keys-in-react","title":"Keys in React","text":""},{"location":"react/talk-is-cheap-show-me-the-code/#why-and-when-do-we-need-keys","title":"Why and When Do We Need Keys?","text":"<p>When we have components at same level and if a new component comes on the first without ID, DOM is going to re-render all the components again. As DOM can\u2019t identify where to place it.</p> <p>But if we give each of them a unique ID then react knows where to put that component according to the ID. It is a good optimization and performance thing.</p> <pre><code>const Body = () =&gt; (\n  &lt;div&gt;\n    {resList.map((restaurant) =&gt; (\n      &lt;RestaurantCard\n        key={restaurant.id}\n        resData={restaurant}\n      /&gt;\n    ))}\n  &lt;/div&gt;\n);\n</code></pre> <p>Using Indexes as Keys</p> <ul> <li>It is not recommended to use indexes as keys if the order of items may change.</li> <li>Using indexes as keys can negatively impact performance and cause issues with component state.</li> <li>If no explicit key is assigned to list items, React defaults to using indexes as keys.</li> <li>Index as a key is an anti-pattern. Avoid using indexes as keys for list items.</li> </ul>"},{"location":"react/time-for-test/","title":"13 - Time for Test","text":""},{"location":"react/time-for-test/#types-of-testing","title":"Types of Testing","text":"<ol> <li> Manual Testing Testing the functionality that has been developed. <ul> <li>Example: If we've developed a search bar, manual testing involves manually checking the search bar by entering queries.</li> <li>\u274c This method isn't very efficient for large applications because it's impractical to test every new feature manually. A single change can introduce bugs throughout the app since multiple components are interconnected.</li> </ul> </li> <li> Automated Testing Writing test cases to verify functionality automatically. It includes: <ol> <li> <p>Unit Testing     Writing test cases for specific parts or isolated components.</p> </li> <li> <p>Integration Testing     Writing test cases for connected components, such as the menu page and cart page.</p> </li> <li> <p>End-to-End Testing     Writing test cases that simulate user interactions from entering the website to leaving it.</p> </li> </ol> </li> </ol>"},{"location":"react/time-for-test/#install-libraries","title":"\ud83d\udce6 Install Libraries","text":"<p>Note</p> <p>If you are using Create React App or Vite, you can skip these installation steps as these packages are already included.</p>"},{"location":"react/time-for-test/#1-react-testing-library","title":"1. \ud83e\uddea React Testing Library","text":"<p>React Testing Library builds on top of DOM Testing Library by adding APIs for working with React components.</p> <ul> <li>Jest is used behind the scenes.</li> <li>Jest is a delightful JavaScript Testing Framework focused on simplicity.</li> <li>It works with projects using Babel, TypeScript, Node, React, Angular, Vue, and more.</li> <li>It allows you to test React components effectively.</li> </ul> <p>Info</p> <p>For more information, refer to the React Testing Library Documentation.</p> <p>Install React Testing Library and DOM Testing Library:</p> <pre><code>npm install --save-dev @testing-library/react @testing-library/dom\n</code></pre>"},{"location":"react/time-for-test/#2-jest","title":"2. \u2699\ufe0f Jest","text":"<p>Jest is required as React Testing Library relies on it.</p> <p>Info</p> <p>For more information, refer to the Jest Documentation.</p> <p>Install Jest:</p> <pre><code>npm install --save-dev jest\n</code></pre>"},{"location":"react/time-for-test/#3-extra-babel-libraries","title":"3. \ud83d\udee0\ufe0f Extra Babel Libraries","text":"<p>Since we are using Babel as a bundler, install the following additional libraries:</p> <p>Info</p> <p>For more information, refer to the Using Babel with Jest Documentation.</p> <p>Install Babel-related packages:</p> <pre><code>npm install --save-dev babel-jest @babel/core @babel/preset-env\n</code></pre> <p>Configure Babel:</p> <p>Create a <code>babel.config.js</code> file in the root of your project:</p> <pre><code>// babel.config.js\nconst presets = [\n  [\n    \"@babel/preset-env\",\n    {\n      targets: {\n        edge: \"17\",\n        firefox: \"60\",\n        chrome: \"67\",\n        safari: \"11.1\",\n      },\n      useBuiltIns: \"usage\",\n      corejs: \"3.6.4\",\n    },\n  ],\n];\nmodule.exports = { presets };\n</code></pre>"},{"location":"react/time-for-test/#4-configure-parcel","title":"4. \ud83d\udee1\ufe0f Configure Parcel","text":"<p>To avoid conflicts with Parcel's built-in Babel configuration, disable it by creating a <code>.parcelrc</code> file.</p> <p>Info</p> <p>For more information, refer to the Parcel Configuration Documentation.</p> <p>Create <code>.parcelrc</code>:</p> <pre><code>// .parcelrc\n{\n  \"extends\": \"@parcel/config-default\",\n  \"transformers\": {\n    \"*.{js,mjs,jsx,cjs,ts,tsx}\": [\n      \"@parcel/transformer-js\",\n      \"@parcel/transformer-react-refresh-wrap\"\n    ]\n  }\n}\n</code></pre>"},{"location":"react/time-for-test/#5-verify-installation","title":"5. \u2705 Verify Installation","text":"<p>Run the test command to ensure everything is installed correctly. Initially, there will be no test cases.</p> <pre><code>npm run test\n</code></pre> <p>Expected Output:</p> <pre><code>&gt; namaste-react@1.0.0 test\n&gt; jest\n\nNo tests found, exiting with code 1\n</code></pre>"},{"location":"react/time-for-test/#6-configure-jest","title":"6. \ud83d\udee0\ufe0f Configure Jest","text":"<p>Initialize Jest configuration by running:</p> <pre><code>npx jest --init\n</code></pre> <p>Follow the prompts:</p> <pre><code>Would you like to use Typescript for the configuration file? \u2026 no\nChoose the test environment that will be used for testing \u203a jsdom (browser-like)\nDo you want Jest to add coverage reports? \u2026 yes\nWhich provider should be used to instrument code for coverage? \u203a babel\nAutomatically clear mock calls, instances, contexts and results before every test? \u2026 yes\n</code></pre> <p>This creates a <code>jest.config.js</code> file in your project.</p> <p>Note</p> <p>We are using jsdom as the test environment to simulate a browser-like environment for running tests.</p>"},{"location":"react/time-for-test/#7-install-jsdom-environment","title":"7. \ud83c\udf10 Install jsdom Environment","text":"<p>Info</p> <p>For more information, refer to the Setup Testing Library with Jest Documentation.</p> <p>Install jsdom:</p> <pre><code>npm install --save-dev jest-environment-jsdom\n</code></pre>"},{"location":"react/time-for-test/#8-start-writing-test-cases","title":"8. \ud83d\udcdd Start Writing Test Cases","text":""},{"location":"react/time-for-test/#example-testing-a-sum-function","title":"Example: Testing a Sum Function","text":"<ol> <li>Create the function file:</li> </ol> <pre><code>// src/components/sum.js\nexport const sum = (a, b) =&gt; {\n  return a + b;\n};\n</code></pre> <ol> <li>Create the test file:</li> </ol> <pre><code>// src/__tests__/sum.test.js\nimport { sum } from \"../sum\";\n\ntest(\"Function should calculate the sum of two numbers\", () =&gt; {\n  const result = sum(3, 4);\n  expect(result).toBe(7);\n});\n</code></pre> <ol> <li>Run the test:</li> </ol> <pre><code>npm run test\n</code></pre> <p>Expected Output:</p> <pre><code>&gt; namaste-react@1.0.0 test\n&gt; jest\n\nPASS src/__tests__/sum.test.js\n  \u2713 Function should calculate the sum of two numbers\n\n----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |\n sum.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|-------------------\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.306 s\nRan all test suites.\n</code></pre>"},{"location":"react/time-for-test/#testing-react-components-made-easy","title":"\ud83e\uddea Testing React Components Made Easy","text":"<p>Testing ensures your React components work as expected. This guide covers Unit Testing and Integration Testing using Jest and React Testing Library. We'll use skeletal component structures for clarity and explain the reasoning behind each step, including important distinctions between various testing methods.</p>"},{"location":"react/time-for-test/#unit-testing","title":"\ud83e\udde9 Unit Testing","text":"<p>Unit Testing focuses on individual components to ensure they function correctly in isolation.</p>"},{"location":"react/time-for-test/#example-component-structure","title":"\ud83d\udcc4 Example Component Structure","text":"<p>Instead of a complete component, we'll use a skeleton to focus on testing logic.</p> <pre><code>// Contact.jsx\nconst Contact = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Contact&lt;/h1&gt;\n            &lt;form&gt;\n                &lt;input type=\"text\" placeholder=\"Your Name\" /&gt;\n                &lt;input type=\"email\" placeholder=\"Your Email\" /&gt;\n                &lt;textarea placeholder=\"Your Message\"&gt;&lt;/textarea&gt;\n                &lt;button&gt;Send&lt;/button&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Contact;\n</code></pre>"},{"location":"react/time-for-test/#writing-a-test-case","title":"\u2705 Writing a Test Case","text":"<p>Objective: Verify that the <code>Contact</code> component renders correctly.</p> <p>Why: Ensures that all essential elements are present, preventing rendering issues.</p> <pre><code>// Contact.test.jsx\nimport { render, screen } from '@testing-library/react';\nimport Contact from './Contact';\nimport '@testing-library/jest-dom'; // Extends Jest with custom matchers\n\ntest('renders Contact component', () =&gt; {\n    render(&lt;Contact /&gt;);\n    const heading = screen.getByRole('heading', { name: /contact/i });\n    expect(heading).toBeInTheDocument();\n});\n</code></pre>"},{"location":"react/time-for-test/#understanding-testing-libraryjest-dom","title":"\ud83d\udd0d Understanding <code>@testing-library/jest-dom</code>","text":"<ul> <li>Purpose: Extends Jest with custom matchers like <code>toBeInTheDocument()</code>, enhancing test readability and expressiveness.</li> <li>Usage: Import it once in your test files to use additional matchers.</li> </ul> <p>Issue: Missing <code>@testing-library/jest-dom</code> library can cause errors like <code>TypeError: expect(...).toBeInTheDocument is not a function</code>.</p> <p>Solution:</p> <ol> <li> <p>Install Jest DOM:</p> <pre><code>npm install --save-dev @testing-library/jest-dom\n</code></pre> </li> <li> <p>Import Jest DOM in Test File:</p> <pre><code>// Contact.test.jsx\nimport '@testing-library/jest-dom';\n</code></pre> </li> </ol>"},{"location":"react/time-for-test/#why-use-name-contacti","title":"\ud83d\udd0d Why Use <code>{ name: /contact/i }</code>?","text":"<ul> <li>Purpose: The <code>{ name: /contact/i }</code> option in <code>getByRole</code> searches for a heading with text matching the regular expression <code>/contact/i</code>.</li> <li>Reason:</li> <li><code>/contact/i</code>: The <code>/i</code> flag makes the search case-insensitive.</li> <li>Enhances Flexibility: Allows the test to pass regardless of the text case, ensuring robustness.</li> </ul>"},{"location":"react/time-for-test/#enabling-jsx-in-testing","title":"\ud83d\udd27 Enabling JSX in Testing","text":"<p>Issue: JSX may not be enabled, causing rendering errors.</p> <p>Solution: Configure Babel to support JSX during tests.</p> <ol> <li> <p>Install Babel Preset for React:</p> <pre><code>npm install --save-dev @babel/preset-react\n</code></pre> </li> <li> <p>Configure Babel (<code>babel.config.json</code>):</p> <pre><code>{\n    \"env\": {\n        \"test\": {\n            \"presets\": [\n                [\"@babel/preset-env\", { \"targets\": { \"node\": \"current\" } }],\n                [\"@babel/preset-react\", { \"runtime\": \"automatic\" }]\n            ]\n        }\n    }\n}\n</code></pre> </li> </ol>"},{"location":"react/time-for-test/#grouping-multiple-test-cases","title":"\ud83d\udcda Grouping Multiple Test Cases","text":"<p>Why: Organizes related tests, making the test suite more readable and maintainable.</p> <pre><code>// Contact.test.jsx\nimport { render, screen } from '@testing-library/react';\nimport Contact from './Contact';\nimport '@testing-library/jest-dom';\n\ndescribe('Contact Component', () =&gt; {\n    test('renders Contact heading', () =&gt; {\n        render(&lt;Contact /&gt;);\n        const heading = screen.getByRole('heading', { name: /contact/i });\n        expect(heading).toBeInTheDocument();\n    });\n\n    test('renders Send button', () =&gt; {\n        render(&lt;Contact /&gt;);\n        const button = screen.getByText(/send/i);\n        expect(button).toBeInTheDocument();\n    });\n});\n</code></pre>"},{"location":"react/time-for-test/#integration-testing","title":"\ud83d\udd17 Integration Testing","text":"<p>Integration Testing evaluates how different parts of your application work together.</p>"},{"location":"react/time-for-test/#automating-tests-with-a-watch-script","title":"\ud83d\udee0 Automating Tests with a Watch Script","text":"<p>Why: Automatically run tests on file changes, improving development efficiency.</p> <ol> <li> <p>Add <code>watch-test</code> Script (<code>package.json</code>):</p> <pre><code>\"scripts\": {\n    \"watch-test\": \"jest --watch\"\n}\n</code></pre> </li> <li> <p>Run Watch Script:</p> <pre><code>npm run watch-test\n</code></pre> </li> </ol>"},{"location":"react/time-for-test/#example-component-structures","title":"\ud83d\udcc4 Example Component Structures","text":"<p>Header Component Skeleton:</p> <pre><code>// Header.jsx\nimport { Link } from 'react-router-dom';\nimport { useSelector } from 'react-redux';\n\nconst Header = () =&gt; {\n    const cartItems = useSelector((store) =&gt; store.cart.items);\n\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Site Name&lt;/h1&gt;\n            &lt;nav&gt;\n                &lt;Link to=\"/\"&gt;Home&lt;/Link&gt;\n                &lt;Link to=\"/cart\"&gt;Cart ({cartItems.length})&lt;/Link&gt;\n                &lt;button&gt;Login&lt;/button&gt;\n            &lt;/nav&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default Header;\n</code></pre> <p>Body Component Skeleton:</p> <pre><code>// Body.jsx\nimport { useState, useEffect } from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Body = () =&gt; {\n    const [restaurants, setRestaurants] = useState([]);\n    const [filteredRestaurants, setFilteredRestaurants] = useState([]);\n    const [searchTerm, setSearchTerm] = useState('');\n\n    useEffect(() =&gt; {\n        // Fetch restaurants from API\n    }, []);\n\n    return (\n        &lt;div&gt;\n            &lt;input placeholder=\"Search Restaurants\" /&gt;\n            &lt;button&gt;Search&lt;/button&gt;\n            &lt;button&gt;Top Rated Restaurants&lt;/button&gt;\n            {/* Restaurant cards will be rendered here */}\n        &lt;/div&gt;\n    );\n};\n\nexport default Body;\n</code></pre>"},{"location":"react/time-for-test/#writing-test-cases-for-header-component","title":"\u2705 Writing Test Cases for Header Component","text":""},{"location":"react/time-for-test/#understanding-provider-and-browserrouter","title":"\ud83d\udd27 Understanding <code>Provider</code> and <code>BrowserRouter</code>","text":"<ul> <li><code>Provider</code>:</li> <li>Purpose: Makes the Redux store available to any nested components that need to access the Redux store.</li> <li> <p>Usage: Wrap your component with <code>Provider</code> and pass the store as a prop.</p> </li> <li> <p><code>BrowserRouter</code>:</p> </li> <li>Purpose: Provides routing context to the components, enabling navigation functionalities.</li> <li>Usage: Wrap your component with <code>BrowserRouter</code> to enable routing features like <code>Link</code> and <code>Route</code>.</li> </ul> <pre><code>// Header.test.jsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport Header from './Header';\nimport { Provider } from 'react-redux';\nimport store from '../../store';\nimport { BrowserRouter } from 'react-router-dom';\nimport '@testing-library/jest-dom'; // Extends Jest with custom matchers\n\ntest('renders Header with Login button', () =&gt; {\n    render(\n        &lt;BrowserRouter&gt;\n            &lt;Provider store={store}&gt;\n                &lt;Header /&gt;\n            &lt;/Provider&gt;\n        &lt;/BrowserRouter&gt;\n    );\n    const loginButton = screen.getByText(/login/i);\n    expect(loginButton).toBeInTheDocument();\n});\n\ntest('changes Login to Logout on button click', () =&gt; {\n    render(\n        &lt;BrowserRouter&gt;\n            &lt;Provider store={store}&gt;\n                &lt;Header /&gt;\n            &lt;/Provider&gt;\n        &lt;/BrowserRouter&gt;\n    );\n    const loginButton = screen.getByRole('button', { name: /login/i });\n    fireEvent.click(loginButton);\n    const logoutButton = screen.getByRole('button', { name: /logout/i });\n    expect(logoutButton).toBeInTheDocument();\n});\n</code></pre>"},{"location":"react/time-for-test/#what-is-fireevent","title":"\ud83d\udd25 What is <code>fireEvent</code>?","text":"<ul> <li>Purpose: Simulates user interactions (e.g., clicks, typing) within tests.</li> <li>Usage:</li> <li>Syntax: <code>fireEvent.eventName(element, eventData)</code></li> <li>Example: <pre><code>fireEvent.click(button);\nfireEvent.change(input, { target: { value: 'new value' } });\n</code></pre></li> </ul>"},{"location":"react/time-for-test/#what-is-getbyplaceholdertext","title":"\ud83d\udd0d What is <code>getByPlaceholderText</code>?","text":"<p>Purpose: Selects input elements based on their placeholder text.</p> <p>Syntax:</p> <pre><code>screen.getByPlaceholderText(/placeholder text/i);\n</code></pre> <p>Usage Example:</p> <pre><code>const searchInput = screen.getByPlaceholderText(/search restaurants/i);\nfireEvent.change(searchInput, { target: { value: 'Pizza' } });\n</code></pre> <p>Why Use It:</p> <ul> <li>Clarity: Targets inputs by their descriptive placeholder.</li> <li>Accessibility: Reflects how users identify input fields through hints.</li> </ul>"},{"location":"react/time-for-test/#writing-test-cases-for-body-component","title":"\u2705 Writing Test Cases for Body Component","text":"<p>Objective: Test search functionality and API integration in <code>Body</code> component.</p> <p>Why: Ensures that user interactions trigger the correct filtering and that API data is handled properly.</p>"},{"location":"react/time-for-test/#mocking-fetch-api","title":"\ud83d\udcc1 Mocking Fetch API","text":"<p>Why: Prevents actual API calls during tests, ensuring consistency and speed.</p> <ol> <li> <p>Create Mock Data:</p> <pre><code>// __mocks__/resListData.json\n[\n    {\n        \"id\": \"1\",\n        \"data\": {\n            \"name\": \"Burger King\",\n            \"rating\": 4.5,\n            \"cuisins\": [\"American\"],\n            \"time\": \"30\",\n            \"promoted\": true,\n            \"logo\": \"https://example.com/logo1.png\"\n        }\n    },\n    {\n        \"id\": \"2\",\n        \"data\": {\n            \"name\": \"McDonald's\",\n            \"rating\": 4.2,\n            \"cuisins\": [\"Fast Food\"],\n            \"time\": \"25\",\n            \"promoted\": false,\n            \"logo\": \"https://example.com/logo2.png\"\n        }\n    }\n    // Add more mock restaurant data as needed\n]\n</code></pre> </li> <li> <p>Mock <code>fetch</code> Globally:</p> <pre><code>// Body.test.jsx\nimport { fireEvent, render, screen } from \"@testing-library/react\";\nimport Body from \"../Body\";\nimport REST_LIST_DATA from \"../__mocks__/resListData.json\";\nimport { act } from \"react-dom/test-utils\";\nimport '@testing-library/jest-dom';\nimport { Provider } from \"react-redux\";\nimport store from \"../../store\";\nimport { BrowserRouter } from \"react-router-dom\";\n\n// Mock Fetch API globally\nglobal.fetch = jest.fn(() =&gt;\n    Promise.resolve({\n        json: () =&gt; Promise.resolve(REST_LIST_DATA),\n    })\n);\n</code></pre> <p>Why Define <code>global.fetch</code>:</p> <ul> <li>Isolation: Ensures tests do not make real API calls, which can be slow and flaky.</li> <li>Control: Allows you to define exact responses, making tests predictable and repeatable.</li> <li>Performance: Speeds up tests by avoiding network latency.</li> </ul> </li> </ol>"},{"location":"react/time-for-test/#creating-a-wrapper-for-rendering","title":"\u2699\ufe0f Creating a Wrapper for Rendering","text":"<p>Why: Provides necessary context (Redux store and Router) to the component being tested.</p> <pre><code>const BodyWrapper = () =&gt; (\n    &lt;BrowserRouter&gt;\n        &lt;Provider store={store}&gt;\n            &lt;Body /&gt;\n        &lt;/Provider&gt;\n    &lt;/BrowserRouter&gt;\n);\n</code></pre>"},{"location":"react/time-for-test/#writing-test-cases","title":"\ud83d\udd04 Writing Test Cases","text":"<pre><code>describe(\"Body Component\", () =&gt; {\n    beforeEach(() =&gt; {\n        fetch.mockClear(); // Clears previous mock calls\n    });\n\n    test(\"loads restaurant list after API call\", async () =&gt; {\n        await act(async () =&gt; {\n            render(&lt;BodyWrapper /&gt;);\n        });\n        const restaurantCards = await screen.findAllByTestId(\"resCard\");\n        expect(restaurantCards.length).toBe(REST_LIST_DATA.length);\n    });\n\n    test(\"searches for a specific restaurant\", async () =&gt; {\n        await act(async () =&gt; {\n            render(&lt;BodyWrapper /&gt;);\n        });\n\n        const searchInput = screen.getByPlaceholderText(/search restaurants/i);\n        fireEvent.change(searchInput, { target: { value: \"Burger\" } });\n        const searchButton = screen.getByRole(\"button\", { name: /search/i });\n        fireEvent.click(searchButton);\n\n        const searchResults = await screen.findAllByTestId(\"resCard\");\n        const filtered = REST_LIST_DATA.filter(restaurant =&gt;\n            restaurant.data.name.toLowerCase().includes(\"burger\".toLowerCase())\n        );\n        expect(searchResults.length).toBe(filtered.length);\n    });\n\n    test(\"filters top-rated restaurants\", async () =&gt; {\n        await act(async () =&gt; {\n            render(&lt;BodyWrapper /&gt;);\n        });\n\n        const topRatedButton = screen.getByRole(\"button\", { name: /top rated restaurants/i });\n        fireEvent.click(topRatedButton);\n\n        const filteredResults = await screen.findAllByTestId(\"resCard\");\n        const expected = REST_LIST_DATA.filter(restaurant =&gt; restaurant.data.rating &gt; 4);\n        expect(filteredResults.length).toBe(expected.length);\n    });\n});\n</code></pre>"},{"location":"react/time-for-test/#why-use-async-and-await-with-act","title":"\ud83d\udd04 Why Use <code>async</code> and <code>await</code> with <code>act</code>?","text":"<ul> <li>Purpose of <code>act</code>: Ensures that all updates related to component rendering and state changes are processed before making assertions.</li> <li>Why <code>async/await</code>:</li> <li>Asynchronous Operations: Components often perform async tasks (e.g., API calls) that need to complete before tests proceed.</li> <li>Prevent Race Conditions: Using <code>async/await</code> with <code>act</code> ensures that the component has fully rendered before assertions run.</li> </ul>"},{"location":"react/time-for-test/#what-is-import-act-from-react-domtest-utils","title":"\ud83d\udcdc What is <code>import { act } from \"react-dom/test-utils\"</code>?","text":"<ul> <li>Purpose: Batches state updates and effects, ensuring that component rendering is completed before assertions.</li> <li>Usage: Wrap asynchronous operations that trigger state updates within <code>act</code> to simulate real user interactions accurately.</li> </ul> <pre><code>import { act } from \"react-dom/test-utils\";\n\nawait act(async () =&gt; {\n    render(&lt;Component /&gt;);\n});\n</code></pre>"},{"location":"react/time-for-test/#using-getbyplaceholdertext-vs-getallbyplaceholdertext","title":"\ud83d\udfe2 Using <code>getByPlaceholderText</code> vs <code>getAllByPlaceholderText</code>","text":"<ul> <li><code>getByPlaceholderText</code>:</li> <li>Use When: You need to select a single input element by its placeholder text.</li> <li> <p>Example: <pre><code>const searchInput = screen.getByPlaceholderText(/search restaurants/i);\n</code></pre></p> </li> <li> <p><code>getAllByPlaceholderText</code>:</p> </li> <li>Use When: You expect multiple input elements sharing the same placeholder text and want to select all of them.</li> <li> <p>Example: <pre><code>const inputs = screen.getAllByPlaceholderText(/enter your name/i);\nexpect(inputs.length).toBe(2);\n</code></pre></p> </li> <li> <p>Difference:</p> </li> <li><code>getByPlaceholderText</code> throws an error if no element or multiple elements match.</li> <li><code>getAllByPlaceholderText</code> returns an array of all matching elements and throws an error if none are found.</li> </ul>"},{"location":"react/time-for-test/#using-findbytestid-vs-findallbytestid","title":"\ud83d\udfe2 Using <code>findByTestId</code> vs <code>findAllByTestId</code>","text":"<ul> <li><code>findByTestId</code>:</li> <li>Use When: You need to asynchronously find a single element by its <code>data-testid</code>.</li> <li>Returns: A Promise that resolves to the found element.</li> <li> <p>Example: <pre><code>const element = await screen.findByTestId('submit-button');\nexpect(element).toBeInTheDocument();\n</code></pre></p> </li> <li> <p><code>findAllByTestId</code>:</p> </li> <li>Use When: You need to asynchronously find all elements matching a <code>data-testid</code>.</li> <li>Returns: A Promise that resolves to an array of found elements.</li> <li> <p>Example: <pre><code>const elements = await screen.findAllByTestId('item');\nexpect(elements.length).toBe(3);\n</code></pre></p> </li> <li> <p>Difference:</p> </li> <li><code>findByTestId</code> is for a single element, while <code>findAllByTestId</code> is for multiple elements.</li> <li>Both are asynchronous and useful for elements that appear after certain actions or delays.</li> </ul>"},{"location":"react/time-for-test/#helper-functions-in-jest","title":"\ud83d\udee0 Helper Functions in Jest","text":"<p>Jest provides functions to run code at specific stages of the testing lifecycle:</p> <ul> <li><code>beforeAll()</code>: Runs once before all tests in a suite.</li> <li><code>afterAll()</code>: Runs once after all tests in a suite.</li> <li><code>beforeEach()</code>: Runs before each test.</li> <li><code>afterEach()</code>: Runs after each test.</li> </ul> <p>Example:</p> <pre><code>describe(\"Test Suite\", () =&gt; {\n    beforeAll(() =&gt; {\n        // Setup before all tests\n    });\n\n    afterAll(() =&gt; {\n        // Cleanup after all tests\n    });\n\n    beforeEach(() =&gt; {\n        // Setup before each test\n    });\n\n    afterEach(() =&gt; {\n        // Cleanup after each test\n    });\n\n    test(\"test case 1\", () =&gt; {\n        // Test implementation\n    });\n\n    test(\"test case 2\", () =&gt; {\n        // Test implementation\n    });\n});\n</code></pre> <p>Why Use Helper Functions:</p> <ul> <li>Code Reusability: Avoids repetition by setting up common prerequisites.</li> <li>Maintainability: Centralizes setup and teardown logic, making tests cleaner.</li> </ul>"},{"location":"react/time-for-test/#additional-testing-tips","title":"\ud83d\udca1 Additional Testing Tips","text":""},{"location":"react/time-for-test/#using-getbyrole-vs-getallbyrole","title":"\ud83c\udfaf Using <code>getByRole</code> vs <code>getAllByRole</code>","text":"<ul> <li><code>getByRole</code>:</li> <li>Use When: Selecting a single element by its ARIA role.</li> <li> <p>Example: <pre><code>const submitButton = screen.getByRole('button', { name: /submit/i });\n</code></pre></p> </li> <li> <p><code>getAllByRole</code>:</p> </li> <li>Use When: Selecting multiple elements sharing the same ARIA role.</li> <li>Example: <pre><code>const buttons = screen.getAllByRole('button');\nexpect(buttons.length).toBeGreaterThan(1);\n</code></pre></li> </ul> <p>Recommendation: Prefer <code>getByRole</code> for better accessibility and specificity. Use <code>getAllByRole</code> when multiple elements match the role.</p>"},{"location":"react/time-for-test/#firing-events","title":"\ud83d\udd04 Firing Events","text":"<p>Why: Simulates user interactions to test component responses.</p> <p>Example:</p> <pre><code>const button = screen.getByRole('button', { name: /login/i });\nfireEvent.click(button);\n</code></pre> <p>Common Events: - <code>click</code>: Simulates a mouse click. - <code>change</code>: Simulates a value change in input elements. - <code>submit</code>: Simulates form submission.</p>"},{"location":"react/time-for-test/#testing-components-with-redux","title":"\ud83d\udd01 Testing Components with Redux","text":"<p>Why: Ensures components interacting with the global state behave correctly.</p> <p>How:</p> <ol> <li> <p>Wrap Component with <code>Provider</code>:</p> <pre><code>import { Provider } from 'react-redux';\nimport store from '../../store';\n\nrender(\n    &lt;Provider store={store}&gt;\n        &lt;Header /&gt;\n    &lt;/Provider&gt;\n);\n</code></pre> </li> <li> <p>Why:</p> <ul> <li>State Access: Components using Redux hooks (<code>useSelector</code>, <code>useDispatch</code>) require access to the Redux store.</li> <li>Consistency: Mimics the actual app environment where the store is provided.</li> </ul> </li> </ol> <p>Example Test:</p> <pre><code>test('renders Header with Cart count from Redux store', () =&gt; {\n    render(\n        &lt;Provider store={store}&gt;\n            &lt;Header /&gt;\n        &lt;/Provider&gt;\n    );\n    const cartLink = screen.getByText(/cart/i);\n    expect(cartLink).toHaveTextContent(`Cart (${store.getState().cart.items.length})`);\n});\n</code></pre>"},{"location":"react/time-for-test/#testing-components-with-react-router","title":"\ud83d\udd00 Testing Components with React Router","text":"<p>Why: Verifies navigation-related functionalities work as intended.</p> <p>How:</p> <ol> <li> <p>Wrap Component with <code>BrowserRouter</code>:</p> <pre><code>import { BrowserRouter } from 'react-router-dom';\n\nrender(\n    &lt;BrowserRouter&gt;\n        &lt;Header /&gt;\n    &lt;/BrowserRouter&gt;\n);\n</code></pre> </li> <li> <p>Why:</p> <ul> <li>Routing Context: Components using <code>Link</code>, <code>Route</code>, or other router features need routing context to function.</li> <li>Prevent Errors: Avoids errors related to missing router context during tests.</li> </ul> </li> </ol> <p>Example Test:</p> <pre><code>test('navigates to home page on Home link click', () =&gt; {\n    render(\n        &lt;BrowserRouter&gt;\n            &lt;Header /&gt;\n        &lt;/BrowserRouter&gt;\n    );\n    const homeLink = screen.getByText(/home/i);\n    expect(homeLink).toHaveAttribute('href', '/');\n});\n</code></pre>"},{"location":"react/time-for-test/#testing-components-with-props","title":"\ud83e\udde9 Testing Components with Props","text":"<p>Why: Ensures components correctly handle and display received data.</p> <p>Example:</p> <pre><code>// ItemCard.jsx\nconst ItemCard = ({ name, price }) =&gt; (\n    &lt;div&gt;\n        &lt;h2&gt;{name}&lt;/h2&gt;\n        &lt;p&gt;{price}&lt;/p&gt;\n    &lt;/div&gt;\n);\n\nexport default ItemCard;\n</code></pre> <p>Test Case:</p> <pre><code>// ItemCard.test.jsx\nimport { render, screen } from '@testing-library/react';\nimport ItemCard from './ItemCard';\n\ntest('renders ItemCard with props', () =&gt; {\n    const mockProps = { name: 'Sample Item', price: '$10' };\n    render(&lt;ItemCard {...mockProps} /&gt;);\n    expect(screen.getByText('Sample Item')).toBeInTheDocument();\n    expect(screen.getByText('$10')).toBeInTheDocument();\n});\n</code></pre>"},{"location":"react/time-for-test/#understanding-findby-and-findallby","title":"\ud83d\udd0d Understanding <code>findBy</code> and <code>findAllBy</code>","text":"<ul> <li><code>findBy</code>:</li> <li>Use When: You need to asynchronously find a single element.</li> <li>Returns: A Promise that resolves to the found element.</li> <li> <p>Example: <pre><code>const element = await screen.findByText(/loading/i);\nexpect(element).toBeInTheDocument();\n</code></pre></p> </li> <li> <p><code>findAllBy</code>:</p> </li> <li>Use When: You need to asynchronously find multiple elements.</li> <li>Returns: A Promise that resolves to an array of found elements.</li> <li>Example: <pre><code>const items = await screen.findAllByTestId('item');\nexpect(items.length).toBeGreaterThan(0);\n</code></pre></li> </ul> <p>Key Points:</p> <ul> <li>Both are asynchronous and return Promises.</li> <li>Use them for elements that appear after asynchronous actions (e.g., API calls).</li> <li>Handle them with <code>async/await</code> in your tests.</li> </ul>"},{"location":"react/time-for-test/#git-configuration","title":"\ud83d\udcc1 Git Configuration","text":""},{"location":"react/time-for-test/#ignoring-the-coverage-folder","title":"\ud83d\udeab Ignoring the Coverage Folder","text":"<p>After running tests, a <code>coverage</code> folder is generated. To prevent cluttering your Git repository:</p> <ol> <li> <p>Add to <code>.gitignore</code>:</p> <pre><code>echo \"coverage/\" &gt;&gt; .gitignore\n</code></pre> </li> </ol>"},{"location":"react/time-for-test/#summary","title":"\ud83d\udcdc Summary","text":"<ul> <li> <p>Unit Testing:</p> <ul> <li>Focus: Individual components.</li> <li>Tools: Jest, React Testing Library.</li> <li>Practices: Use semantic selectors (<code>getByRole</code>), mock dependencies, group tests with <code>describe</code>.</li> </ul> </li> <li> <p>Integration Testing:</p> <ul> <li>Focus: How components work together.</li> <li>Tools: Jest, React Testing Library.</li> <li>Practices: Mock API calls, provide necessary context (Redux, Router), test user interactions.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Use Semantic Selectors: Enhances accessibility and test reliability (<code>getByRole</code> over <code>getByTestId</code> when possible).</li> <li>Mock External Services: Isolate tests and ensure consistency (<code>global.fetch</code> mocking).</li> <li>Organize Tests: Group related tests using <code>describe</code> for clarity.</li> <li>Utilize Helper Functions: Streamline setup and teardown processes (<code>beforeEach</code>, <code>afterEach</code>).</li> <li>Handle Asynchronous Code Properly: Use <code>act</code>, <code>async/await</code> to manage state updates and async operations.</li> <li>Keep Tests Focused: Ensure each test checks a specific functionality for better maintainability.</li> </ul> </li> </ul>"},{"location":"react/useMemo/","title":"useMemo","text":""},{"location":"react/useMemo/#the-problem-expensive-calculations","title":"The Problem: Expensive Calculations","text":"<p>Have you ever noticed your React app becoming sluggish when performing complex calculations? This happens because React re-executes all code in your component body during every re-render.</p> <p>Consider this example where we calculate the nth prime number:</p> MemoExample.js<pre><code>import { useState } from \"react\";\nimport { findNthPrime } from \"../utils/helper\";\n\nconst MemoExample = () =&gt; {\n    const [memoInput, setMemoInput] = useState(0);\n    const [theme, setTheme] = useState(\"light\");\n\n    console.log(\"MemoExample Rendered\");\n\n    // This expensive calculation runs on EVERY render!\n    console.log(\"Calculating prime number for:\", memoInput);\n    const prime = findNthPrime(memoInput);\n\n    return (\n        &lt;div className={theme === \"dark\" ? \"bg-gray-800 text-white\" : \"bg-white text-black\"}&gt;\n            &lt;h1&gt;Use Memo Example Box&lt;/h1&gt;\n            &lt;button onClick={() =&gt; setTheme(theme === \"dark\" ? \"light\" : \"dark\")}&gt;\n                Toggle Theme\n            &lt;/button&gt;\n            &lt;input\n                type=\"number\"\n                value={memoInput}\n                onChange={(e) =&gt; setMemoInput(e.target.value)}\n            /&gt;\n            &lt;p&gt;\n                The {memoInput}th prime number is {memoInput ? prime : \"?\"}\n            &lt;/p&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre> <p>In this code, the findNthPrime function is computationally expensive, especially for values greater than or equal to 6. The critical issue is that this calculation runs every time the component re-renders - even when toggling the theme, which has nothing to do with our prime number!</p> <p></p>"},{"location":"react/useMemo/#the-solution-usememo","title":"The Solution: useMemo","text":"<p>React's <code>useMemo</code> hook lets you cache expensive calculations between renders:</p> <pre><code>const cachedValue = useMemo(calculateValue, dependencies)\n</code></pre>"},{"location":"react/useMemo/#parameters","title":"Parameters:","text":"<ul> <li><code>calculateValue</code>: A function that returns the value you want to cache</li> <li><code>dependencies</code>: An array of values that, when changed, will trigger recalculation</li> </ul>"},{"location":"react/useMemo/#fixing-our-example","title":"Fixing Our Example:","text":"MemoExample.js<pre><code>import { useMemo, useState } from \"react\";\nimport { findNthPrime } from \"../utils/helper\";\n\nconst MemoExample = () =&gt; {\n    const [memoInput, setMemoInput] = useState(0);\n    const [theme, setTheme] = useState(\"light\");\n\n    console.log(\"MemoExample Rendered\");\n\n    // Now the calculation only runs when memoInput changes!\n    const prime = useMemo(() =&gt; {\n        console.log(\"Calculating prime number for:\", memoInput);\n        return findNthPrime(memoInput);\n    }, [memoInput]);\n\n    return (\n        &lt;div className={theme === \"dark\" ? \"bg-gray-800 text-white\" : \"bg-white text-black\"}&gt;\n            &lt;h1&gt;Use Memo Example Box&lt;/h1&gt;\n            &lt;button onClick={() =&gt; setTheme(theme === \"dark\" ? \"light\" : \"dark\")}&gt;\n                Toggle Theme\n            &lt;/button&gt;\n            &lt;input\n                type=\"number\"\n                value={memoInput}\n                onChange={(e) =&gt; setMemoInput(e.target.value)}\n            /&gt;\n            &lt;p&gt;\n                The {memoInput}th prime number is {memoInput ? prime : \"?\"}\n            &lt;/p&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre> <p>With this change, the expensive calculation now only runs when the <code>memoInput</code> changes. When you toggle the theme, React reuses the previously calculated value, keeping your UI responsive.</p> <p>Important Notes</p> <ul> <li><code>useMemo</code> is a Hook, so you can only call it at the top level of components or custom hooks</li> <li>In development mode (Strict Mode), React calls your calculation function twice to help detect impurities</li> <li>Only use <code>useMemo</code> for computationally expensive operations - it has its own overhead</li> <li>React may occasionally discard cached values for internal optimization reasons</li> </ul>"},{"location":"react/useMemo/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Skipping expensive calculations</li> <li>Preventing unnecessary re-renders of child components</li> <li>Stabilizing dependencies for useEffect</li> <li>Memoizing callback functions (though useCallback is often better for this)</li> </ul> <p>Try entering a large number (like 100000) in the example app and toggle the theme. With <code>useMemo</code>, the UI remains responsive during theme changes because the prime calculation doesn't need to run again.</p>"},{"location":"react/useMemo/#further-reading","title":"Further Reading","text":"<ul> <li> React Docs: useMemo</li> <li> React Docs: useCallback</li> </ul>"},{"location":"react/useRef-hook/","title":"14 - useRef hook","text":""},{"location":"react/useRef-hook/#understanding-useref-in-react","title":"\ud83d\udd17 Understanding <code>useRef</code> in React","text":"<p>The <code>useRef</code> hook in React is a versatile tool that allows you to persist values between renders without triggering re-renders when those values change. It's commonly used for accessing and manipulating DOM elements directly, storing mutable values, and integrating with third-party libraries.</p>"},{"location":"react/useRef-hook/#what-is-useref","title":"\ud83d\udccc What is <code>useRef</code>?","text":"<p><code>useRef</code> is a React hook that returns a mutable ref object. This object has a <code>.current</code> property that you can use to store any value, similar to how you might use instance fields in classes. Unlike state variables returned by <code>useState</code>, updating a ref does not cause a component to re-render.</p> <pre><code>import { useRef } from 'react';\n\nconst Example = () =&gt; {\n  const myRef = useRef(initialValue);\n\n  // You can access or modify the value using myRef.current\n};\n</code></pre>"},{"location":"react/useRef-hook/#common-use-cases","title":"\ud83d\udee0\ufe0f Common Use Cases","text":""},{"location":"react/useRef-hook/#1-accessing-dom-elements","title":"1. Accessing DOM Elements","text":"<p><code>useRef</code> is often used to access DOM elements directly. This is useful for tasks like focusing an input field, selecting text, or measuring the size of an element.</p> <pre><code>import React, { useRef } from 'react';\n\nconst FocusInput = () =&gt; {\n  const inputRef = useRef(null);\n\n  const focusInputField = () =&gt; {\n    inputRef.current.focus();\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} type=\"text\" placeholder=\"Focus me with the button\" /&gt;\n      &lt;button onClick={focusInputField}&gt;Focus Input&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FocusInput;\n</code></pre>"},{"location":"react/useRef-hook/#2-storing-mutable-values","title":"2. Storing Mutable Values","text":"<p><code>useRef</code> can store values that persist across renders without triggering re-renders when updated. This is useful for keeping track of previous values, timers, or any mutable data.</p> <pre><code>import React, { useRef, useState, useEffect } from 'react';\n\nconst Timer = () =&gt; {\n  const [seconds, setSeconds] = useState(0);\n  const intervalRef = useRef(null);\n\n  useEffect(() =&gt; {\n    intervalRef.current = setInterval(() =&gt; {\n      setSeconds(prev =&gt; prev + 1);\n    }, 1000);\n\n    return () =&gt; clearInterval(intervalRef.current);\n  }, []);\n\n  return &lt;div&gt;Seconds Elapsed: {seconds}&lt;/div&gt;;\n};\n\nexport default Timer;\n</code></pre>"},{"location":"react/useRef-hook/#3-integrating-with-third-party-libraries","title":"3. Integrating with Third-Party Libraries","text":"<p>When working with libraries that require direct DOM manipulation or need to access DOM nodes, <code>useRef</code> provides a way to reference those nodes.</p> <pre><code>import React, { useRef, useEffect } from 'react';\nimport SomeThirdPartyLibrary from 'third-party-library';\n\nconst ThirdPartyComponent = () =&gt; {\n  const containerRef = useRef(null);\n\n  useEffect(() =&gt; {\n    const instance = new SomeThirdPartyLibrary(containerRef.current);\n    instance.initialize();\n\n    return () =&gt; {\n      instance.destroy();\n    };\n  }, []);\n\n  return &lt;div ref={containerRef}&gt;&lt;/div&gt;;\n};\n\nexport default ThirdPartyComponent;\n</code></pre>"},{"location":"react/useRef-hook/#example-login-component-using-useref","title":"\ud83d\udcdd Example: Login Component Using <code>useRef</code>","text":"<p>Let's explore a practical example of how <code>useRef</code> can be utilized within a React component, specifically a simplified Login component.</p>"},{"location":"react/useRef-hook/#login-component-code","title":"\ud83d\udcc4 Login Component Code","text":"<pre><code>import Header from \"./Header\";\nimport bgImage from \"../assets/large-bg-image.jpg\";\nimport { useRef, useState } from \"react\";\nimport { validateData } from \"../utils/validate\";\n\nconst Login = () =&gt; {\n  const [isSignIn, setIsSignIn] = useState(true);\n  const [errors, setErrors] = useState({});\n\n  const emailRef = useRef();\n  const passwordRef = useRef();\n  const fullnameRef = useRef();\n\n  const toggleForm = () =&gt; setIsSignIn(!isSignIn);\n\n  const handleSubmit = () =&gt; {\n    const formData = {\n      email: emailRef.current.value,\n      password: passwordRef.current.value,\n      fullname: isSignIn ? undefined : fullnameRef.current.value,\n    };\n    const validationErrors = validateData(formData, isSignIn);\n    setErrors(validationErrors);\n  };\n\n  return (\n    &lt;div\n      className=\"bg-center bg-cover h-screen\"\n      style={{ backgroundImage: `url(${bgImage})` }}\n    &gt;\n      &lt;Header /&gt;\n      &lt;div&gt;\n        &lt;div&gt;\n          &lt;h1&gt;\n            {isSignIn ? \"Sign In\" : \"Sign Up\"}\n          &lt;/h1&gt;\n          &lt;form\n            onSubmit={(e) =&gt; e.preventDefault()}\n          &gt;\n            &lt;div&gt;\n              &lt;input\n                ref={emailRef}\n                type=\"email\"\n                placeholder=\"Email Address\"\n              /&gt;\n              {errors.email &amp;&amp; &lt;p&gt;{errors.email}&lt;/p&gt;}\n            &lt;/div&gt;\n\n            {!isSignIn &amp;&amp; (\n              &lt;div&gt;\n                &lt;input\n                  ref={fullnameRef}\n                  type=\"text\"\n                  placeholder=\"Full Name\"\n                /&gt;\n                {errors.fullname &amp;&amp; &lt;p&gt;{errors.fullname}&lt;/p&gt;}\n              &lt;/div&gt;\n            )}\n\n            &lt;div&gt;\n              &lt;input\n                ref={passwordRef}\n                type=\"password\"\n                placeholder=\"Password\"\n              /&gt;\n              {errors.password &amp;&amp; &lt;p className=\"text-red-500 text-sm\"&gt;{errors.password}&lt;/p&gt;}\n            &lt;/div&gt;\n\n            &lt;button\n              type=\"submit\"\n              className=\"w-full bg-red-600 text-white p-2 rounded hover:bg-red-700\"\n              onClick={handleSubmit}\n            &gt;\n              {isSignIn ? \"Sign In\" : \"Sign Up\"}\n            &lt;/button&gt;\n          &lt;/form&gt;\n          &lt;p className=\"text-gray-300 text-sm text-center\"&gt;\n            {isSignIn ? \"New here?\" : \"Already have an account?\"}\n            &lt;span\n              className=\"text-white ml-1 cursor-pointer\"\n              onClick={toggleForm}\n            &gt;\n              {isSignIn ? \"Sign Up\" : \"Sign In\"}\n            &lt;/span&gt;\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Login;\n</code></pre>"},{"location":"react/useRef-hook/#how-useref-is-utilized-in-the-login-component","title":"\ud83d\udcca How <code>useRef</code> is Utilized in the Login Component","text":"<p>In the <code>Login</code> component, <code>useRef</code> is employed to manage form input fields efficiently. Here's a breakdown of how it's used:</p> <ol> <li> <p>Creating References:</p> <pre><code>const emailRef = useRef();\nconst passwordRef = useRef();\nconst fullnameRef = useRef();\n</code></pre> <ul> <li><code>emailRef</code>: References the email input field.</li> <li><code>passwordRef</code>: References the password input field.</li> <li><code>fullnameRef</code>: References the fullname input field (only visible during sign-up).</li> </ul> </li> <li> <p>Attaching References to DOM Elements:</p> <p>Each input field is linked to its corresponding ref using the <code>ref</code> attribute.</p> <pre><code>&lt;input\n    ref={emailRef}\n    type=\"email\"\n    placeholder=\"Email Address\"\n    /* ...other props */\n/&gt;\n\n&lt;input\n    ref={passwordRef}\n    type=\"password\"\n    placeholder=\"Password\"\n    /* ...other props */\n/&gt;\n\n{!isSignIn &amp;&amp; (\n    &lt;input\n    ref={fullnameRef}\n    type=\"text\"\n    placeholder=\"Full Name\"\n    /* ...other props */\n    /&gt;\n)}\n</code></pre> </li> <li> <p>Accessing Input Values:</p> <p>When the user submits the form by clicking the button, the <code>handleSubmit</code> function accesses the current values of each input field using the <code>.current.value</code> property of the respective refs.</p> <pre><code>const handleSubmit = () =&gt; {\n    const formData = {\n    email: emailRef.current.value,\n    password: passwordRef.current.value,\n    fullname: isSignIn ? undefined : fullnameRef.current.value,\n    };\n    const validationErrors = validateData(formData, isSignIn);\n    setErrors(validationErrors);\n};\n</code></pre> </li> <li> <p>Advantages in This Context:</p> <ul> <li>Simplified Form Handling: By using refs, there's no need to bind state variables to each input field, reducing the complexity of state management.</li> <li>Performance Optimization: Since updating refs doesn't trigger re-renders, the component remains performant, especially beneficial for forms with many fields.</li> <li>Direct Access: Provides straightforward access to input values for validation or other operations without intermediary steps.</li> </ul> </li> </ol>"},{"location":"react/useRef-hook/#useref-vs-usestate","title":"\u2696\ufe0f <code>useRef</code> vs. <code>useState</code>","text":"<p>While both <code>useRef</code> and <code>useState</code> can hold values, they serve different purposes:</p> <ul> <li><code>useState</code>:</li> <li>Ideal for values that influence what gets rendered.</li> <li>Updating state triggers a re-render of the component.</li> <li> <p>Suitable for form inputs when you need to display or react to user input in real-time.</p> </li> <li> <p><code>useRef</code>:</p> </li> <li>Best for values that persist across renders but don't need to trigger re-renders when changed.</li> <li>Ideal for accessing DOM elements directly or storing mutable values like timers or previous state values.</li> <li>Prevents unnecessary re-renders, enhancing performance for certain use cases.</li> </ul>"},{"location":"react/useRef-hook/#caveats-and-pitfalls-of-using-useref","title":"\u26a0\ufe0f Caveats and Pitfalls of Using <code>useRef</code>","text":"<p>While <code>useRef</code> is a powerful tool in React, it's essential to use it judiciously to avoid common mistakes and potential issues. Here are some caveats and pitfalls to be aware of, along with examples to illustrate each point:</p>"},{"location":"react/useRef-hook/#1-bypassing-reacts-declarative-model","title":"1. Bypassing React's Declarative Model","text":"<p>Danger</p> <p>Using <code>useRef</code> to manipulate DOM elements directly can interfere with React's declarative approach, making the code harder to understand and maintain.</p> <p>Example: Inconsistent UI State</p> <p>Imagine a scenario where you use <code>useRef</code> to update an input's value directly, bypassing React's state management:</p> <pre><code>import React, { useRef } from 'react';\n\nconst InconsistentInput = () =&gt; {\nconst inputRef = useRef(null);\n\nconst updateInput = () =&gt; {\n    inputRef.current.value = \"Updated via useRef!\";\n    // React is unaware of this change\n};\n\nreturn (\n    &lt;div&gt;\n    &lt;input ref={inputRef} type=\"text\" /&gt;\n    &lt;button onClick={updateInput}&gt;Update Input&lt;/button&gt;\n    &lt;/div&gt;\n);\n};\n\nexport default InconsistentInput;\n</code></pre> <p>In this example:</p> <ul> <li>Clicking the \"Update Input\" button changes the input's value directly.</li> <li>However, React remains unaware of this update since it's not using state.</li> <li>If other parts of the component rely on the input's value via state, inconsistencies can arise.</li> </ul> <p>Solution</p> <p>Prefer controlled components using <code>useState</code> for form inputs and UI interactions unless there's a compelling reason to manipulate the DOM directly.</p> <pre><code>import React, { useState } from 'react';\n\nconst ControlledInput = () =&gt; {\nconst [value, setValue] = useState('');\n\nconst updateInput = () =&gt; {\n    setValue(\"Updated via useState!\");\n};\n\nreturn (\n    &lt;div&gt;\n    &lt;input\n        type=\"text\"\n        value={value}\n        onChange={(e) =&gt; setValue(e.target.value)}\n    /&gt;\n    &lt;button onClick={updateInput}&gt;Update Input&lt;/button&gt;\n    &lt;/div&gt;\n);\n};\n\nexport default ControlledInput;\n</code></pre>"},{"location":"react/useRef-hook/#2-potential-for-stale-or-inconsistent-data","title":"2. Potential for Stale or Inconsistent Data","text":"<p>Bug</p> <p>Since updating a ref does not trigger a re-render, there's a risk of the UI displaying outdated information if the ref's value changes but the component doesn't re-render to reflect those changes.</p> <p>Example: Stale Data in Event Handlers</p> <p>Consider a counter using <code>useRef</code> to track the current count without re-rendering:</p> <pre><code>import React, { useRef } from 'react';\n\nconst StaleCounter = () =&gt; {\n  const countRef = useRef(0);\n\n  const handleClick = () =&gt; {\n    countRef.current += 1;\n    console.log(`Current count: ${countRef.current}`);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Counter: {countRef.current}&lt;/p&gt; {/* Always displays 0 */}\n      &lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default StaleCounter;\n</code></pre> <p>In this example:</p> <ul> <li>Clicking \"Increment\" increases <code>countRef.current</code> and logs it.</li> <li>However, the displayed counter (<code>countRef.current</code>) remains <code>0</code> because the component doesn't re-render.</li> </ul> <p>Solution</p> <p>Use <code>useState</code> for values that need to be reflected in the UI to ensure consistency.</p> <pre><code>import React, { useState } from 'react';\n\nconst PersistentCounter = () =&gt; {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    setCount(prev =&gt; prev + 1);\n    console.log(`Current count: ${count + 1}`);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Counter: {count}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default PersistentCounter;\n</code></pre>"},{"location":"react/useRef-hook/#3-overusing-refs-for-state-management","title":"3. Overusing Refs for State Management","text":"<p>Bug</p> <p>Relying heavily on <code>useRef</code> for managing state can lead to code that's difficult to debug and reason about, as it sidesteps React's state management patterns.</p> <p>Example: Managing Multiple States with Refs</p> <pre><code>import React, { useRef } from 'react';\n\nconst OverusedRefs = () =&gt; {\n  const firstNameRef = useRef('');\n  const lastNameRef = useRef('');\n  const emailRef = useRef('');\n\n  const handleSubmit = () =&gt; {\n    console.log(`Name: ${firstNameRef.current} ${lastNameRef.current}`);\n    console.log(`Email: ${emailRef.current}`);\n  };\n\n  return (\n    &lt;form onSubmit={(e) =&gt; { e.preventDefault(); handleSubmit(); }}&gt;\n      &lt;input type=\"text\" placeholder=\"First Name\" onChange={(e) =&gt; { firstNameRef.current = e.target.value; }} /&gt;\n      &lt;input type=\"text\" placeholder=\"Last Name\" onChange={(e) =&gt; { lastNameRef.current = e.target.value; }} /&gt;\n      &lt;input type=\"email\" placeholder=\"Email\" onChange={(e) =&gt; { emailRef.current = e.target.value; }} /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n};\n\nexport default OverusedRefs;\n</code></pre> <p>In this example:</p> <ul> <li>Managing multiple form fields with <code>useRef</code> complicates the component.</li> <li>It becomes harder to track changes, validate inputs, and manage stateful behaviors.</li> <li>Debugging becomes more challenging due to the lack of a centralized state.</li> </ul> <p>Solution</p> <p>Use <code>useState</code> or form management libraries like Formik or React Hook Form for handling multiple form inputs efficiently.</p> <pre><code>import React, { useState } from 'react';\n\nconst ControlledForm = () =&gt; {\n  const [form, setForm] = useState({ firstName: '', lastName: '', email: '' });\n\n  const handleChange = (e) =&gt; {\n    const { name, value } = e.target;\n    setForm(prev =&gt; ({ ...prev, [name]: value }));\n  };\n\n  const handleSubmit = () =&gt; {\n    console.log(`Name: ${form.firstName} ${form.lastName}`);\n    console.log(`Email: ${form.email}`);\n  };\n\n  return (\n    &lt;form onSubmit={(e) =&gt; { e.preventDefault(); handleSubmit(); }}&gt;\n      &lt;input name=\"firstName\" type=\"text\" placeholder=\"First Name\" value={form.firstName} onChange={handleChange} /&gt;\n      &lt;input name=\"lastName\" type=\"text\" placeholder=\"Last Name\" value={form.lastName} onChange={handleChange} /&gt;\n      &lt;input name=\"email\" type=\"email\" placeholder=\"Email\" value={form.email} onChange={handleChange} /&gt;\n      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n  );\n};\n\nexport default ControlledForm;\n</code></pre>"},{"location":"react/useRef-hook/#4-memory-leaks-with-unmanaged-refs","title":"4. Memory Leaks with Unmanaged Refs","text":"<p>Bug</p> <p>If refs are used to store subscriptions, event listeners, or instances of third-party libraries without proper cleanup, it can lead to memory leaks.</p> <p>Example: Unmanaged Event Listener</p> <pre><code>import React, { useRef, useEffect } from 'react';\n\nconst MemoryLeakComponent = () =&gt; {\n  const buttonRef = useRef(null);\n\n  useEffect(() =&gt; {\n    const handleClick = () =&gt; console.log('Button clicked!');\n    const button = buttonRef.current;\n    button.addEventListener('click', handleClick);\n\n    // Missing cleanup\n  }, []);\n\n  return &lt;button ref={buttonRef}&gt;Click Me&lt;/button&gt;;\n};\n\nexport default MemoryLeakComponent;\n</code></pre> <p>In this example:</p> <ul> <li>An event listener is added to the button using <code>useRef</code>.</li> <li>The <code>useEffect</code> hook does not return a cleanup function to remove the event listener.</li> <li>If the component unmounts, the event listener remains, causing a memory leak.</li> </ul> <p>Solution</p> <p>Always clean up side effects in the <code>useEffect</code> cleanup function when using refs for subscriptions or event listeners.</p> <pre><code>import React, { useRef, useEffect } from 'react';\n\nconst ManagedMemoryLeakComponent = () =&gt; {\n  const buttonRef = useRef(null);\n\n  useEffect(() =&gt; {\n    const handleClick = () =&gt; console.log('Button clicked!');\n    const button = buttonRef.current;\n    button.addEventListener('click', handleClick);\n\n    return () =&gt; {\n      button.removeEventListener('click', handleClick);\n    };\n  }, []);\n\n  return &lt;button ref={buttonRef}&gt;Click Me&lt;/button&gt;;\n};\n\nexport default ManagedMemoryLeakComponent;\n</code></pre>"},{"location":"react/useRef-hook/#5-refs-not-updating-immediately","title":"5. Refs Not Updating Immediately","text":"<p>Bug</p> <p>Updates to refs are synchronous, but accessing them immediately after setting can sometimes lead to unexpected behaviors, especially within event handlers.</p> <p>Example: Immediate Access After Update</p> <pre><code>import React, { useRef } from 'react';\n\nconst ImmediateAccessRef = () =&gt; {\n  const inputRef = useRef('');\n\n  const handleChange = (e) =&gt; {\n    inputRef.current = e.target.value;\n    console.log(inputRef.current); // Always logs the latest value\n  };\n\n  const handleSubmit = () =&gt; {\n    // Trying to use inputRef.current here works fine\n    console.log(`Submitted value: ${inputRef.current}`);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;input type=\"text\" onChange={handleChange} /&gt;\n      &lt;button onClick={handleSubmit}&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ImmediateAccessRef;\n</code></pre> <p>While this example works as expected, issues can arise in more complex scenarios where multiple updates happen in quick succession or within nested events, leading to potential inconsistencies.</p> <p>Solution</p> <p>To ensure the latest value is accessed, use the updated ref value within the next render cycle or within a <code>useEffect</code> hook to guarantee the value is up-to-date.</p>"},{"location":"react/useRef-hook/#6-server-side-rendering-ssr-considerations","title":"6. Server-Side Rendering (SSR) Considerations","text":"<p>Bug</p> <p>Accessing DOM elements via refs doesn't make sense in a server-side rendering context, as the DOM isn't available.</p> <p>Example: Ref Access in SSR</p> <pre><code>import React, { useRef, useEffect } from 'react';\n\nconst SSRComponent = () =&gt; {\n  const divRef = useRef(null);\n\n  useEffect(() =&gt; {\n    // This will run only on the client, not on the server\n    if (divRef.current) {\n      console.log('Div dimensions:', divRef.current.getBoundingClientRect());\n    }\n  }, []);\n\n  return &lt;div ref={divRef}&gt;Hello, world!&lt;/div&gt;;\n};\n\nexport default SSRComponent;\n</code></pre> <p>In this example:</p> <ul> <li><code>useRef</code> is used to access the div's dimensions.</li> <li>During server-side rendering, <code>useEffect</code> doesn't run, so no errors occur.</li> <li>However, attempting to access <code>divRef.current</code> outside of <code>useEffect</code> could cause issues.</li> </ul> <p>Solution</p> <p>Ensure that any ref-based DOM manipulations occur within <code>useEffect</code> or conditional checks that verify the presence of the DOM.</p> <pre><code>import React, { useRef, useEffect } from 'react';\n\nconst SafeSSRComponent = () =&gt; {\n  const divRef = useRef(null);\n\n  useEffect(() =&gt; {\n    if (typeof window !== 'undefined' &amp;&amp; divRef.current) {\n      console.log('Div dimensions:', divRef.current.getBoundingClientRect());\n    }\n  }, []);\n\n  return &lt;div ref={divRef}&gt;Hello, world!&lt;/div&gt;;\n};\n\nexport default SafeSSRComponent;\n</code></pre>"},{"location":"react/useRef-hook/#best-practices","title":"\ud83d\udcda Best Practices","text":"<ul> <li> <p> Use When Necessary</p> <p>Prefer <code>useState</code> for managing form inputs unless there's a specific need to avoid re-renders.</p> </li> <li> <p> Avoid Overuse</p> <p>Relying heavily on refs for state management can lead to code that's hard to maintain and debug.</p> </li> <li> <p> Encapsulate Logic</p> <p>For complex interactions, consider encapsulating ref-related logic within custom hooks to keep components clean.</p> </li> <li> <p> Cleanup Effects</p> <p>When using refs for side effects (like event listeners or third-party libraries), ensure you clean them up appropriately to prevent memory leaks.</p> </li> <li> <p> Combine with <code>useEffect</code></p> <p>When working with refs that interact with the DOM, use <code>useEffect</code> to handle side effects after the component has rendered.</p> </li> </ul>"},{"location":"react/useRef-hook/#summary","title":"\ud83d\udcdd Summary","text":"<p>The <code>useRef</code> hook is a powerful tool in React for managing mutable values and interacting directly with DOM elements without the overhead of state management. In the provided <code>Login</code> component example, <code>useRef</code> simplifies form handling by providing direct access to input values, enhancing both performance and code readability. However, it's crucial to use <code>useRef</code> judiciously to avoid bypassing React's declarative patterns and to prevent potential issues like memory leaks or inconsistent UI states.</p> <p>Understanding the caveats and pitfalls of <code>useRef</code>, such as memory leaks and inconsistent UI states, is essential for building efficient and maintainable React applications. By adhering to best practices and being mindful of potential issues, you can leverage <code>useRef</code> effectively without compromising the integrity of your components.</p>"},{"location":"reference/","title":"Reference","text":"<p>Material for MkDocs is packed with many great features that make technical writing a joyful activity. This section of the documentation explains how to set up a page, and showcases all available specimen that can be used directly from within Markdown files.</p> <p>For more information on how to use Material for MkDocs, please refer to the official documentation.</p> <p>Visit Official Documentation </p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/category/tutorial/","title":"Tutorial","text":""},{"location":"blog/category/pdf/","title":"PDF","text":""},{"location":"blog/category/google-drive/","title":"Google Drive","text":""}]}